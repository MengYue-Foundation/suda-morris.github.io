<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kdm | WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/blog/categories/kdm/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-06-20T15:14:34+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[cpu_init.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/19/cpu-init-dot-s/"/>
    <updated>2015-06-19T17:28:03+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/19/cpu-init-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;config.h&gt;                     /*里面包含mini6410.h*/
#include &lt;s3c6410.h&gt;

    .globl mem_ctrl_asm_init
mem_ctrl_asm_init:
    ldr r0, =ELFIN_MEM_SYS_CFG          @Memory sussystem address 0x7e00f120
    mov r1, #0xd                        @ Xm0CSn2 = NFCON CS0, Xm0CSn3 = NFCON CS1
    str r1, [r0]

    ldr r0, =ELFIN_DMC1_BASE            @DMC1 base address 0x7e001000

/* 1. 使dramc进入"config"状态 */
    ldr r1, =0x04
    str r1, [r0, #INDEX_DMC_MEMC_CMD]   

/* 2. 设置timing parameter*/
    ldr r1, =DMC_DDR_REFRESH_PRD
    str r1, [r0, #INDEX_DMC_REFRESH_PRD]        /*刷新周期7.8us */

    ldr r1, =DMC_DDR_CAS_LATENCY
    str r1, [r0, #INDEX_DMC_CAS_LATENCY]        /*CAS Latency:指的是内存存取数据所需的延迟时间，简单的说，就是内存接到CPU的指令后的反应速度。一般的参数值是2和3*/

    ldr r1, =DMC_DDR_t_DQSS
    str r1, [r0, #INDEX_DMC_T_DQSS]

    ldr r1, =DMC_DDR_t_MRD
    str r1, [r0, #INDEX_DMC_T_MRD]

    ldr r1, =DMC_DDR_t_RAS                      /*RAS=45ns*/
    str r1, [r0, #INDEX_DMC_T_RAS]

    ldr r1, =DMC_DDR_t_RC                       /*RC=68ns*/
    str r1, [r0, #INDEX_DMC_T_RC]

    ldr r1, =DMC_DDR_t_RCD
    ldr r2, =DMC_DDR_schedule_RCD
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RCD]

    ldr r1, =DMC_DDR_t_RFC
    ldr r2, =DMC_DDR_schedule_RFC
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RFC]

    ldr r1, =DMC_DDR_t_RP
    ldr r2, =DMC_DDR_schedule_RP
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RP]

    ldr r1, =DMC_DDR_t_RRD
    str r1, [r0, #INDEX_DMC_T_RRD]

    ldr r1, =DMC_DDR_t_WR
    str r1, [r0, #INDEX_DMC_T_WR]

    ldr r1, =DMC_DDR_t_WTR
    str r1, [r0, #INDEX_DMC_T_WTR]

    ldr r1, =DMC_DDR_t_XP
    str r1, [r0, #INDEX_DMC_T_XP]

    ldr r1, =DMC_DDR_t_XSR
    str r1, [r0, #INDEX_DMC_T_XSR]

    ldr r1, =DMC_DDR_t_ESR
    str r1, [r0, #INDEX_DMC_T_ESR]

/* 3.设置chip configuration*/
    ldr r1, =DMC1_MEM_CFG
    str r1, [r0, #INDEX_DMC_MEMORY_CFG]

    ldr r1, =DMC1_MEM_CFG2
    str r1, [r0, #INDEX_DMC_MEMORY_CFG2]

    ldr r1, =DMC1_CHIP0_CFG
    str r1, [r0, #INDEX_DMC_CHIP_0_CFG]

    ldr r1, =DMC_DDR_32_CFG
    str r1, [r0, #INDEX_DMC_USER_CONFIG]

/* 4. 初始化sdram */
    @DMC0 DDR Chip 0 configuration direct command reg
    ldr r1, =DMC_NOP0                                   /* NOP*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Precharge All
    ldr r1, =DMC_PA0                                    /*precharge*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Auto Refresh   2 time
    ldr r1, =DMC_AR0
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]                 /*auto refresh*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @MRS
    ldr r1, =DMC_mDDR_EMR0                              /*EMRS*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Mode Reg
    ldr r1, =DMC_mDDR_MR0                               /*MRS*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

#ifdef CONFIG_SMDK6410_X5A
    ldr r1, =DMC1_CHIP1_CFG
    str r1, [r0, #INDEX_DMC_CHIP_1_CFG]

    @DMC0 DDR Chip 0 configuration direct command reg
    ldr r1, =DMC_NOP1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Precharge All
    ldr r1, =DMC_PA1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Auto Refresh   2 time
    ldr r1, =DMC_AR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @MRS
    ldr r1, =DMC_mDDR_EMR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Mode Reg
    ldr r1, =DMC_mDDR_MR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]
#endif

/* 5. 使dramc进入"ready"状态   */
    @Enable DMC1
    mov r1, #0x0
    str r1, [r0, #INDEX_DMC_MEMC_CMD]

check_dmc1_ready:
    ldr r1, [r0, #INDEX_DMC_MEMC_STATUS]
    mov r2, #0x3
    and r1, r1, r2
    cmp r1, #0x1
    bne check_dmc1_ready
    nop
    mov pc, lr                              /*内存控制器初始化完毕，返回*/


/* Below code is for ARM926EJS and ARM1026EJS */
    .globl cleanDCache
cleanDCache:
    mrc p15, 0, pc, c7, c10, 3  /* test/clean D-Cache */
    bne cleanDCache
    mov pc, lr

    .globl cleanFlushDCache
cleanFlushDCache:
    mrc p15, 0, pc, c7, c14, 3  /* test/cleanflush D-Cache */
    bne cleanFlushDCache
    mov pc, lr

    .globl cleanFlushCache
cleanFlushCache:
    mrc p15, 0, pc, c7, c14, 3  /* test/cleanflush D-Cache */
    bne cleanFlushCache
    mcr p15, 0, r0, c7, c5, 0   /* flush I-Cache */
    mov pc, lr

    .ltorg
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lowlevel_init.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/18/lowlevel-init-dot-s/"/>
    <updated>2015-06-18T15:38:36+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/18/lowlevel-init-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;config.h&gt;
#include &lt;version.h&gt;
#include &lt;s3c6410.h&gt;
#include "mini6410_val.h"

_TEXT_BASE:
    .word   TEXT_BASE

    .globl lowlevel_init
lowlevel_init:
    mov r12, lr                     /*bl指令会把下一条指令的地址赋给lr，在这里保存lr是为了最后能够成功地函数返回*/

    /* LED on only #8 */
    ldr r0, =ELFIN_GPIO_BASE        /*Regs.h中的宏定义，就是s3c6410.h中的宏定义*/
    ldr r1, =0x55540000
    str r1, [r0, #GPNCON_OFFSET]    /*GPN15~GPN9均是输出(01),GPN0~GPN8均是输入(00)*/

    ldr r1, =0x55555555
    str r1, [r0, #GPNPUD_OFFSET]    /*GPN0~GPN15均是下拉使能*/

    ldr r1, =0xf000
    str r1, [r0, #GPNDAT_OFFSET]    /*GPN15~GPN12输出高电平，GPN10~11输出低电平*/

    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x1
    str r1, [r0, #GPECON_OFFSET]    /*GPE0设置为输出，GPE1~GPE15设置为输入*/
    ldr r1, =0x0
    str r1, [r0, #GPEDAT_OFFSET]    /*GPE0输出低电平*/

    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x2A5AAAAA
    str r1, [r0, #GPPCON_OFFSET]    /*GPP15设置为输入，GPP11~GPP10设置为输出，其余设置为片内外设功能*/
    ldr r1, =0x0
    str r1, [r0, #GPPDAT_OFFSET]    /*GPP11和GPP10输出低电平*/


    ldr r1, =0x55555555
    str r1, [r0, #MEM1DRVCON_OFFSET]    /*由于ddr芯片的工作电压在1.8V，所以驱动电流设置为7mA*/

    /* Disable Watchdog */              /*关闭片内看门狗*/
    ldr r0, =0x7e000000     @0x7e004000
    orr r0, r0, #0x4000
    mov r1, #0
    str r1, [r0]

    @ External interrupt pending clear
    ldr r0, =(ELFIN_GPIO_BASE+EINTPEND_OFFSET)  /*EINTPEND*/
    ldr r1, [r0]                        /*读一次外部中断就能清楚外部中断信号*/
    str r1, [r0]

    ldr r0, =ELFIN_VIC0_BASE_ADDR   @0x71200000
    ldr r1, =ELFIN_VIC1_BASE_ADDR   @0x71300000

    @ Disable all interrupts (VIC0 and VIC1)
    mvn r3, #0x0                        /*0取反为全1*/
    str r3, [r0, #oINTMSK]              /*禁用所有中断*/
    str r3, [r1, #oINTMSK]

    @ Set all interrupts as IRQ
    mov r3, #0x0
    str r3, [r0, #oINTMOD]              /*将所有中断设置为IRQ中断*/
    str r3, [r1, #oINTMOD]

    @ Pending Interrupt Clear
    mov r3, #0x0                        /*清除所有当前激活的中断服务程序的地址*/
    str r3, [r0, #oVECTADDR]
    str r3, [r1, #oVECTADDR]

    /* init system clock */
    bl system_clock_init                /*初始化系统时钟*/

    /* for UART */
    bl uart_asm_init                    /*初始化串口*/

#if defined(CONFIG_NAND)
    /* simple init for NAND */
    bl nand_asm_init                    /*nand flash初始化*/
#endif

    bl  mem_ctrl_asm_init               /*内存控制器初始化,函数位于/CPU/s3c6410/CPU_init.S*/

    ldr     r0, =(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)       /*7e00_f904-&gt;RST_STAT*/
    ldr     r1, [r0]
    bic     r1, r1, #0xfffffff7
    cmp     r1, #0x8                    /*bit[3]=1,表明从SLEEP状态中唤醒*/
    beq     wakeup_reset

1:
    ldr r0, =ELFIN_UART_BASE
    ldr r1, =0x4b4b4b4b                 /*通过串口发送字母“K”*/
    str r1, [r0, #UTXH_OFFSET]

    mov lr, r12
    mov pc, lr                          /*lowlevel_init结束，返回*/

wakeup_reset:

    ldr r0, =(ELFIN_CLOCK_POWER_BASE+WAKEUP_STAT_OFFSET)
    ldr r1, [r0]
    str r1, [r0]                        /*Clear wakeup status register*/

    /*LED test*/
    ldr     r0, =ELFIN_GPIO_BASE
    ldr     r1, =0x3000
    str     r1, [r0, #GPNDAT_OFFSET]

    /*Load return address and jump to kernel*/
    ldr r0, =(ELFIN_CLOCK_POWER_BASE+INF_REG0_OFFSET)       /*0x4c00_0a00-&gt;INFORM0*/
    ldr r1, [r0]                                            /* r1 = physical address of s3c6400_cpu_resume function*/
    mov pc, r1                                              /*Jump to kernel (sleep-s3c6400.S)*/
    nop
    nop

/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
    ldr r0, =ELFIN_CLOCK_POWER_BASE @0x7e00f000

#ifdef  CONFIG_SYNC_MODE
    ldr r1, [r0, #OTHERS_OFFSET]
    mov r2, #0x40
    orr r1, r1, r2
    str r1, [r0, #OTHERS_OFFSET]                

    nop
    nop
    nop
    nop
    nop

    ldr r2, =0x80
    orr r1, r1, r2
    str r1, [r0, #OTHERS_OFFSET]            /*bit[6],bit[7]都置1，设置成同步模式*/

check_syncack:                              /*等待时钟完成同步*/
    ldr r1, [r0, #OTHERS_OFFSET]
    ldr r2, =0xf00
    and r1, r1, r2                          /*只查看bit[8]~bit[11]，这几位是SYNC mode相应位，只读,只有在AYNC模式才能读1*/
    cmp r1, #0xf00
    bne check_syncack
#else                                       /* 否则配置成异步时钟模式 */
    nop
    nop
    nop
    nop
    nop

    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0xC0
    orr r1, r1, #0x40                       /*bit[6]置1，bit[7]清0*/
    str r1, [r0, #OTHERS_OFFSET]            

wait_for_async:
    ldr r1, [r0, #OTHERS_OFFSET]
    and r1, r1, #0xf00
    cmp r1, #0x0
    bne wait_for_async

    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0x40                       /*bit[6]清0*/
    str r1, [r0, #OTHERS_OFFSET]
#endif

    mov r1, #0xff00
    orr r1, r1, #0xff                       /*设置各PLL的LOCK_TIME,使用最大值*/
    str r1, [r0, #APLL_LOCK_OFFSET]         /*APLL_LOCK，供cpu使用*/ 
    str r1, [r0, #MPLL_LOCK_OFFSET]         /*MPLL_LOCK，供AHB(存储/中断/lcd等控制器)/APB(看门狗，定时器，SD等)总线上的设备使用*/
    str r1, [r0, #EPLL_LOCK_OFFSET]         /*EPLL_LOCK，供UART,IIS,IIC使用*/

#if defined(CONFIG_CLKSRC_CLKUART)
    ldr     r1, [r0, #CLK_DIV2_OFFSET]
    bic r1, r1, #0x70000
    orr r1, r1, #0x30000                    /*CLK_DIV2的bit[16]~bit[19]即UART_RATIO,设置为3,CLKUART(66.5Mhz)=CLKUART_input(532/2=266Mhz)/(UART_RATIO(3)+1)*/
    str r1, [r0, #CLK_DIV2_OFFSET]
#endif

    ldr     r1, [r0, #CLK_DIV0_OFFSET]      /*Set Clock Divider*/
    bic r1, r1, #0x30000
    bic r1, r1, #0xff00
    bic r1, r1, #0xff
    ldr r2, =CLK_DIV_VAL
    orr r1, r1, r2
    str r1, [r0, #CLK_DIV0_OFFSET]          /*设置时钟的分频系数*/

    ldr r1, =APLL_VAL                       /*设置APLL_MDIV=266,APLL_PDIV=3,APLL_SDIV=1*/
    str r1, [r0, #APLL_CON_OFFSET]          /*FOUT = MDIV X FIN / (PDIV X 2^SDIV) = 266*12/(3*2^1) = 532MHz*/
    ldr r1, =MPLL_VAL                       /*设置MPLL_MDIV=266,MPLL_PDIV=3,MPLL_SDIV=1*/
    str r1, [r0, #MPLL_CON_OFFSET]          /*FOUT = MDIV X FIN / (PDIV X 2^SDIV) = 266*12/(3*2^1) = 532MHz*/

    ldr r1, =0x80200102                     /*设置EPLL_MDIV=32,EPLL_PDIV=1,EPLL_SDIV=2*/
    str r1, [r0, #EPLL_CON0_OFFSET]         /*FOUT = (MDIV+KDIV/2^16) X FIN / (PDIV X 2^SDIV) = (32+0)*12/(1*2^2) = 96MHz*/
    ldr r1, =0x0                            /*设置EPLL_KDIV=0*/
    str r1, [r0, #EPLL_CON1_OFFSET]

    ldr r1, [r0, #CLK_SRC_OFFSET]           /*读取CLK_SRC寄存器的值*/

#if defined(CONFIG_CLKSRC_CLKUART)
    ldr r2, =0x2007                                 
#else
    ldr r2, =0x7
#endif
    orr r1, r1, r2                          /*APLL,MPLL,EPLL的时钟源选择各自的Fout；UART的时钟源选择DOUT_MPLL*/

    str r1, [r0, #CLK_SRC_OFFSET]

    mov r1, #0x10000                        /*等待所有时钟稳定，至少200us*/
1:  subs    r1, r1, #1                      /*非0则跳转*/
    bne 1b

#ifdef CONFIG_SYNC_MODE                     /* Synchronization for VIC port */
    ldr r1, [r0, #OTHERS_OFFSET]
    orr r1, r1, #0x20
    str r1, [r0, #OTHERS_OFFSET]
#else
    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0x20
    str r1, [r0, #OTHERS_OFFSET]
#endif

    mov pc, lr                              /*系统时钟初始化完成，返回*/


/*
 * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
 * void uart_asm_init(void)
 */
uart_asm_init:
    /*配置GPIO的功能为串口UART*/
    /*UART0_RXD=GPA0,UART0_TXD=GPA1,UART1_RXD=GPA4,UART1_TXD=GPA5*/
    /*UART2_RXD=GPB0,UART2_TXD=GPB1,UART3_RXD=GPB2,UART3_TXD=GPB3*/
    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x22222222
    str     r1, [r0, #GPACON_OFFSET]        /*配置UART0和UART1使用的GPIO引脚,UART0和UART1具有流控功能(GPA0~GPA7)*/
    ldr r1, =0x2222
    str     r1, [r0, #GPBCON_OFFSET]        /*配置UART2和UART3使用的GPIO引脚,UART2和UART3不具有流控功能(GPB0~GPB3)*/

    ldr r0, =ELFIN_UART_CONSOLE_BASE        /*ELFIN_UART_CONSOLE_BASE=0x7F005000,即UART0*/
    mov r1, #0x0
    str r1, [r0, #UFCON_OFFSET]             /*禁止使用FIFO*/
    str r1, [r0, #UMCON_OFFSET]             /*禁止流控，调制解调功能*/

    mov r1, #0x3                            /*配置UART0：数据位:8, 无校验, 停止位: 1, 8n1*/
    str r1, [r0, #ULCON_OFFSET]

/*设置波特率 */
/*DIV_VAL = (EXT_UCLK1 / (bps x 16 ) ) - 1 = (66500000/(115200x16))-1 = 35.08*/
/*DIV_VAL = 35.08 = UBRDIVn + (num of 1’s in UDIVSLOTn)/16*/
#if defined(CONFIG_CLKSRC_CLKUART)
    ldr r1, =0xe45                          /* UARTCLK_SRC=11 =&gt; EXT_UCLK1,EXT_UCLK1由MPLL或者EPLL分频得到,这里是66.5MHz。串口数据接收发送采用轮训或者中断的方式*/
#else
    ldr r1, =0x245                          /* UARTCLK_SRC=x0 =&gt; PCLK */
#endif
    str r1, [r0, #UCON_OFFSET]

#if defined(CONFIG_UART_50)
    ldr r1, =0x1A
#elif defined(CONFIG_UART_66)
    ldr r1, =0x23
#else
    ldr r1, =0x1A
#endif
    str r1, [r0, #UBRDIV_OFFSET]            /*UBRDIV0=35*/

#if defined(CONFIG_UART_50)
    ldr r1, =0x3
#elif defined(CONFIG_UART_66)
    ldr r1, =0x0080
#else
    ldr r1, =0x3
#endif
    str r1, [r0, #UDIVSLOT_OFFSET]          /*UDIVSLOT0中有1个‘1’*/

    ldr r1, =0x4f4f4f4f
    str r1, [r0, #UTXH_OFFSET]              /*UART0串口发送字母‘O’*/

    mov pc, lr                              /*串口配置结束，返回*/

/*
 * Nand Interface Init for SMDK6410 
 * /
nand_asm_init:                              /*初始化NandFlash控制器*/
    ldr r0, =ELFIN_NAND_BASE
    ldr r1, [r0, #NFCONF_OFFSET]
    orr r1, r1, #0x70                       /*TWRPH1=7*/
    orr r1, r1, #0x7700                     /*TWRPH0=7,TACLS=7*/
    str     r1, [r0, #NFCONF_OFFSET]

    ldr r1, [r0, #NFCONT_OFFSET]
    orr r1, r1, #0x03                       /*使能NandFlash控制器*/
    str     r1, [r0, #NFCONT_OFFSET]

    mov pc, lr                              /*NandFlash控制器初始化完毕，返回*/


#ifdef CONFIG_ENABLE_MMU
                                            /*为Uboot服务的MMU页表在这里创建*/
                                            /* form a first-level section entry */
/*定义一个可以生成描述符的宏*/
/*描述符的最低两位00为无效，01为二级页表方式（由高地址12位的一级页表(TTB的高18位指定的虚拟基地址)位置取出对应二级页表(coarse page table)的基地址，由中间地址8位的二级页表取出对应4KB页表（small page）的基地址，最后由低12为地址的页表取出最终的内存值），10为一级页表方式（如果bit18为0，则为section，bit18为1，则为supersection），11保留。*/
.macro FL_SECTION_ENTRY base,ap,d,c,b       
    .word (\base &lt;&lt; 20) | (\ap &lt;&lt; 10) | \
          (\d &lt;&lt; 5) | (1&lt;&lt;4) | (\c &lt;&lt; 3) | (\b &lt;&lt; 2) | (1&lt;&lt;1)
.endm

/*按照section方式映射，每个section必须是1M，占20位地址，这里共256M物理内存，映射到整个4G地址空间，所以共有4096（0x1000）个描述符。虚拟地址的高12位（4096）作为描述符位置，低20位作为section里面的地址*/
.section .mmudata, "a"                      /*指名该段的名称是.mmudata,在u-boot.lds中会为该段分配具体的空间，.a表示这是一个需要鉴权的段*/
    .align 14                               /*对齐到0x4000*/
    // the following alignment creates the mmu table at address 0x4000.
    .globl mmu_table                        /*mmu页表地址需要在start.S中告诉CPU以启动MMU，因此需要声明为全局变量*/
mmu_table:
    .set __base,0
    // 1:1 mapping for debugging
    .rept 0xA00                             /*共2048个描述符*/
    FL_SECTION_ENTRY __base,3,0,0,0         /*ap为3表示读允许,d为0表示这些描述符都属于domain0，domain用来做权限控制,c和b为0表示共享，互斥读写*/
    .set __base,__base+1
    .endr

    // access is not allowed.
    .rept 0xC00 - 0xA00                     /*共512个描述符*/
    .word 0x00000000                        /*ap为0表示不允许访问*/
    .endr

    // 128MB for SDRAM 0xC0000000 -&gt; 0x50000000
    .set __base, 0x500
    .rept 0xC80 - 0xC00                     /*共128个描述符*/
    FL_SECTION_ENTRY __base,3,0,1,1         /*ap为3表示读允许,d为0表示这些描述符都属于domain0，domain用来做权限控制,c和b为1表示内存输入输出都为回写模式*/
    .set __base,__base+1
    .endr

    // access is not allowed.
    .rept 0x1000 - 0xc80                        /*共896个描述符*/
    .word 0x00000000                        /*ap为0表示不允许访问*/
    .endr

#endif
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mini6410.h]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/17/mini6410-dot-h/"/>
    <updated>2015-06-17T11:49:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/17/mini6410-dot-h</id>
    <content type="html"><![CDATA[<pre><code class="C">#define CONFIG_S3C6410      1       /* in a SAMSUNG S3C6410 SoC */
#define CONFIG_S3C64XX      1       /* in a SAMSUNG S3C64XX Family  */
#define CONFIG_MINI6410     1       /* in a FriendlyARM MINI6410 Board */

#define CFG_UBOOT_SIZE      (2*1024*1024)   /*定义Uboot大小为2M字节*/

#define CONFIG_ENABLE_MMU   /*在Uboot中开启MMU,目的为了开启DCache来提高运行速度*/
#define MEMORY_BASE_ADDRESS 0x50000000  /*DDR起始地址*/
#define CFG_PHY_UBOOT_BASE  MEMORY_BASE_ADDRESS + 0x7e00000 /*Uboot的物理地址0x57e00000*/

#ifdef CONFIG_ENABLE_MMU
#define CFG_UBOOT_BASE      0xc7e00000
#else
#define CFG_UBOOT_BASE      0x57e00000
#endif

#define CFG_ENV_OFFSET      0x00040000      /*Uboot中环境变量偏移地址*/

#if defined(FRIENDLYARM_BOOT_MEDIA_NAND)    /*启动介质是NandFlash*/
#define CONFIG_BOOT_NAND
#elif defined(FRIENDLYARM_BOOT_MEDIA_SD)    /*启动介质是SD Card*/
#define CONFIG_BOOT_MOVINAND
#else
#error Boot media not defined
#endif

#define CONFIG_NAND
#define CONFIG_MOVINAND

#define CONFIG_MEMORY_UPPER_CODE

#undef CONFIG_USE_IRQ                       /* Uboot中不使用IRQ/FIQ*/



/******************************************系统时钟宏定义*******************************************/
#define CONFIG_CLK_532_133_66               /*FIN=12MHz,Fout=532MHz*/
#define APLL_MDIV   266
#define APLL_PDIV   3
#define APLL_SDIV   1
#define CONFIG_SYNC_MODE
#define set_pll(mdiv, pdiv, sdiv)   (1&lt;&lt;31 | mdiv&lt;&lt;16 | pdiv&lt;&lt;8 | sdiv)
#define APLL_VAL    set_pll(APLL_MDIV, APLL_PDIV, APLL_SDIV)
#define Startup_APLL    (CONFIG_SYS_CLK_FREQ/(APLL_PDIV&lt;&lt;APLL_SDIV)*APLL_MDIV)

#define MPLL_MDIV   266                     /* fixed MPLL 533MHz */
#define MPLL_PDIV   3
#define MPLL_SDIV   1
#define MPLL_VAL    set_pll(MPLL_MDIV, MPLL_PDIV, MPLL_SDIV)
#define Startup_MPLL    ((CONFIG_SYS_CLK_FREQ)/(MPLL_PDIV&lt;&lt;MPLL_SDIV)*MPLL_MDIV)

#define Startup_APLLdiv     0
#define Startup_HCLKx2div   1
#define Startup_PCLKdiv     3
#define Startup_HCLKdiv     1
#define Startup_MPLLdiv     1

#define CLK_DIV_VAL ((Startup_PCLKdiv&lt;&lt;12)|(Startup_HCLKx2div&lt;&lt;9)|(Startup_HCLKdiv&lt;&lt;8)|(Startup_MPLLdiv&lt;&lt;4)|Startup_APLLdiv)

#if defined(CONFIG_SYNC_MODE)
#define Startup_HCLK    (Startup_APLL/(Startup_HCLKx2div+1)/(Startup_HCLKdiv+1))
#else
#define Startup_HCLK    (Startup_MPLL/(Startup_HCLKx2div+1)/(Startup_HCLKdiv+1))
#endif

#define CONFIG_CLKSRC_CLKUART
#define CONFIG_UART_66                      /*CLKUART=66.5MHz*/



/*****************************************DDR控制器宏定义*******************************************/
#if defined(FRIENDLYARM_BOOT_RAM256)
#define DMC1_MEM_CFG        ((1&lt;&lt;30) | (2&lt;&lt;15) | (3&lt;&lt;3) | (2&lt;&lt;0))   /*column address(10):A0~A9;row address(14):A0~A13;Burst Length =4*/
#define DMC1_CHIP0_CFG      0x150F0                                 /*Bank-Row-Column organization */
#define PHYS_SDRAM_1_SIZE   0x10000000 /* 256 MB */
#elif defined(FRIENDLYARM_BOOT_RAM128)
#define DMC1_MEM_CFG        ((1&lt;&lt;30) | (2&lt;&lt;15) | (2&lt;&lt;3)| (2&lt;&lt;0))
#define DMC1_CHIP0_CFG      0x150F8
#define PHYS_SDRAM_1_SIZE   0x8000000 /* 128 MB */
#else
#error RAM size must be defined
#endif

#define DMC1_MEM_CFG2       0xB41       /*Memory with=32,Mobile DDR SDRAM,Read delay 1 cycle*/
#define DMC_DDR_32_CFG      0x0         

/* DDR Parameters */
#define DDR_tREFRESH        7800        /* ns */
#define DDR_tRAS        45      /* ns (min: 45ns)*/
#define DDR_tRC         68      /* ns (min: 67.5ns)*/
#define DDR_tRCD        23      /* ns (min: 22.5ns)*/
#define DDR_tRFC        80      /* ns (min: 80ns)*/
#define DDR_tRP         23      /* ns (min: 22.5ns)*/
#define DDR_tRRD        15      /* ns (min: 15ns)*/
#define DDR_tWR         15      /* ns (min: 15ns)*/
#define DDR_tXSR        120     /* ns (min: 120ns)*/
#define DDR_CASL        3       /* CAS Latency 3 */

#define DMC_DDR_BA_EMRS     2
#define DMC_DDR_MEM_CASLAT  3
#define DMC_DDR_CAS_LATENCY (DDR_CASL&lt;&lt;1)                       //6   Set Cas Latency to 3
#define DMC_DDR_t_DQSS      1                           // Min 0.75 ~ 1.25
#define DMC_DDR_t_MRD       2                           //Min 2 tck
#define DMC_DDR_t_RAS       (((Startup_HCLK / 1000 * DDR_tRAS) - 1) / 1000000 + 1)  //7, Min 45ns
#define DMC_DDR_t_RC        (((Startup_HCLK / 1000 * DDR_tRC) - 1) / 1000000 + 1)   //10, Min 67.5ns
#define DMC_DDR_t_RCD       (((Startup_HCLK / 1000 * DDR_tRCD) - 1) / 1000000 + 1)  //4,5(TRM), Min 22.5ns
#define DMC_DDR_schedule_RCD    ((DMC_DDR_t_RCD - 3) &lt;&lt; 3)
#define DMC_DDR_t_RFC       (((Startup_HCLK / 1000 * DDR_tRFC) - 1) / 1000000 + 1)  //11,18(TRM) Min 80ns
#define DMC_DDR_schedule_RFC    ((DMC_DDR_t_RFC - 3) &lt;&lt; 5)
#define DMC_DDR_t_RP        (((Startup_HCLK / 1000 * DDR_tRP) - 1) / 1000000 + 1)   //4, 5(TRM) Min 22.5ns
#define DMC_DDR_schedule_RP ((DMC_DDR_t_RP - 3) &lt;&lt; 3)
#define DMC_DDR_t_RRD       (((Startup_HCLK / 1000 * DDR_tRRD) - 1) / 1000000 + 1)  //3, Min 15ns
#define DMC_DDR_t_WR        (((Startup_HCLK / 1000 * DDR_tWR) - 1) / 1000000 + 1)   //Min 15ns
#define DMC_DDR_t_WTR       2
#define DMC_DDR_t_XP        2                           //1tck + tIS(1.5ns)
#define DMC_DDR_t_XSR       (((Startup_HCLK / 1000 * DDR_tXSR) - 1) / 1000000 + 1)  //17, Min 120ns
#define DMC_DDR_t_ESR       DMC_DDR_t_XSR
#define DMC_DDR_REFRESH_PRD (((Startup_HCLK / 1000 * DDR_tREFRESH) - 1) / 1000000)  // TRM 2656
#define DMC_DDR_USER_CONFIG 1                           // 2b01 : mDDR

#define CONFIG_NR_DRAM_BANKS    1      /* we have 2 bank of DRAM */
#define PHYS_SDRAM_1        MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[start.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/13/start-dot-s/"/>
    <updated>2015-06-13T23:15:44+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/13/start-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C start.S">#include &lt;config.h&gt;
#include &lt;version.h&gt;

#include &lt;regs.h&gt;       /*6410外设寄存器头文件*/

/*6410在Uboot中是开启MMU的，目的为了开启DCache来提高运行速度,CFG_PHY_UBOOT_BASE=0x57e00000*/
#ifndef CONFIG_ENABLE_MMU
#ifndef CFG_PHY_UBOOT_BASE
#define CFG_PHY_UBOOT_BASE  CFG_UBOOT_BASE
#endif
#endif

/*
 *************************************************************************
 *
 * Jump vector table as in table 3.1 in [1]
 *
 *************************************************************************
 */

.globl _start       /*在u-boot.lds中指明了ENTRY(_start),所以这里需要对外公开_start的地址*/
/*下面是异常向量表,地址范围0~0x20,正好8条指令，每条指令4字节*/
_start: b   reset   /*相对跳转指令，位置无关码*/
    ldr pc, _undefined_instruction  /*undefined异常由arm核译码单元检测，并触发未定义指令异常请求，硬件设置pc的值为0x4，强制程序从内存0x4地址执行指令*/
    ldr pc, _software_interrupt     /*arm中使用swi指令时触发软件中断，硬件设置PC的值为0x8，同时进入系统模式，多用在系统库的编写*/
    ldr pc, _prefetch_abort         /*prefetch异常，预取指中止异常，导致正在取的指令无法正常取出，这里需要注意流水线造成的pc值*/
    ldr pc, _data_abort             /*data中止，无法获取数据，产生的原因有可能是内存未准备好、内存无读或写权限等一些原因产生的异常*/
    ldr pc, _not_used               /* 0x14暂时未使用*/
    ldr pc, _irq                    /* 0x18提供系统硬件中断跳转接口*/
    ldr pc, _fiq                    /* 0x1c地址为_fiq快速中断，一个系统在中断流水线上可能产生很多中断，但快中断只会有一个*/

_undefined_instruction:
    .word undefined_instruction
_software_interrupt:
    .word software_interrupt
_prefetch_abort:
    .word prefetch_abort
_data_abort:
    .word data_abort
_not_used:
    .word not_used
_irq:
    .word irq
_fiq:
    .word fiq
_pad:
    .word 0x12345678 /* now 16*4=64 */
.global _end_vect   /*全局变量_end_vect*/
_end_vect:

    .balignl 16,0xdeadbeef          /*.balign 的作用同.align,用于表示对齐方式:通过添加填充字节使当前位置满足一定的对齐方式,以下代码按照16位对齐，不足位补上0xdeadbeef*/
/*
 *************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * setup Memory and board specific bits prior to relocation.
 * relocate armboot to ram
 * setup stack
 *
 *************************************************************************
 */

_TEXT_BASE:
    .word   TEXT_BASE       /*定义uboot程序的运行地址，值为0xc7e0 0000,TEXT_BASE在编译的时候，通过向编译器传递参数获得,值的定义在config.mk中，Makefile会包含它*/

/*
 * Below variable is very important because we use MMU in U-Boot.
 * Without it, we cannot run code correctly before MMU is ON.
 * by scsuh.
 */
_TEXT_PHY_BASE:             /*MMU开启前uboot在内存存放的是真实物理地址,0x57e0 0000*/
    .word   CFG_PHY_UBOOT_BASE

.globl _armboot_start
_armboot_start:
    .word _start

/*
 * These are defined in the board-specific linker script.
 */
.globl _bss_start
_bss_start:
    .word __bss_start       /*_bss_start 保存的是__bss_start 这个标号所在的地址,不受编译时地址的影响，表示当前代码所在的地址不是编译时的地址*/

.globl _bss_end
_bss_end:
    .word _end

/*uboot里面没有开启IRQ中断功能*/
#ifdef CONFIG_USE_IRQ
/* IRQ stack memory (calculated at run-time) */
.globl IRQ_STACK_START
IRQ_STACK_START:
    .word   0x0badc0de

/* IRQ stack memory (calculated at run-time) */
.globl FIQ_STACK_START
FIQ_STACK_START:
    .word 0x0badc0de
#endif

/*
 * the actual reset code
 */

/*MRS {} Rd,CPSR/SPSR语句的意思：将 CPSR/SPSR的值传送到Rd*/
/*MSR {} CPSR|SPSR,Rm语句的意思：将Rm中的值保存到CPSR/SPSR*/
reset:
    /*
     * set the cpu to SVC32 mode
     */
/*进入SVC模式(保证CPSR寄存器的最低5位为10011)，由于ARM上电就处于SVC模式，故此代码可以省略*/
    mrs r0,cpsr
    bic r0,r0,#0x1f
    orr r0,r0,#0xd3         /*把0xd3赋给CPSR，即1101 0011，最高两位置1的意思是关闭中断和快中断,bit【5】为0的意思是cpu的状态为arm状态，如果是1则cpu进入thumb状态*/
    msr cpsr,r0

/*
 *************************************************************************
 *
 * CPU_init_critical registers
 *
 * setup important registers
 * setup memory timing
 *
 *************************************************************************
 */
         /*
         * we do sys-critical inits only at reboot,
         * not when booting from ram!
         */
cpu_init_crit:
    /*
     * flush v4 I/D caches
     */
/*mcr的意思是把arm寄存器的值赋给coprocesser寄存器*/
/*mrc的意思是把coprocesser寄存器的值赋给arm寄存器*/
/*mcr{cond} coproc,opcode1,Rd,CRn,CRm,{opcode2}:coproc是协处理器，标准名为Pn，n=1~15，对应CPn；opcode1位协处理器行为操作吗，必须为0，否则协处理器状态不确定；Rd为ARM的寄存器；CRn为目标寄存器；CRm为附加寄存器，不使用的时候设为0*/
/*CP15是系统控制协处理器，用于连接在内存中的页表描述符,它是外部内存端口映射寄存器,32位，在开关MMU的时候发生作用，且优先级最高*/
/*c7，c8都被清零*/
    mov r0, #0
    mcr p15, 0, r0, c7, c7, 0   /* flush v3/v4 cache */
    mcr p15, 0, r0, c8, c7, 0   /* flush v4 TLB */

    /*
     * disable MMU stuff and caches
     */
/*c1是控制寄存器,其中13,9,8位为 V、R、S：V位是对高端异常向量表的支持，如果选择0异常向量表为0x00000000-0x0000001c，如果选择1异常向量表就是FFFF0000-FFFF001c；R位用于ROM保护的，具体的还要与c5里面的配合,S在这里面的意思也是用于系统保护的*/
    mrc p15, 0, r0, c1, c0, 0       
    bic r0, r0, #0x00002300 @ clear bits 13, 9:8 (--V- --RS)
    bic r0, r0, #0x00000087 @ clear bits 7, 2:0 (B--- -CAM)     /*B为0表示支持小little-endian,M为0代表禁止MMU,A为0代表禁止地址对齐检查，C为0代表禁止指令数据cache控制*/
    orr r0, r0, #0x00000002 @ set bit 2 (A) Align               /*A为1代表使能地址对齐检查*/
    orr r0, r0, #0x00001000 @ set bit 12 (I) I-Cache                /*I为1代表打开指令缓存*/
    mcr p15, 0, r0, c1, c0, 0

    /* Peri port setup */
/*把外设的基地址告诉CPU*/
    ldr r0, =0x70000000         /*对于6410来说,内存(0x00000000～0x60000000),外设(0x70000000-0x7fffffff)*/
    orr r0, r0, #0x13           /*外设大小:256M*/
    mcr p15,0,r0,c15,c2,4       @ 256M(0x70000000-0x7fffffff)

/*关闭看门狗*/
/*一般都在外部专门有一个看门狗,做一个外部的电路,不在cpu内部使用看门狗,cpu内部的看门狗只是复位一个cpu,当开发板很复杂时,有好几个cpu 时,就不能完全让板子复位*/

    /*
     * Go setup Memory and board specific bits prior to relocation.
     */
/*在lowlevel.S中实现比如说点亮LED灯、关闭watchdog、关闭中断、系统时钟初始、nand flash初始化、内存控制器初始化*/
    bl  lowlevel_init   /* go setup pll,mux,memory */

    /* when we already run in ram, we don't need to relocate U-Boot.
     * and actually, memory controller must be configured before U-Boot
     * is running in ram.
     */
/*跳转出来以后，继续执行下面的代码，下面的代码是判断程序是否已经在ram中了，在的话就不拷贝，直接跳转到after_copy了，否则继续执行下面的代码*/
    ldr r0, =0xff000fff
    bic r1, pc, r0      /* r0 &lt;- current base addr of code */
    ldr r2, _TEXT_BASE      /* r1 &lt;- original base addr in ram */
    bic r2, r2, r0      /* r0 &lt;- current base addr of code */
    cmp     r1, r2                  /* compare r0, r1                  */
    beq     after_copy      /* r0 == r1 then skip flash copy   */

#ifdef CONFIG_BOOT_NAND     /*从Nand启动*/
    mov r0, #0x1000
    bl  copy_from_nand      /*具体实现在后面的代码*/
#endif

#ifdef CONFIG_BOOT_MOVINAND /*从SD卡启动*/
    ldr sp, _TEXT_PHY_BASE  /*因为要调用C函数，所以先要设置栈指针，此时MMU没有开启，堆栈栈顶地址为0x57e00000,ARM中的栈向下(低地址)生长*/
    bl  movi_bl2_copy       /*具体实现代码在于cpu/s3c64xx/movi.c*/
    b   after_copy
#endif

after_copy:

/*协处理器c3的作用是存储的保护和控制，用在MMU中为内存的域访问控制，c3为32位寄存器，每两位为一个访问控制特权，0x00代表没有访问权限，这时候访问将失效；0x01为客户类型，将根据地址变换条目中的访问控制位决定是否允许特定内存访问；0x10是保留的，暂时没有使用，0x11为管理者权限，不考虑地址变换条目中的权限控制位，将不会访问内存失效。*/
/*协处理器c2用于保存页表基地址。所谓页表基地址即是虚实转换的内存页表的首地址*/  
#ifdef CONFIG_ENABLE_MMU
enable_mmu:
    /* enable domain access */
    ldr r5, =0x0000ffff
    mcr p15, 0, r5, c3, c0, 0       /*代码的含义为设置高8个域无访问权限，低8个域为管理者权限*/

    /* Set the TTB register */
    ldr r0, _mmu_table_base         /*_mmu_table_base=mmu_table,mmu_table在lowlevel_init.S中*/
    ldr r1, =CFG_PHY_UBOOT_BASE
    ldr r2, =0xfff00000
    bic r0, r0, r2
    orr r1, r0, r1
    mcr p15, 0, r1, c2, c0, 0       /*r1的值为0x57exxxxx*/

    /* Enable the MMU */
mmu_on:
    mrc p15, 0, r0, c1, c0, 0
    orr r0, r0, #1                  /* Set CR_M to enable MMU */
    mcr p15, 0, r0, c1, c0, 0       /*将c1的最后一位置1*/
    nop
    nop
    nop
    nop
#endif

skip_hw_init:
    /* Set up the stack */
stack_setup:
#ifdef CONFIG_MEMORY_UPPER_CODE
    ldr sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0xc)    /*sp = 0xc7e0 0000+0x20 0000-0xc=0xc7ff fff4*/
#else
    ldr r0, _TEXT_BASE                                  /* upper 128 KiB: relocated uboot */
    sub r0, r0, #CFG_MALLOC_LEN                         /* malloc area */
    sub r0, r0, #CFG_GBL_DATA_SIZE                      /* bdinfo  */
#ifdef CONFIG_USE_IRQ
    sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
#endif
    sub sp, r0, #12                                     /* leave 3 words for abort-stack    */

#endif

clear_bss:
    ldr r0, _bss_start                                  /* find start of bss segment*/
    ldr r1, _bss_end                                
    mov     r2, #0x00000000                             

clbss_l:
    str r2, [r0]        
    add r0, r0, #4
    cmp r0, r1
    ble clbss_l                                         /*ble指令表明：小于或者等于就跳转*/

    ldr pc, _start_armboot                              /*跳转到uboot代码的第二个阶段的入口点。这里不能使用b跳转指令，因为此时代码还没有在ddr中运行*/

_start_armboot:
    .word start_armboot                                 /*定义在lib_arm/board.c中的函数*/

#ifdef CONFIG_ENABLE_MMU
_mmu_table_base:
    .word mmu_table                                     /*在lowlevel_init.S中将mmu_tabel声明为全局变量*/
#endif

/*
 * copy U-Boot to SDRAM and jump to ram (from NAND or OneNAND)
 * r0: size to be compared
 * Load 1'st 2blocks to RAM because U-boot's size is larger than 1block(128k) size
 */
    .globl copy_from_nand
copy_from_nand:
    mov r10, lr                                         /* save return address */

    mov r9, r0
    /* get ready to call C functions */
    ldr sp, _TEXT_PHY_BASE                              /*设置好临时的堆栈指针,此时MMU还没有开启，所以sp=0x57e0 0000*/
    sub sp, sp, #12
    mov fp, #0                                          /* no previous frame, so fp=0 */
    mov r9, #0x1000
    bl  copy_uboot_to_ram                               /*函数在cpu/s3c64xx/Nand_cp.c中.从nand中读取0x50000(大于uboot实际大小)大小的内容到内存0x57e00000中,*/

3:  tst     r0, #0x0                                    /*r0中保存着copy_uboot_to_ram的返回值，如果返回值不是0，就表明失败,进入死循环*/
    bne copy_failed

    ldr r0, =0x0c000000                                 /*校验拷贝是否失真，比较的地址为：0x0c000000(stepping stone)和0x57e0 0000*/
    ldr r1, _TEXT_PHY_BASE
1:  ldr r3, [r0], #4
    ldr r4, [r1], #4
    teq r3, r4
    bne compare_failed  /* not matched */               /*如果发生了失真就进入死循环*/
    subs    r9, r9, #4                                  /*总共比较4K大小的数据，没有全部比较*/
    bne 1b

4:  mov lr, r10     /* all is OK */
    mov pc, lr

copy_failed:
    nop         /* copy from nand failed */
    b   copy_failed

compare_failed:
    nop         /* compare failed */
    b   compare_failed

/*
 * we assume that cache operation is done before. (eg. cleanup_before_linux())
 * actually, we don't need to do anything about cache if not use d-cache in U-Boot
 * So, in this function we clean only MMU. by scsuh
 *
 * void theLastJump(void *kernel, int arch_num, uint boot_params);
 */
#ifdef CONFIG_ENABLE_MMU
    .globl theLastJump
theLastJump:
    mov r9, r0
    ldr r3, =0xfff00000
    ldr r4, _TEXT_PHY_BASE
    adr r5, phy_last_jump
    bic r5, r5, r3
    orr r5, r5, r4
    mov pc, r5
phy_last_jump:
    /*
     * disable MMU stuff
     */
    mrc p15, 0, r0, c1, c0, 0
    bic r0, r0, #0x00002300 /* clear bits 13, 9:8 (--V- --RS) */
    bic r0, r0, #0x00000087 /* clear bits 7, 2:0 (B--- -CAM) */
    orr r0, r0, #0x00000002 /* set bit 2 (A) Align */
    orr r0, r0, #0x00001000 /* set bit 12 (I) I-Cache */
    mcr p15, 0, r0, c1, c0, 0

    mcr p15, 0, r0, c8, c7, 0   /* flush v4 TLB */

    mov r0, #0
    mov pc, r9
#endif
/*
 *************************************************************************
 *
 * Interrupt handling
 *
 *************************************************************************
 */
@
@ IRQ stack frame.
@
#define S_FRAME_SIZE    72

#define S_OLD_R0    68
#define S_PSR       64
#define S_PC        60
#define S_LR        56
#define S_SP        52

#define S_IP        48
#define S_FP        44
#define S_R10       40
#define S_R9        36
#define S_R8        32
#define S_R7        28
#define S_R6        24
#define S_R5        20
#define S_R4        16
#define S_R3        12
#define S_R2        8
#define S_R1        4
#define S_R0        0

#define MODE_SVC 0x13
#define I_BIT    0x80

/*
 * use bad_save_user_regs for abort/prefetch/undef/swi ...
 * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
 */

    .macro  bad_save_user_regs
    sub sp, sp, #S_FRAME_SIZE       @ carve out a frame on current user stack
    stmia   sp, {r0 - r12}          @ Save user registers (now in svc mode) r0-r12

    ldr r2, _armboot_start
    sub r2, r2, #(CFG_MALLOC_LEN)
    sub r2, r2, #(CFG_GBL_DATA_SIZE+8)  @ set base 2 words into abort stack
    ldmia   r2, {r2 - r3}           @ get values for "aborted" pc and cpsr (into parm regs)
    add r0, sp, #S_FRAME_SIZE       @ grab pointer to old stack

    add r5, sp, #S_SP
    mov r1, lr
    stmia   r5, {r0 - r3}           @ save sp_SVC, lr_SVC, pc, cpsr
    mov r0, sp              @ save current stack into r0 (param register)
    .endm

    .macro  irq_save_user_regs
    sub sp, sp, #S_FRAME_SIZE
    stmia   sp, {r0 - r12}          @ Calling r0-r12
    add r8, sp, #S_PC           @ !!!! R8 NEEDS to be saved !!!! a reserved stack spot would be good.
    stmdb   r8, {sp, lr}^           @ Calling SP, LR
    str lr, [r8, #0]            @ Save calling PC
    mrs r6, spsr
    str r6, [r8, #4]            @ Save CPSR
    str r0, [r8, #8]            @ Save OLD_R0
    mov r0, sp
    .endm

    .macro  irq_restore_user_regs
    ldmia   sp, {r0 - lr}^          @ Calling r0 - lr
    mov r0, r0
    ldr lr, [sp, #S_PC]         @ Get PC
    add sp, sp, #S_FRAME_SIZE
    subs    pc, lr, #4          @ return &amp; move spsr_svc into cpsr
    .endm

    .macro get_bad_stack
    ldr r13, _armboot_start     @ setup our mode stack (enter in banked mode)
    sub r13, r13, #(CFG_MALLOC_LEN) @ move past malloc pool
    sub r13, r13, #(CFG_GBL_DATA_SIZE+8) @ move to reserved a couple spots for abort stack

    str lr, [r13]           @ save caller lr in position 0 of saved stack
    mrs lr, spsr            @ get the spsr
    str lr, [r13, #4]           @ save spsr in position 1 of saved stack

    mov r13, #MODE_SVC          @ prepare SVC-Mode
    @ msr   spsr_c, r13
    msr spsr, r13           @ switch modes, make sure moves will execute
    mov lr, pc              @ capture return pc
    movs    pc, lr              @ jump to next instruction &amp; switch modes.
    .endm

    .macro get_bad_stack_swi
    sub r13, r13, #4            @ space on current stack for scratch reg.
    str r0, [r13]           @ save R0's value.
    ldr r0, _armboot_start      @ get data regions start
    sub r0, r0, #(CFG_MALLOC_LEN)   @ move past malloc pool
    sub r0, r0, #(CFG_GBL_DATA_SIZE+8)  @ move past gbl and a couple spots for abort stack
    str lr, [r0]            @ save caller lr in position 0 of saved stack
    mrs r0, spsr            @ get the spsr
    str lr, [r0, #4]            @ save spsr in position 1 of saved stack
    ldr r0, [r13]           @ restore r0
    add r13, r13, #4            @ pop stack entry
    .endm

    .macro get_irq_stack            @ setup IRQ stack
    ldr sp, IRQ_STACK_START
    .endm

    .macro get_fiq_stack            @ setup FIQ stack
    ldr sp, FIQ_STACK_START
    .endm

/*
 * exception handlers
 */
    .align  5
undefined_instruction:
    get_bad_stack
    bad_save_user_regs
    bl  do_undefined_instruction

    .align  5
software_interrupt:
    get_bad_stack_swi
    bad_save_user_regs
    bl  do_software_interrupt

    .align  5
prefetch_abort:
    get_bad_stack
    bad_save_user_regs
    bl  do_prefetch_abort

    .align  5
data_abort:
    get_bad_stack
    bad_save_user_regs
    bl  do_data_abort

    .align  5
not_used:
    get_bad_stack
    bad_save_user_regs
    bl  do_not_used

#ifdef CONFIG_USE_IRQ

    .align  5
irq:
    get_irq_stack
    irq_save_user_regs
    bl  do_irq
    irq_restore_user_regs

    .align  5
fiq:
    get_fiq_stack
    /* someone ought to write a more effiction fiq_save_user_regs */
    irq_save_user_regs
    bl  do_fiq
    irq_restore_user_regs

#else

    .align  5
irq:
    get_bad_stack
    bad_save_user_regs
    bl  do_irq

    .align  5
fiq:
    get_bad_stack
    bad_save_user_regs
    bl  do_fiq

#endif
    .align 5
.global arm1136_cache_flush
arm1136_cache_flush:
        mcr p15, 0, r1, c7, c5, 0   @ invalidate I cache
        mov pc, lr          @ back to caller

#if defined(CONFIG_INTEGRATOR) &amp;&amp; defined(CONFIG_ARCH_CINTEGRATOR)
/* Use the IntegratorCP function from board/integratorcp/platform.S */
#elif defined(CONFIG_S3C64XX)
/* For future usage of S3C64XX*/
#else
    .align  5
.globl reset_cpu
reset_cpu:
    ldr r1, rstctl  /* get addr for global reset reg */
    mov r3, #0x2    /* full reset pll+mpu */
    str r3, [r1]    /* force reset */
    mov r0, r0
_loop_forever:
    b   _loop_forever
rstctl:
    .word   PM_RSTCTRL_WKUP

#endif
</code></pre>

<p><img src="http://i.imgur.com/Nn7Krru.gif" alt="suda-morris" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[u-boot.lds]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/13/u-boot-dot-lds/"/>
    <updated>2015-06-13T23:06:13+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/13/u-boot-dot-lds</id>
    <content type="html"><![CDATA[<pre><code class="C u-boot.lds">OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
    . = 0x00000000;
    . = ALIGN(4);
    .text      :
    {
      cpu/s3c64xx/start.o   (.text)
      cpu/s3c64xx/s3c6410/cpu_init.o    (.text)
      cpu/s3c64xx/onenand_cp.o  (.text)
      cpu/s3c64xx/nand_cp.o (.text)
      board/samsung/mini6410/nand_6410.fo
      cpu/s3c64xx/movi.o (.text)
      *(.text)
      lib_arm/div0.o
    }
    . = ALIGN(4);
    .rodata : { *(.rodata) }
    . = ALIGN(4);
    .data : { *(.data) }
    . = ALIGN(4);
    .got : { *(.got) }
    __u_boot_cmd_start = .;
    .u_boot_cmd : { *(.u_boot_cmd) }
    __u_boot_cmd_end = .;
    . = ALIGN(4);
    .mmudata : { *(.mmudata) }
    . = ALIGN(4);
    __bss_start = .;
    .bss : { *(.bss) }
    _end = .;
}
</code></pre>

<p><img src="http://i.imgur.com/Nn7Krru.gif" alt="suda-morris" /></p>
]]></content>
  </entry>
  
</feed>
