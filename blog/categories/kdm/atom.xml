<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kdm | WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/blog/categories/kdm/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-11-22T19:24:35+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Uboot第二阶段代码分析]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/20/board-dot-c/"/>
    <updated>2015-06-20T15:23:31+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/20/board-dot-c</id>
    <content type="html"><![CDATA[<pre><code class="C include/asm-arm/global_data.h">typedef struct  global_data {
    bd_t        *bd;                /*与板子相关的结构*/
    unsigned long   flags;
    unsigned long   baudrate;       /*波特率*/
    unsigned long   have_console;   /* serial_init() was called */
    unsigned long   reloc_off;      /* 重定位偏移*/
    unsigned long   env_addr;       /* 存放环境变量结构的地址*/
    unsigned long   env_valid;      /* Checksum of Environment valid? */
    unsigned long   fb_base;        /* base address of frame buffer */
#ifdef CONFIG_VFD
    unsigned char   vfd_type;       /* display type */
#endif
#if 0
    unsigned long   cpu_clk;        /* CPU的时钟频率*/
    unsigned long   bus_clk;        /*总线的时钟频率*/
    unsigned long   ram_size;       /* RAM size */
    unsigned long   reset_status;   /* reset status register at boot */
#endif
    void        **jt;               /* jump table，保存着某些函数的入口地址，在common/Exoirt.c中进行填充 */
} gd_t;

/*
 * Global Data Flags
 */
#define GD_FLG_RELOC    0x00001     /* Code was relocated to RAM        */
#define GD_FLG_DEVINIT  0x00002     /* Devices have been initialized    */
#define GD_FLG_SILENT   0x00004     /* Silent mode              */

#if 0
#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")
#else
#define DECLARE_GLOBAL_DATA_PTR
extern gd_t *gd;
#endif

#endif /* __ASM_GBL_DATA_H */
</code></pre>

<pre><code class="C include/asm-arm/u-boot.h">#ifndef _U_BOOT_H_
#define _U_BOOT_H_  1

typedef struct bd_info {
    int         bi_baudrate;        /* 串口波特率*/
    unsigned long   bi_ip_addr;     /* IP Address */
    unsigned char   bi_enetaddr[6]; /* Ethernet adress */
    struct environment_s    *bi_env;/*环境变量地址指针*/
    ulong           bi_arch_number; /* unique id for this board's CPU */
    ulong           bi_boot_params; /* where this board expects params */
    struct                          /* RAM configuration */
    {
    ulong start;                    /*RAM的起始地址*/
    ulong size;                     /*RAM的大小*/
    } bi_dram[CONFIG_NR_DRAM_BANKS];
#ifdef CONFIG_HAS_ETH1
    /* second onboard ethernet port */
    unsigned char   bi_enet1addr[6];
#endif
} bd_t;

#define bi_env_data bi_env-&gt;data
#define bi_env_crc  bi_env-&gt;crc

#endif  /* _U_BOOT_H_ */
</code></pre>

<pre><code class="C include/command.h">struct cmd_tbl_s {                  /*command table结构体*/
    char        *name;              /* Command Name         */
    int     maxargs;                /* maximum number of arguments  */
    int     repeatable;             /* autorepeat allowed?      */
                                    /* Implementation function  */
    int     (*cmd)(struct cmd_tbl_s *, int, int, char *[]);
    char        *usage;             /* Usage message    (short) */
#ifdef  CFG_LONGHELP
    char        *help;              /* Help  message    (long)  */
#endif
#ifdef CONFIG_AUTO_COMPLETE
    /* do auto completion on the arguments */
    int     (*complete)(int argc, char *argv[], char last_char, int maxv, char *cmdv[]);
#endif
};
</code></pre>

<blockquote><p>可用于U-Boot的kernel是在常规内核zImage前加了个64byte头的uImage，这个头包含了：
1. kernel的加载和运行地址
2. zImage的CRC校验码等信息</p></blockquote>

<pre><code class="C include/image.h">typedef struct image_header {
    uint32_t    ih_magic;           /* Image Header Magic Number    */
    uint32_t    ih_hcrc;            /* Image Header CRC Checksum    */
    uint32_t    ih_time;            /* Image Creation Timestamp */
    uint32_t    ih_size;            /* Image Data Size      */
    uint32_t    ih_load;            /* Data  Load  Address      */
    uint32_t    ih_ep;              /* Entry Point Address      */
    uint32_t    ih_dcrc;            /* Image Data CRC Checksum  */
    uint8_t     ih_os;              /* Operating System     */
    uint8_t     ih_arch;            /* CPU architecture     */
    uint8_t     ih_type;            /* Image Type           */
    uint8_t     ih_comp;            /* Compression Type     */
    uint8_t     ih_name[IH_NMLEN];  /* Image Name       */
} image_header_t;
</code></pre>

<pre><code class="C board.c">#include &lt;common.h&gt;
#include &lt;command.h&gt;
#include &lt;malloc.h&gt;
#include &lt;devices.h&gt;
#include &lt;version.h&gt;
#include &lt;net.h&gt;
#include &lt;asm/io.h&gt;

#if defined(CONFIG_BOOT_MOVINAND)
#include &lt;movi.h&gt;
#endif

#ifdef CONFIG_DRIVER_SMC91111
#include "../drivers/smc91111.h"
#endif
#ifdef CONFIG_DRIVER_LAN91C96
#include "../drivers/lan91c96.h"
#endif

/* Note: volatile register variable is *NOT* volatile in gcc 4.5.1+ */
#if 0
DECLARE_GLOBAL_DATA_PTR;
#else
gd_t *gd;
#endif

#if (CONFIG_COMMANDS &amp; CFG_CMD_NAND)
void nand_init (void);
#endif

#ifdef CONFIG_ONENAND
void onenand_init(void);
#endif

ulong monitor_flash_len;

#ifdef CONFIG_HAS_DATAFLASH
extern int  AT91F_DataflashInit(void);
extern void dataflash_print_info(void);
#endif

#ifndef CONFIG_IDENT_STRING
#define CONFIG_IDENT_STRING ""
#endif

const char version_string[] =
    "   kdm ver1.01" CONFIG_IDENT_STRING;

#ifdef CONFIG_DRIVER_CS8900
extern void cs8900_get_enetaddr (uchar * addr);
#endif

#ifdef CONFIG_DRIVER_RTL8019
extern void rtl8019_get_enetaddr (uchar * addr);
#endif

/*
 * Begin and End of memory area for malloc(), and current "brk"
 */
static ulong mem_malloc_start = 0;
static ulong mem_malloc_end = 0;
static ulong mem_malloc_brk = 0;

static
void mem_malloc_init (ulong dest_addr)
{
    mem_malloc_start = dest_addr;                   /*缓冲区起始地址*/
    mem_malloc_end = dest_addr + CFG_MALLOC_LEN;    /*缓冲区结束地址*/
    mem_malloc_brk = mem_malloc_start;              /*已使用块的地址，初始时应指向起始地址*/
    /* memset ((void *) mem_malloc_start, 0,
            mem_malloc_end - mem_malloc_start); */
}

void *sbrk (ptrdiff_t increment)
{
    ulong old = mem_malloc_brk;
    ulong new = old + increment;

    if ((new &lt; mem_malloc_start) || (new &gt; mem_malloc_end)) {
        return (NULL);
    }
    mem_malloc_brk = new;

    return ((void *) old);
}

/************************************************************************
 * Init Utilities                           *
 ************************************************************************
 * Some of this code should be moved into the core functions,
 * or dropped completely,
 * but let's get it working (again) first...
 */

static int init_baudrate (void)
{
    char tmp[64];   /* long enough for environment variables */
    int i = getenv_r ("baudrate", tmp, sizeof (tmp));
    gd-&gt;bd-&gt;bi_baudrate = gd-&gt;baudrate = (i &gt; 0)
            ? (int) simple_strtoul (tmp, NULL, 10)
            : CONFIG_BAUDRATE;

    return (0);
}

static int display_banner (void)
{
    printf ("\n\n%s\n\n", version_string);
    debug ("U-Boot code: %08lX -&gt; %08lX  BSS: -&gt; %08lX\n",
           _armboot_start, _bss_start, _bss_end);
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
    debug("\t\bMalloc and Stack is above the U-Boot Code.\n");
#else
    debug("\t\bMalloc and Stack is below the U-Boot Code.\n");
#endif
#ifdef CONFIG_MODEM_SUPPORT
    debug ("Modem Support enabled\n");
#endif
#ifdef CONFIG_USE_IRQ
    debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
    debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

    return (0);
}

/*
 * WARNING: this code looks "cleaner" than the PowerPC version, but
 * has the disadvantage that you either get nothing, or everything.
 * On PowerPC, you might see "DRAM: " before the system hangs - which
 * gives a simple yet clear indication which part of the
 * initialization if failing.
 */
static int display_dram_config (void)
{
    int i;

#ifdef DEBUG
    puts ("RAM Configuration:\n");

    for(i=0; i&lt;CONFIG_NR_DRAM_BANKS; i++) {
        printf ("Bank #%d: %08lx ", i, gd-&gt;bd-&gt;bi_dram[i].start);
        print_size (gd-&gt;bd-&gt;bi_dram[i].size, "\n");
    }
#else
    ulong size = 0;

    for (i=0; i&lt;CONFIG_NR_DRAM_BANKS; i++) {
        size += gd-&gt;bd-&gt;bi_dram[i].size;
    }

    puts("DRAM:    ");
    print_size(size, "\n");
#endif

    return (0);
}

#ifndef CFG_NO_FLASH
static void display_flash_config (ulong size)
{
    puts ("Flash:  ");
    print_size (size, "\n");
}
#endif /* CFG_NO_FLASH */

typedef int (init_fnc_t) (void);

int print_cpuinfo (void); /* test-only */

init_fnc_t *init_sequence[] = {
    cpu_init,           /* cpu的初始化，位于cpu/sec64xx/cpu.c*/
    board_init,         /* 板子初始化，位于board/samsung/mini6410/mini6410.c*/
    interrupt_init,     /* 中断初始化，位于cpu/s3c64xx/interrupts.c*/
    env_init,           /* 初始化环境变量，位于common/env_nand.c*/
    init_baudrate,      /* 初始化波特率设置，位于lib_arm/board.c*/
    serial_init,        /* 串口通讯设置，位于cpu/s3c64xx/serial.c*/
    console_init_f,     /* 第一阶段控制台设置，位于common/console.c*/
    display_banner,     /* 打印banner，位于lib_arm/board.c*/
#if defined(CONFIG_DISPLAY_CPUINFO)
    print_cpuinfo,      /* 打印CPU信息，位于cpu/s3c64xx/s3c6410/speed.c*/
#endif
#if defined(CONFIG_DISPLAY_BOARDINFO)
    checkboard,         /* 打印板子信息，位于board/samsumg/mini6410/mini6410.c*/
#endif
    dram_init,          /* 配置现有的RAM banks,这里只是对gd中的bi_dram结构中的两个成员赋值,也即BANK的起始地址和大小 位于board/samsumg/mini6410/mini6410.c*/
    display_dram_config,/*位于lib_arm/board.c*/
    NULL,               /*用以标识列表数组的结束 */
};

void start_armboot (void)               /*uboot第二阶段入口函数,完成uboot第二阶级的一系列的硬件初始化工作, 然后转入main函数*/
{
    init_fnc_t **init_fnc_ptr;          /*init_fnc_t 是各初始化函数的数组 */
    char *s;
#ifndef CFG_NO_FLASH
    ulong size;
#endif

#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
    unsigned long addr;
#endif

#if defined(CONFIG_BOOT_MOVINAND)
    uint *magic = (uint *) (PHYS_SDRAM_1);  /*指向0x5000 0000*/
#endif

    /* Pointer is writable since we allocated a register for it */
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
    ulong gd_base;

    gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t);
#ifdef CONFIG_USE_IRQ
    gd_base -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
#endif
    gd = (gd_t*)gd_base;
#else
    gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
#endif

    /* compiler optimization barrier needed for GCC &gt;= 3.4 */
    __asm__ __volatile__("": : :"memory");                  /*禁止编译器优化此处代码*/

    memset ((void*)gd, 0, sizeof (gd_t));
    gd-&gt;bd = (bd_t*)((char*)gd - sizeof(bd_t));
    memset (gd-&gt;bd, 0, sizeof (bd_t));

    monitor_flash_len = _bss_start - _armboot_start;            /*monitor_flash_len表示从flash中搬来的代码的长度,包络代码段，数据段*/

    for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
        if ((*init_fnc_ptr)() != 0) {
            hang ();
        }
    }

#ifndef CFG_NO_FLASH
    /* configure available FLASH banks */
    size = flash_init ();
    display_flash_config (size);                            /*打印flash的信息*/
#endif /* CFG_NO_FLASH */

#ifdef CONFIG_VFD
#ifndef PAGE_SIZE
#define PAGE_SIZE 4096                                      /*显存大小*/
#endif
    /*
     * reserve memory for VFD display (always full pages)
     */
    /* bss_end is defined in the board-specific linker script */
    addr = (_bss_end + (PAGE_SIZE - 1)) &amp; ~(PAGE_SIZE - 1);
    size = vfd_setmem (addr);
    gd-&gt;fb_base = addr;                                     /*设置显存基地址*/
#endif /* CONFIG_VFD */

#ifdef CONFIG_LCD
#ifndef PAGE_SIZE
#define PAGE_SIZE 4096                                      /*显存大小*/
#endif
    /*
     * reserve memory for LCD display (always full pages)
     */
    /* bss_end is defined in the board-specific linker script */
    addr = (_bss_end + (PAGE_SIZE - 1)) &amp; ~(PAGE_SIZE - 1);
    size = lcd_setmem (addr);                               /*该函数位于common/lcd.c*/
    gd-&gt;fb_base = addr;                                     /*设置显存基地址*/
#endif /* CONFIG_LCD */

#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
    mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);
#else
    mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
#endif

#if defined(CONFIG_SMDK6400) || defined(CONFIG_SMDK6410) || defined(CONFIG_SMDK6430) || defined(CONFIG_SMDK2450) || defined(CONFIG_SMDK2416) || \
defined(CONFIG_MINI6410)

#if defined(CONFIG_NAND)
    puts ("NAND:    ");
    nand_init();        /* go init the NAND */
    NAND_Init();        /*友善提供的闭源代码*/
#endif

#if defined(CONFIG_ONENAND)
    puts ("OneNAND: ");
    onenand_init();     /* go init the One-NAND */
#endif

#if defined(CONFIG_BOOT_MOVINAND)
    puts ("MMC:     ");

    if ((0x24564236 == magic[0]) &amp;&amp; (0x20764316 == magic[1])) {
        printf("Boot up for burning\n");
    } else {
        movi_set_capacity();
        movi_set_ofs(MOVI_TOTAL_BLKCNT);
        movi_init();
    }
#endif

#else

#if (CONFIG_COMMANDS &amp; CFG_CMD_NAND)
    puts ("NAND:    ");
    nand_init();        /* go init the NAND */
#endif

#endif

#ifdef CONFIG_HAS_DATAFLASH
    AT91F_DataflashInit();
    dataflash_print_info();
#endif

                                /* initialize environment */
    env_relocate ();            /*位于common/env_common.c*/

#ifdef CONFIG_VFD
                                /* must do this after the framebuffer is allocated */
    drv_vfd_init();             /*必须在前村初始化完成以后才能调用该初始化函数*/
#endif /* CONFIG_VFD */

                                                        /* IP Address */
    gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr ("ipaddr");      /*位于net/net.c*/

                                                        /* MAC Address */
    {
        int i;
        ulong reg;
        char *s, *e;
        char tmp[64];

        i = getenv_r ("ethaddr", tmp, sizeof (tmp));
        s = (i &gt; 0) ? tmp : NULL;

        for (reg = 0; reg &lt; 6; ++reg) {
            gd-&gt;bd-&gt;bi_enetaddr[reg] = s ? simple_strtoul (s, &amp;e, 16) : 0;
            if (s)
                s = (*e) ? e + 1 : e;
        }

#ifdef CONFIG_HAS_ETH1
        i = getenv_r ("eth1addr", tmp, sizeof (tmp));
        s = (i &gt; 0) ? tmp : NULL;

        for (reg = 0; reg &lt; 6; ++reg) {
            gd-&gt;bd-&gt;bi_enet1addr[reg] = s ? simple_strtoul (s, &amp;e, 16) : 0;
            if (s)
                s = (*e) ? e + 1 : e;
        }
#endif
    }

    devices_init ();                                /* get the devices list going. */

#ifdef CONFIG_CMC_PU2
    load_sernum_ethaddr ();
#endif /* CONFIG_CMC_PU2 */

    jumptable_init ();                              /*初始化跳转表,对gd中的jt(函数跳转表)数组进行初始化,其中保存着一些函数的入口地址*/

    console_init_r ();                              /* fully init console as a device */

#if defined(CONFIG_MISC_INIT_R)
                                                    /* miscellaneous platform dependent initialisations */
    misc_init_r ();
#endif

                                                    /* enable exceptions */
    enable_interrupts ();                           /*设置cpsr的I和F位以充许中断*/

                                                    /*网卡初始化*/
#if defined(CONFIG_DRIVER_DM9000) &amp;&amp; defined(CONFIG_DRIVER_DM9000_NO_EEPROM)
extern int eth_set_mac(bd_t * bd);                  /*位于drivers/dm9000x.c*/
    if (getenv ("ethaddr")) {
        eth_set_mac(gd-&gt;bd);                            /*设置DM9000的网卡地址*/
    }
#endif

#ifdef CONFIG_DRIVER_CS8900
    cs8900_get_enetaddr (gd-&gt;bd-&gt;bi_enetaddr);
#endif

#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
    if (getenv ("ethaddr")) {
        smc_set_mac_addr(gd-&gt;bd-&gt;bi_enetaddr);
    }
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

                                                    /* Initialize from environment */
    if ((s = getenv ("loadaddr")) != NULL) {
        load_addr = simple_strtoul (s, NULL, 16);
    }
#if (CONFIG_COMMANDS &amp; CFG_CMD_NET)
    if ((s = getenv ("bootfile")) != NULL) {
        copy_filename (BootFile, s, sizeof (BootFile));
    }
#endif  /* CFG_CMD_NET */

#ifdef BOARD_LATE_INIT
    board_late_init ();
#endif
#if (CONFIG_COMMANDS &amp; CFG_CMD_NET)
#if defined(CONFIG_NET_MULTI)
    puts ("Net:     ");
#endif
    eth_initialize(gd-&gt;bd);
#endif
    /* main_loop() can return to retry autoboot, if so just run it again. */
    for (;;) {
        main_loop ();                               /*硬件初始化完成，进入main_loop函数，该函数在common/main.c中*/
    }

    /* NOTREACHED - no way out of command loop except booting */
}

void hang (void)
{
    puts ("### ERROR ### Please RESET the board ###\n");
    for (;;);
}

#ifdef CONFIG_MODEM_SUPPORT
static inline void mdm_readline(char *buf, int bufsiz);

/* called from main loop (common/main.c) */
extern void  dbg(const char *fmt, ...);
int mdm_init (void)
{
    char env_str[16];
    char *init_str;
    int i;
    extern char console_buffer[];
    extern void enable_putc(void);
    extern int hwflow_onoff(int);

    enable_putc(); /* enable serial_putc() */

#ifdef CONFIG_HWFLOW
    init_str = getenv("mdm_flow_control");
    if (init_str &amp;&amp; (strcmp(init_str, "rts/cts") == 0))
        hwflow_onoff (1);
    else
        hwflow_onoff(-1);
#endif

    for (i = 1;;i++) {
        sprintf(env_str, "mdm_init%d", i);
        if ((init_str = getenv(env_str)) != NULL) {
            serial_puts(init_str);
            serial_puts("\n");
            for(;;) {
                mdm_readline(console_buffer, CFG_CBSIZE);
                dbg("ini%d: [%s]", i, console_buffer);

                if ((strcmp(console_buffer, "OK") == 0) ||
                    (strcmp(console_buffer, "ERROR") == 0)) {
                    dbg("ini%d: cmd done", i);
                    break;
                } else /* in case we are originating call ... */
                    if (strncmp(console_buffer, "CONNECT", 7) == 0) {
                        dbg("ini%d: connect", i);
                        return 0;
                    }
            }
        } else
            break; /* no init string - stop modem init */

        udelay(100000);
    }

    udelay(100000);

    /* final stage - wait for connect */
    for(;i &gt; 1;) { /* if 'i' &gt; 1 - wait for connection
                  message from modem */
        mdm_readline(console_buffer, CFG_CBSIZE);
        dbg("ini_f: [%s]", console_buffer);
        if (strncmp(console_buffer, "CONNECT", 7) == 0) {
            dbg("ini_f: connected");
            return 0;
        }
    }

    return 0;
}

/* 'inline' - We have to do it fast */
static inline void mdm_readline(char *buf, int bufsiz)
{
    char c;
    char *p;
    int n;

    n = 0;
    p = buf;
    for(;;) {
        c = serial_getc();

        /*      dbg("(%c)", c); */

        switch(c) {
        case '\r':
            break;
        case '\n':
            *p = '\0';
            return;

        default:
            if(n++ &gt; bufsiz) {
                *p = '\0';
                return; /* sanity check */
            }
            *p = c;
            p++;
            break;
        }
    }
}
#endif  /* CONFIG_MODEM_SUPPORT */
</code></pre>

<pre><code class="C common/main.c">void main_loop (void)
{
#ifndef CFG_HUSH_PARSER
    static char lastcommand[CFG_CBSIZE] = { 0, };
    int len;
    int rc = 1;
    int flag;
#endif

#if defined(CONFIG_BOOTDELAY) &amp;&amp; (CONFIG_BOOTDELAY &gt;= 0)
    char *s;                                        /*保存环境变量字符串*/
    int bootdelay;                                  /*保存uboot启动延时时间*/
#endif
#ifdef CONFIG_PREBOOT
    char *p;
#endif
#ifdef CONFIG_BOOTCOUNT_LIMIT
    unsigned long bootcount = 0;
    unsigned long bootlimit = 0;
    char *bcs;
    char bcs_set[16];
#endif /* CONFIG_BOOTCOUNT_LIMIT */

#if defined(CONFIG_VFD) &amp;&amp; defined(VFD_TEST_LOGO)
    ulong bmp = 0;      /* default bitmap */
    extern int trab_vfd (ulong bitmap);

#ifdef CONFIG_MODEM_SUPPORT
    if (do_mdm_init)
        bmp = 1;    /* alternate bitmap */
#endif
    trab_vfd (bmp);
#endif  /* CONFIG_VFD &amp;&amp; VFD_TEST_LOGO */

                                                    /*友善之臂1wire触摸驱动*/
    {
        void FriendlyARM1Wire(void);
        FriendlyARM1Wire();
    }

#ifdef CONFIG_BOOTCOUNT_LIMIT
    bootcount = bootcount_load();
    bootcount++;
    bootcount_store (bootcount);
    sprintf (bcs_set, "%lu", bootcount);
    setenv ("bootcount", bcs_set);
    bcs = getenv ("bootlimit");
    bootlimit = bcs ? simple_strtoul (bcs, NULL, 10) : 0;
#endif /* CONFIG_BOOTCOUNT_LIMIT */

#ifdef CONFIG_MODEM_SUPPORT
    debug ("DEBUG: main_loop:   do_mdm_init=%d\n", do_mdm_init);
    if (do_mdm_init) {
        char *str = strdup(getenv("mdm_cmd"));
        setenv ("preboot", str);  /* set or delete definition */
        if (str != NULL)
            free (str);
        mdm_init(); /* wait for modem connection */
    }
#endif  /* CONFIG_MODEM_SUPPORT */

#ifdef CONFIG_VERSION_VARIABLE
    {
        extern char version_string[];

        setenv ("ver", version_string);  /* set version variable */
    }
#endif /* CONFIG_VERSION_VARIABLE */

#ifdef CFG_HUSH_PARSER
    u_boot_hush_start ();                       /*定义在common/hush.c中*/
#endif

#ifdef CONFIG_AUTO_COMPLETE
    install_auto_complete();
#endif

#ifdef CONFIG_PREBOOT
    if ((p = getenv ("preboot")) != NULL) {
# ifdef CONFIG_AUTOBOOT_KEYED
        int prev = disable_ctrlc(1);    /* disable Control C checking */
# endif

# ifndef CFG_HUSH_PARSER
        run_command (p, 0);
# else
        parse_string_outer(p, FLAG_PARSE_SEMICOLON |
                    FLAG_EXIT_FROM_LOOP);
# endif

# ifdef CONFIG_AUTOBOOT_KEYED
        disable_ctrlc(prev);    /* restore Control C checking */
# endif
    }
#endif /* CONFIG_PREBOOT */

#if defined(CONFIG_BOOTDELAY) &amp;&amp; (CONFIG_BOOTDELAY &gt;= 0)
    s = getenv ("bootdelay");               /*获得环境变量bootdelay*/
    bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;

    debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
    //printf("main_loop enter: the bootdelay =%d\n\n",bootdelay);
# ifdef CONFIG_BOOT_RETRY_TIME
    init_cmd_timeout ();
# endif /* CONFIG_BOOT_RETRY_TIME */

#ifdef CONFIG_BOOTCOUNT_LIMIT
    if (bootlimit &amp;&amp; (bootcount &gt; bootlimit)) {
        printf ("Warning: Bootlimit (%u) exceeded. Using altbootcmd.\n",
                (unsigned)bootlimit);
        s = getenv ("altbootcmd");
    }
    else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
    s = getenv ("bootcmd");                         /*字符串s保存bootcmd的命令*/

    debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "&lt;UNDEFINED&gt;");

    if (bootdelay &gt;= 0 &amp;&amp; s &amp;&amp; !abortboot (bootdelay)) {    /*uboot延时期间没有被打断则进入if判断*/
# ifdef CONFIG_AUTOBOOT_KEYED
        int prev = disable_ctrlc(1);                /* disable Control C checking */
# endif

# ifndef CFG_HUSH_PARSER
        run_command (s, 0);
# else
        parse_string_outer(s, FLAG_PARSE_SEMICOLON |
                    FLAG_EXIT_FROM_LOOP);
# endif

# ifdef CONFIG_AUTOBOOT_KEYED
        disable_ctrlc(prev);                        /* restore Control C checking */
# endif
    }

# ifdef CONFIG_MENUKEY
    if (menukey == CONFIG_MENUKEY) {
        s = getenv("menucmd");
        if (s) {
# ifndef CFG_HUSH_PARSER
        run_command (s, 0);
# else
        parse_string_outer(s, FLAG_PARSE_SEMICOLON |
                    FLAG_EXIT_FROM_LOOP);
# endif
        }
    }
#endif /* CONFIG_MENUKEY */
#endif  /* CONFIG_BOOTDELAY */

#ifdef CONFIG_AMIGAONEG3SE
    {
        extern void video_banner(void);
        video_banner();
    }
#endif

    //FriendlyARMMenu();                        /*友善之臂uboot界面*/
    /*
     * Main Loop for Monitor Command Processing
     */
#ifdef CFG_HUSH_PARSER
    parse_file_outer();                         /*读取用户命令并执行*/
    /* This point is never reached */
    for (;;);
#else
    for (;;) {                                  
#ifdef CONFIG_BOOT_RETRY_TIME
        if (rc &gt;= 0) {
            /* Saw enough of a valid command to
             * restart the timeout.
             */
            reset_cmd_timeout();
        }
#endif
        len = readline (CFG_PROMPT);            /*循环读取命令的一般实现方法:从终端读入用户输入的命令字符串，然后将该字符串作为参数调用run_command函数执行该命令*/

        flag = 0;   /* assume no special flags for now */
        if (len &gt; 0)
            strcpy (lastcommand, console_buffer);
        else if (len == 0)
            flag |= CMD_FLAG_REPEAT;
#ifdef CONFIG_BOOT_RETRY_TIME
        else if (len == -2) {
            /* -2 means timed out, retry autoboot
             */
            puts ("\nTimed out waiting for command\n");
# ifdef CONFIG_RESET_TO_RETRY
            /* Reinit board to run initialization code again */
            do_reset (NULL, 0, 0, NULL);
# else
            return;     /* retry autoboot */
# endif
        }
#endif

        if (len == -1)
            puts ("&lt;INTERRUPT&gt;\n");
        else
            rc = run_command (lastcommand, flag);

        if (rc &lt;= 0) {
            /* invalid command or not repeatable, forget it */
            lastcommand[0] = 0;
        }
    }
#endif /*CFG_HUSH_PARSER*/
}

/*解析执行用户命令*/
/****************************************************************************
 * returns:
 *  1  - command executed, repeatable
 *  0  - command executed but not repeatable, interrupted commands are
 *       always considered not repeatable
 *  -1 - not executed (unrecognized, bootd recursion or too many args)
 *           (If cmd is NULL or "" or longer than CFG_CBSIZE-1 it is
 *           considered unrecognized)
 * **************************************************************************/
int run_command (const char *cmd, int flag)
{
    cmd_tbl_t *cmdtp;
    char cmdbuf[CFG_CBSIZE];            /* working copy of cmd      */
    char *token;                        /* start of token in cmdbuf */
    char *sep;                          /* end of token (separator) in cmdbuf */
    char finaltoken[CFG_CBSIZE];
    char *str = cmdbuf;
    char *argv[CFG_MAXARGS + 1];        /* NULL terminated  */
    int argc, inquotes;
    int repeatable = 1;
    int rc = 0;
                                        /*解析用户命令字符串*/                 
#ifdef DEBUG_PARSER
    printf ("[RUN_COMMAND] cmd[%p]=\"", cmd);
    puts (cmd ? cmd : "NULL");          /* use puts - string may be loooong */
    puts ("\"\n");
#endif

    clear_ctrlc();                      /* forget any previous Control C */

    if (!cmd || !*cmd) {
        return -1;  /* empty command */
    }

    if (strlen(cmd) &gt;= CFG_CBSIZE) {
        puts ("## Command too long!\n");
        return -1;
    }

    strcpy (cmdbuf, cmd);

    /* Process separators and check for invalid
     * repeatable commands
     */

#ifdef DEBUG_PARSER
    printf ("[PROCESS_SEPARATORS] %s\n", cmd);
#endif
    while (*str) {

        /*
         * Find separator, or string end
         * Allow simple escape of ';' by writing "\;"
         */
        for (inquotes = 0, sep = str; *sep; sep++) {
            if ((*sep=='\'') &amp;&amp;
                (*(sep-1) != '\\'))
                inquotes=!inquotes;

            if (!inquotes &amp;&amp;
                (*sep == ';') &amp;&amp;    /* separator        */
                ( sep != str) &amp;&amp;    /* past string start    */
                (*(sep-1) != '\\')) /* and NOT escaped  */
                break;
        }

        /*
         * Limit the token to data between separators
         */
        token = str;
        if (*sep) {
            str = sep + 1;  /* start of command for next pass */
            *sep = '\0';
        }
        else
            str = sep;  /* no more commands for next pass */
#ifdef DEBUG_PARSER
        printf ("token: \"%s\"\n", token);
#endif

        /* find macros in this token and replace them */
        process_macros (token, finaltoken);

        /* Extract arguments */
        if ((argc = parse_line (finaltoken, argv)) == 0) {
            rc = -1;    /* no command at all */
            continue;
        }
                                                        /*用户命令解析完毕，解析结果尊放在argv中*/                                                         
        /* Look up command in command table */
        if ((cmdtp = find_cmd(argv[0])) == NULL) {      /*根据argv[0]去查询具体命令，返回cmdtp结构体指针*/
            printf ("Unknown command '%s' - try 'help'\n", argv[0]);
            rc = -1;    /* give up after bad command */
            continue;
        }

        /* found - check max args */
        if (argc &gt; cmdtp-&gt;maxargs) {
            printf ("Usage:\n%s\n", cmdtp-&gt;usage);
            rc = -1;
            continue;
        }

#if (CONFIG_COMMANDS &amp; CFG_CMD_BOOTD)
        /* avoid "bootd" recursion */
        if (cmdtp-&gt;cmd == do_bootd) {
#ifdef DEBUG_PARSER
            printf ("[%s]\n", finaltoken);
#endif
            if (flag &amp; CMD_FLAG_BOOTD) {
                puts ("'bootd' recursion detected\n");
                rc = -1;
                continue;
            } else {
                flag |= CMD_FLAG_BOOTD;
            }
        }
#endif  /* CFG_CMD_BOOTD */

        /* OK - call function to do the command */
        if ((cmdtp-&gt;cmd) (cmdtp, flag, argc, argv) != 0) {
            rc = -1;
        }

        repeatable &amp;= cmdtp-&gt;repeatable;

        /* Did the user stop this? */
        if (had_ctrlc ())
            return 0;   /* if stopped then not repeatable */
    }

    return rc ? rc : repeatable;
}
</code></pre>

<h2>在uboot中添加自定义命令，以led为例</h2>

<ol>
<li>实现自定义函数do_leds，添加U_BOOT_CMD宏定义，形成源代码文件cmd_leds.c</li>
<li>将该文件放到common目录下，并修改common/Makefile以使该c文件被编译</li>
<li>在include/cmd_confdefs.h中增加宏定义CFG_CMD_LEDS，以便使得leds命令能被用户通过include/configs/xxxx.h进行裁剪</li>
<li>修改include/configs/xxxx.h中对CONFIG_COMMANDS宏的定义，使其包含CFG_CMD_LEDS宏</li>
</ol>


<pre><code class="C include/command.h">#define Struct_Section  __attribute__ ((unused,section (".u_boot_cmd")))

#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \
cmd_tbl_t __u_boot_cmd_##name Struct_Section = {#name, maxargs, rep, cmd, usage}
</code></pre>

<pre><code class="C common/cmd_net.c">U_BOOT_CMD(
    ping,   2,  1,  do_ping,
    "ping\t- send ICMP ECHO_REQUEST to network host\n",
    "pingAddress\n"
);
</code></pre>

<p><strong>上面代码定义了一个全局已初始化变量__u_boot_cmd_ping,类型是结构体类型cmd_tbl_t,该结构体变量的第一个字段存放的是用户将来会在uboot命令行中输入的命令名称字符串&ndash;“ping”，该结构变量第4个字段存放的是实现该命令的函数的函数名称，该变量存放在uboot.bin的二进制代码的.u_boot_cmd段</strong></p>

<pre><code class="C common/cmd_bootm.c">#ifndef CFG_BOOTM_LEN
#define CFG_BOOTM_LEN   0x800000        /* use 8MByte as default max gunzip size */
#endif
image_header_t header;                  /*这是很重要的全局变量， 会被armlinux.c 里面的do_bootm_linux()使用*/
ulong load_addr = CFG_LOAD_ADDR;        /* Default Load Address=0x5000_0000 */

int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
    ulong   iflag;
    ulong   addr;
    ulong   data, len, checksum;
    ulong  *len_ptr = NULL;             /* not to make warning. by scsuh */
    uint    unc_len = CFG_BOOTM_LEN;
    int i, verify;
    char    *name, *s;
    int (*appl)(int, char *[]);
    image_header_t *hdr = &amp;header;

    s = getenv ("verify");              /*读取环境变量“verify”*/
    verify = (s &amp;&amp; (*s == 'n')) ? 0 : 1;

    if (argc &lt; 2) {
        addr = load_addr;
    } else {
        addr = simple_strtoul(argv[1], NULL, 16);   /*addr=kernel在内存中的地址*/
    }

#ifdef CONFIG_ZIMAGE_BOOT
#define LINUX_ZIMAGE_MAGIC  0x016f2818
    if (*(ulong *)(addr + 9*4) == LINUX_ZIMAGE_MAGIC) {
        printf("Boot with zImage\n");
        addr = virt_to_phys(addr);
        hdr-&gt;ih_os = IH_OS_LINUX;
        hdr-&gt;ih_ep = ntohl(addr);
        goto after_header_check;
    }
#endif

    SHOW_BOOT_PROGRESS (1);
    //printf ("## Booting image at %08lx ...\n", addr);

    /* Copy header so we can blank CRC field for re-calculation */
#ifdef CONFIG_HAS_DATAFLASH
    if (addr_dataflash(addr)){
        read_dataflash(addr, sizeof(image_header_t), (char *)&amp;header);
    } else
#endif
    memmove (&amp;header, (char *)addr, sizeof(image_header_t));

    if (ntohl(hdr-&gt;ih_magic) != IH_MAGIC) {
#ifdef __I386__ /* correct image format not implemented yet - fake it */
        if (fake_header(hdr, (void*)addr, -1) != NULL) {
            /* to compensate for the addition below */
            addr -= sizeof(image_header_t);
            /* turnof verify,
             * fake_header() does not fake the data crc
             */
            verify = 0;
        } else
#endif  /* __I386__ */
        {
#ifdef CONFIG_IMAGE_BOOT
        //printf("Boot with Image\n");
        addr = virt_to_phys(addr);
        hdr-&gt;ih_os = IH_OS_LINUX;
        hdr-&gt;ih_ep = ntohl(addr);
        hdr-&gt;ih_comp = IH_COMP_NONE;
        goto after_header_check;
#endif
        puts ("Bad Magic Number\n");
        SHOW_BOOT_PROGRESS (-1);
        return 1;
        }
    }
    SHOW_BOOT_PROGRESS (2);

    data = (ulong)&amp;header;
    len  = sizeof(image_header_t);      /*header的长度0x40*/

    checksum = ntohl(hdr-&gt;ih_hcrc);
    hdr-&gt;ih_hcrc = 0;

    if (crc32 (0, (uchar *)data, len) != checksum) {    /*crc头校验*/
        puts ("Bad Header Checksum\n");
        SHOW_BOOT_PROGRESS (-2);
        return 1;
    }
    SHOW_BOOT_PROGRESS (3);

#ifdef CONFIG_HAS_DATAFLASH
    if (addr_dataflash(addr)){
        len  = ntohl(hdr-&gt;ih_size) + sizeof(image_header_t);
        read_dataflash(addr, len, (char *)CFG_LOAD_ADDR);
        addr = CFG_LOAD_ADDR;
    }
#endif


    /* for multi-file images we need the data part, too */
    print_image_hdr ((image_header_t *)addr);

    data = addr + sizeof(image_header_t);           /*指向了后面的kernel部分*/
    len  = ntohl(hdr-&gt;ih_size);                     /*kernel的实际大小就是编译后的大小*/

    if (verify) {
        puts ("   Verifying Checksum ... ");
        if (crc32 (0, (uchar *)data, len) != ntohl(hdr-&gt;ih_dcrc)) {
            printf ("Bad Data CRC\n");
            SHOW_BOOT_PROGRESS (-3);
            return 1;
        }
        puts ("OK\n");
    }
    SHOW_BOOT_PROGRESS (4);

    len_ptr = (ulong *)data;

#if defined(__PPC__)
    if (hdr-&gt;ih_arch != IH_CPU_PPC)
#elif defined(__ARM__)
    if (hdr-&gt;ih_arch != IH_CPU_ARM)
#elif defined(__I386__)
    if (hdr-&gt;ih_arch != IH_CPU_I386)
#elif defined(__mips__)
    if (hdr-&gt;ih_arch != IH_CPU_MIPS)
#elif defined(__nios__)
    if (hdr-&gt;ih_arch != IH_CPU_NIOS)
#elif defined(__M68K__)
    if (hdr-&gt;ih_arch != IH_CPU_M68K)
#elif defined(__microblaze__)
    if (hdr-&gt;ih_arch != IH_CPU_MICROBLAZE)
#elif defined(__nios2__)
    if (hdr-&gt;ih_arch != IH_CPU_NIOS2)
#elif defined(__blackfin__)
    if (hdr-&gt;ih_arch != IH_CPU_BLACKFIN)
#elif defined(__avr32__)
    if (hdr-&gt;ih_arch != IH_CPU_AVR32)
#else
# error Unknown CPU type
#endif
    {
        printf ("Unsupported Architecture 0x%x\n", hdr-&gt;ih_arch);
        SHOW_BOOT_PROGRESS (-4);
        return 1;
    }
    SHOW_BOOT_PROGRESS (5);

    switch (hdr-&gt;ih_type) {
    case IH_TYPE_STANDALONE:
        name = "Standalone Application";
        /* A second argument overwrites the load address */
        if (argc &gt; 2) {
            hdr-&gt;ih_load = htonl(simple_strtoul(argv[2], NULL, 16));
        }
        break;
    case IH_TYPE_KERNEL:
        name = "Kernel Image";
        break;
    case IH_TYPE_MULTI:
        name = "Multi-File Image";
        len  = ntohl(len_ptr[0]);
        /* OS kernel is always the first image */
        data += 8; /* kernel_len + terminator */
        for (i=1; len_ptr[i]; ++i)
            data += 4;
        break;
    default: printf ("Wrong Image Type for %s command\n", cmdtp-&gt;name);
        SHOW_BOOT_PROGRESS (-5);
        return 1;
    }
    SHOW_BOOT_PROGRESS (6);

    /*
     * We have reached the point of no return: we are going to
     * overwrite all exception vector code, so we cannot easily
     * recover from any failures any more...
     */

    iflag = disable_interrupts();

#ifdef CONFIG_AMIGAONEG3SE
    /*
     * We've possible left the caches enabled during
     * bios emulation, so turn them off again
     */
    icache_disable();
    invalidate_l1_instruction_cache();
    flush_data_cache();
    dcache_disable();
#endif
                                        /*下面开始搬运kernel到ih_load指定的地址上去*/
    switch (hdr-&gt;ih_comp) {
    case IH_COMP_NONE:
        if(ntohl(hdr-&gt;ih_load) == addr) {
            printf ("   XIP %s ... ", name);    /*XIP:原地执行*/
        } else {
#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
            size_t l = len;
            void *to = (void *)ntohl(hdr-&gt;ih_load);
            void *from = (void *)data;

            printf ("   Loading %s ... ", name);

            while (l &gt; 0) {
                size_t tail = (l &gt; CHUNKSZ) ? CHUNKSZ : l;
                WATCHDOG_RESET();
                memmove (to, from, tail);
                to += tail;
                from += tail;
                l -= tail;
            }
#else   /* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
            memmove ((void *) ntohl(hdr-&gt;ih_load), (uchar *)data, len); /*搬运代码*/
#endif  /* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
        }
        break;
    case IH_COMP_GZIP:
        printf ("   Uncompressing %s ... ", name);
        if (gunzip ((void *)ntohl(hdr-&gt;ih_load), unc_len,       /*把它解压到 ih_load的位置上去*/
                (uchar *)data, &amp;len) != 0) {
            puts ("GUNZIP ERROR - must RESET board to recover\n");
            SHOW_BOOT_PROGRESS (-6);
            do_reset (cmdtp, flag, argc, argv);
        }
        break;
#ifdef CONFIG_BZIP2
    case IH_COMP_BZIP2:
        printf ("   Uncompressing %s ... ", name);
        /*
         * If we've got less than 4 MB of malloc() space,
         * use slower decompression algorithm which requires
         * at most 2300 KB of memory.
         */
        i = BZ2_bzBuffToBuffDecompress ((char*)ntohl(hdr-&gt;ih_load),
                        &amp;unc_len, (char *)data, len,
                        CFG_MALLOC_LEN &lt; (4096 * 1024), 0);
        if (i != BZ_OK) {
            printf ("BUNZIP2 ERROR %d - must RESET board to recover\n", i);
            SHOW_BOOT_PROGRESS (-6);
            udelay(100000);
            do_reset (cmdtp, flag, argc, argv);
        }
        break;
#endif /* CONFIG_BZIP2 */
    default:
        if (iflag)
            enable_interrupts();
        printf ("Unimplemented compression type %d\n", hdr-&gt;ih_comp);
        SHOW_BOOT_PROGRESS (-7);
        return 1;
    }
    puts ("OK\n");                          /*搬运完毕*/
    SHOW_BOOT_PROGRESS (7);

    switch (hdr-&gt;ih_type) {
    case IH_TYPE_STANDALONE:
        if (iflag)
            enable_interrupts();

        /* load (and uncompress), but don't start if "autostart"
         * is set to "no"
         */
        if (((s = getenv("autostart")) != NULL) &amp;&amp; (strcmp(s,"no") == 0)) {
            char buf[32];
            sprintf(buf, "%lX", len);
            setenv("filesize", buf);
            return 0;
        }
        appl = (int (*)(int, char *[]))ntohl(hdr-&gt;ih_ep);
        (*appl)(argc-1, &amp;argv[1]);
        return 0;
    case IH_TYPE_KERNEL:
    case IH_TYPE_MULTI:
        /* handled below */
        break;
    default:
        if (iflag)
            enable_interrupts();
        printf ("Can't boot image type %d\n", hdr-&gt;ih_type);
        SHOW_BOOT_PROGRESS (-8);
        return 1;
    }
    SHOW_BOOT_PROGRESS (8);

#if defined(CONFIG_ZIMAGE_BOOT) || defined(CONFIG_IMAGE_BOOT)
after_header_check:
#endif
    switch (hdr-&gt;ih_os) {               /*判断何种操作系统*/
    default:            /* handled by (original) Linux case */
    case IH_OS_LINUX:
#ifdef CONFIG_SILENT_CONSOLE
        fixup_silent_linux();
#endif
        do_bootm_linux  (cmdtp, flag, argc, argv,       /*开始启动linux内核*/
                 addr, len_ptr, verify);
        break;
    case IH_OS_NETBSD:
        do_bootm_netbsd (cmdtp, flag, argc, argv,
                 addr, len_ptr, verify);
        break;

#ifdef CONFIG_LYNXKDI
    case IH_OS_LYNXOS:
        do_bootm_lynxkdi (cmdtp, flag, argc, argv,
                 addr, len_ptr, verify);
        break;
#endif

    case IH_OS_RTEMS:
        do_bootm_rtems (cmdtp, flag, argc, argv,
                 addr, len_ptr, verify);
        break;

#if (CONFIG_COMMANDS &amp; CFG_CMD_ELF)
    case IH_OS_VXWORKS:
        do_bootm_vxworks (cmdtp, flag, argc, argv,
                  addr, len_ptr, verify);
        break;
    case IH_OS_QNX:
        do_bootm_qnxelf (cmdtp, flag, argc, argv,
                  addr, len_ptr, verify);
        break;
#endif /* CFG_CMD_ELF */
#ifdef CONFIG_ARTOS
    case IH_OS_ARTOS:
        do_bootm_artos  (cmdtp, flag, argc, argv,
                 addr, len_ptr, verify);
        break;
#endif
    }

    SHOW_BOOT_PROGRESS (-9);
#ifdef DEBUG
    puts ("\n## Control returned to monitor - resetting...\n");
    do_reset (cmdtp, flag, argc, argv);
#endif
    return 1;
}
</code></pre>

<pre><code class="C lib_arm/armlinux.c">extern image_header_t header;   /* from cmd_bootm.c */
void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
             ulong addr, ulong *len_ptr, int verify)
{
    ulong len = 0, checksum;
    ulong initrd_start, initrd_end;
    ulong data;
    void (*theKernel)(int zero, int arch, uint params);
    image_header_t *hdr = &amp;header;
    bd_t *bd = gd-&gt;bd;

#ifdef CONFIG_CMDLINE_TAG
    char *commandline = getenv ("bootargs");
#endif

    theKernel = (void (*)(int, int, uint))ntohl(hdr-&gt;ih_ep);

    /*
     * Check if there is an initrd image
     */
    if (argc &gt;= 3) {
        SHOW_BOOT_PROGRESS (9);

        addr = simple_strtoul (argv[2], NULL, 16);

        printf ("## Loading Ramdisk Image at %08lx ...\n", addr);

        /* Copy header so we can blank CRC field for re-calculation */
#ifdef CONFIG_HAS_DATAFLASH
        if (addr_dataflash (addr)) {
            read_dataflash (addr, sizeof (image_header_t),
                    (char *) &amp;header);
        } else
#endif
            memcpy (&amp;header, (char *) addr,
                sizeof (image_header_t));

        if (ntohl (hdr-&gt;ih_magic) != IH_MAGIC) {
            printf ("Bad Magic Number\n");
            SHOW_BOOT_PROGRESS (-10);
            do_reset (cmdtp, flag, argc, argv);
        }

        data = (ulong) &amp; header;
        len = sizeof (image_header_t);

        checksum = ntohl (hdr-&gt;ih_hcrc);
        hdr-&gt;ih_hcrc = 0;

        if (crc32 (0, (unsigned char *) data, len) != checksum) {
            printf ("Bad Header Checksum\n");
            SHOW_BOOT_PROGRESS (-11);
            do_reset (cmdtp, flag, argc, argv);
        }

        SHOW_BOOT_PROGRESS (10);

        print_image_hdr (hdr);

        data = addr + sizeof (image_header_t);
        len = ntohl (hdr-&gt;ih_size);

#ifdef CONFIG_HAS_DATAFLASH
        if (addr_dataflash (addr)) {
            read_dataflash (data, len, (char *) CFG_LOAD_ADDR);
            data = CFG_LOAD_ADDR;
        }
#endif

        if (verify) {
            ulong csum = 0;

            printf ("   Verifying Checksum ... ");
            csum = crc32 (0, (unsigned char *) data, len);
            if (csum != ntohl (hdr-&gt;ih_dcrc)) {
                printf ("Bad Data CRC\n");
                SHOW_BOOT_PROGRESS (-12);
                do_reset (cmdtp, flag, argc, argv);
            }
            printf ("OK\n");
        }

        SHOW_BOOT_PROGRESS (11);

        if ((hdr-&gt;ih_os != IH_OS_LINUX) ||
            (hdr-&gt;ih_arch != IH_CPU_ARM) ||
            (hdr-&gt;ih_type != IH_TYPE_RAMDISK)) {
            printf ("No Linux ARM Ramdisk Image\n");
            SHOW_BOOT_PROGRESS (-13);
            do_reset (cmdtp, flag, argc, argv);
        }

#if defined(CONFIG_B2) || defined(CONFIG_EVB4510) || defined(CONFIG_ARMADILLO)
        /*
         *we need to copy the ramdisk to SRAM to let Linux boot
         */
        memmove ((void *) ntohl(hdr-&gt;ih_load), (uchar *)data, len);
        data = ntohl(hdr-&gt;ih_load);
#endif /* CONFIG_B2 || CONFIG_EVB4510 */

        /*
         * Now check if we have a multifile image
         */
    } else if ((hdr-&gt;ih_type == IH_TYPE_MULTI) &amp;&amp; (len_ptr[1])) {
        ulong tail = ntohl (len_ptr[0]) % 4;
        int i;

        SHOW_BOOT_PROGRESS (13);

        /* skip kernel length and terminator */
        data = (ulong) (&amp;len_ptr[2]);
        /* skip any additional image length fields */
        for (i = 1; len_ptr[i]; ++i)
            data += 4;
        /* add kernel length, and align */
        data += ntohl (len_ptr[0]);
        if (tail) {
            data += 4 - tail;
        }

        len = ntohl (len_ptr[1]);

    } else {
        /*
         * no initrd image
         */
        SHOW_BOOT_PROGRESS (14);

        len = data = 0;
    }

#ifdef  DEBUG
    if (!data) {
        printf ("No initrd\n");
    }
#endif

    if (data) {
        initrd_start = data;
        initrd_end = initrd_start + len;
    } else {
        initrd_start = 0;
        initrd_end = 0;
    }

    SHOW_BOOT_PROGRESS (15);

    debug ("## Transferring control to Linux (at address %08lx) ...\n",
           (ulong) theKernel);

#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
    defined (CONFIG_CMDLINE_TAG) || \
    defined (CONFIG_INITRD_TAG) || \
    defined (CONFIG_SERIAL_TAG) || \
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
    setup_start_tag (bd);
#ifdef CONFIG_SERIAL_TAG
    setup_serial_tag (&amp;params);
#endif
#ifdef CONFIG_REVISION_TAG
    setup_revision_tag (&amp;params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
    setup_memory_tags (bd);
#endif
#ifdef CONFIG_CMDLINE_TAG
    setup_commandline_tag (bd, commandline);
#endif
#ifdef CONFIG_INITRD_TAG
    if (initrd_start &amp;&amp; initrd_end)
        setup_initrd_tag (bd, initrd_start, initrd_end);
#endif
#if defined (CONFIG_VFD) || defined (CONFIG_LCD)
    setup_videolfb_tag ((gd_t *) gd);
#endif
    setup_end_tag (bd);
#endif

    /* we assume that the kernel is in place */
    //printf ("\nStarting kernel ...\n\n");

#ifdef CONFIG_USB_DEVICE
    {
        extern void udc_disconnect (void);
        udc_disconnect ();
    }
#endif

    cleanup_before_linux ();        /*关闭中断，清空数据cache，关闭数据cache*/

    theKernel (0, bd-&gt;bi_arch_number, bd-&gt;bi_boot_params);  /*相当于执行mov r0,#0;mov r1 #2520;mov r2,#0x50000100;ldr pc,=0x50008000*/
}
</code></pre>

<blockquote><ol>
<li>在将内核映像复制到RAM空间中后，就可以准备启动Linux内核了。但是在调用内核之前应该作一步准备工作，即设置Linux内核的启动参数（根文件系统在Nand Flash上的位置是其中的1个参数）。Uboot必须将正确的内核的启动参数放到内存0x50000100处，然后将存放地址（0x50000100）告知内核。内核启动后，到0x50000100处去取得参数，内核必须取得正确的根文件系统在NandFlash上的位置参数后，才能挂载根文件系统。</li>
<li>Linux2.4.x以后的内核都期望以标记列表(tagged list)的形式来传递启动参数。启动参数标记列表以标记ATAG_CORE开始，以标记ATAG_NONE结束。每个标记由标识被传递参数的tag_header结构以及随后的参数值数据结构来组成。数据结构tag和tag_header定义在Linux内核源码的include/asm/setup.h头文件中，Uboot复制了该定义，放在include/asm-arm/setup.h中</li>
<li>内核至少需要4个tag：start_tag、end_tag、memory_tags、commandline_tag才能正确启动</li>
</ol>
</blockquote>

<pre><code class="C include/asm-arm/setup.h">/* The list ends with an ATAG_NONE node. */
#define ATAG_NONE   0x00000000

struct tag_header {
    u32 size;
    u32 tag;
};

/* The list must start with an ATAG_CORE node */
#define ATAG_CORE   0x54410001

struct tag_core {
    u32 flags;      /* bit 0 = read-only */
    u32 pagesize;
    u32 rootdev;
};

struct tag {
    struct tag_header hdr;
    union {
        struct tag_core     core;
        struct tag_mem32    mem;
        struct tag_videotext    videotext;
        struct tag_ramdisk  ramdisk;
        struct tag_initrd   initrd;
        struct tag_serialnr serialnr;
        struct tag_revision revision;
        struct tag_videolfb videolfb;
        struct tag_cmdline  cmdline;

        /*
         * Acorn specific
         */
        struct tag_acorn    acorn;

        /*
         * DC21285 specific
         */
        struct tag_memclk   memclk;
    } u;
};
</code></pre>

<pre><code class="C lib_arm/armlinux.c中标记列表的建立">static void setup_start_tag (bd_t *bd)
{
    params = (struct tag *) bd-&gt;bi_boot_params;

    params-&gt;hdr.tag = ATAG_CORE;
    params-&gt;hdr.size = tag_size (tag_core);

    params-&gt;u.core.flags = 0;
    params-&gt;u.core.pagesize = 0;
    params-&gt;u.core.rootdev = 0;

    params = tag_next (params);
}

static void setup_memory_tags (bd_t *bd)
{
    int i;

    for (i = 0; i &lt; CONFIG_NR_DRAM_BANKS; i++) {
        params-&gt;hdr.tag = ATAG_MEM;
        params-&gt;hdr.size = tag_size (tag_mem32);

        params-&gt;u.mem.start = bd-&gt;bi_dram[i].start;
        params-&gt;u.mem.size = bd-&gt;bi_dram[i].size;

        params = tag_next (params);
    }
}

static void setup_commandline_tag (bd_t *bd, char *commandline)
{
    char *p;

    if (!commandline)
        return;

    /* eat leading white space */
    for (p = commandline; *p == ' '; p++);

    /* skip non-existent command lines so the kernel will still
     * use its default command line.
     */
    if (*p == '\0')
        return;

    params-&gt;hdr.tag = ATAG_CMDLINE;
    params-&gt;hdr.size =
        (sizeof (struct tag_header) + strlen (p) + 1 + 4) &gt;&gt; 2;

    strcpy (params-&gt;u.cmdline.cmdline, p);

    params = tag_next (params);
}

static void setup_initrd_tag (bd_t *bd, ulong initrd_start, ulong initrd_end)
{
    /* an ATAG_INITRD node tells the kernel where the compressed
     * ramdisk can be found. ATAG_RDIMG is a better name, actually.
     */
    params-&gt;hdr.tag = ATAG_INITRD2;
    params-&gt;hdr.size = tag_size (tag_initrd);

    params-&gt;u.initrd.start = initrd_start;
    params-&gt;u.initrd.size = initrd_end - initrd_start;

    params = tag_next (params);
}

static void setup_end_tag (bd_t *bd)
{
    params-&gt;hdr.tag = ATAG_NONE;
    params-&gt;hdr.size = 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nand_cp.c]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/20/nand-cp-dot-c/"/>
    <updated>2015-06-20T15:17:22+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/20/nand-cp-dot-c</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;common.h&gt;
#ifdef CONFIG_S3C64XX
#include &lt;asm/io.h&gt;
#include &lt;linux/mtd/nand.h&gt;
#include &lt;regs.h&gt;

static int nandll_read_page (uchar *buf, ulong addr, int large_block)
{
    int i;
    int page_size = 512;

    if (large_block)    
        page_size = 2048;

        NAND_ENABLE_CE();               /*使能芯片*/

        NFCMD_REG = NAND_CMD_READ0;     /*读命令*/

        /* Write Address */
        NFADDR_REG = 0;                 /*页内起始地址*/

    if (large_block)
            NFADDR_REG = 0;

    NFADDR_REG = (addr) &amp; 0xff;         /*页地址*/
    NFADDR_REG = (addr &gt;&gt; 8) &amp; 0xff;
    NFADDR_REG = (addr &gt;&gt; 16) &amp; 0xff;

    if (large_block)
        NFCMD_REG = NAND_CMD_READSTART;

        NF_TRANSRnB();                  /*循环判断是否已经准备好*/

    for(i=0; i &lt; page_size; i++) {
                *buf++ = NFDATA8_REG;               
        }

        NAND_DISABLE_CE();
        return 0;
}

/*
 * Read data from NAND.
 */
static int nandll_read_blocks (ulong dst_addr, ulong size, int large_block)
{
        uchar *buf = (uchar *)dst_addr;                     /*这里buf就是指定的0x57e0 0000物理地址*/
        int i;
    uint page_shift = 9;

    if (large_block)
        page_shift = 11;

        /* Read pages */
        for (i = 0; i &lt; (0x50000&gt;&gt;page_shift); i++, buf+=(1&lt;&lt;page_shift)) {
                nandll_read_page(buf, i, large_block);      /*一次读取一个页*/
        }

        return 0;
}

int copy_uboot_to_ram (void)
{
    int large_block = 0;
    int i;
    vu_char id;

    NAND_ENABLE_CE();               /*使能芯片*/
    NFCMD_REG = NAND_CMD_READID;
    NFADDR_REG =  0x00;             

    /* wait for a while */
        for (i=0; i&lt;200; i++);
    id = NFDATA8_REG;
    id = NFDATA8_REG;               /*取第二次的返回值*/

    if (id &gt; 0x80)                  //判断读取的id是否大于0x80
        large_block = 1;

    /* read NAND Block.
     * 128KB -&gt;240KB because of U-Boot size increase. by scsuh
     * So, read 0x3c000 bytes not 0x20000(128KB).
     */
    return nandll_read_blocks(CFG_PHY_UBOOT_BASE, 0x50000, large_block);
}

#endif
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cpu_init.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/19/cpu-init-dot-s/"/>
    <updated>2015-06-19T17:28:03+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/19/cpu-init-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;config.h&gt;                     /*里面包含mini6410.h*/
#include &lt;s3c6410.h&gt;

    .globl mem_ctrl_asm_init
mem_ctrl_asm_init:
    ldr r0, =ELFIN_MEM_SYS_CFG          @Memory sussystem address 0x7e00f120
    mov r1, #0xd                        @ Xm0CSn2 = NFCON CS0, Xm0CSn3 = NFCON CS1
    str r1, [r0]

    ldr r0, =ELFIN_DMC1_BASE            @DMC1 base address 0x7e001000

/* 1. 使dramc进入"config"状态 */
    ldr r1, =0x04
    str r1, [r0, #INDEX_DMC_MEMC_CMD]   

/* 2. 设置timing parameter*/
    ldr r1, =DMC_DDR_REFRESH_PRD
    str r1, [r0, #INDEX_DMC_REFRESH_PRD]        /*刷新周期7.8us */

    ldr r1, =DMC_DDR_CAS_LATENCY
    str r1, [r0, #INDEX_DMC_CAS_LATENCY]        /*CAS Latency:指的是内存存取数据所需的延迟时间，简单的说，就是内存接到CPU的指令后的反应速度。一般的参数值是2和3*/

    ldr r1, =DMC_DDR_t_DQSS
    str r1, [r0, #INDEX_DMC_T_DQSS]

    ldr r1, =DMC_DDR_t_MRD
    str r1, [r0, #INDEX_DMC_T_MRD]

    ldr r1, =DMC_DDR_t_RAS                      /*RAS=45ns*/
    str r1, [r0, #INDEX_DMC_T_RAS]

    ldr r1, =DMC_DDR_t_RC                       /*RC=68ns*/
    str r1, [r0, #INDEX_DMC_T_RC]

    ldr r1, =DMC_DDR_t_RCD
    ldr r2, =DMC_DDR_schedule_RCD
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RCD]

    ldr r1, =DMC_DDR_t_RFC
    ldr r2, =DMC_DDR_schedule_RFC
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RFC]

    ldr r1, =DMC_DDR_t_RP
    ldr r2, =DMC_DDR_schedule_RP
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RP]

    ldr r1, =DMC_DDR_t_RRD
    str r1, [r0, #INDEX_DMC_T_RRD]

    ldr r1, =DMC_DDR_t_WR
    str r1, [r0, #INDEX_DMC_T_WR]

    ldr r1, =DMC_DDR_t_WTR
    str r1, [r0, #INDEX_DMC_T_WTR]

    ldr r1, =DMC_DDR_t_XP
    str r1, [r0, #INDEX_DMC_T_XP]

    ldr r1, =DMC_DDR_t_XSR
    str r1, [r0, #INDEX_DMC_T_XSR]

    ldr r1, =DMC_DDR_t_ESR
    str r1, [r0, #INDEX_DMC_T_ESR]

/* 3.设置chip configuration*/
    ldr r1, =DMC1_MEM_CFG
    str r1, [r0, #INDEX_DMC_MEMORY_CFG]

    ldr r1, =DMC1_MEM_CFG2
    str r1, [r0, #INDEX_DMC_MEMORY_CFG2]

    ldr r1, =DMC1_CHIP0_CFG
    str r1, [r0, #INDEX_DMC_CHIP_0_CFG]

    ldr r1, =DMC_DDR_32_CFG
    str r1, [r0, #INDEX_DMC_USER_CONFIG]

/* 4. 初始化sdram */
    @DMC0 DDR Chip 0 configuration direct command reg
    ldr r1, =DMC_NOP0                                   /* NOP*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Precharge All
    ldr r1, =DMC_PA0                                    /*precharge*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Auto Refresh   2 time
    ldr r1, =DMC_AR0
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]                 /*auto refresh*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @MRS
    ldr r1, =DMC_mDDR_EMR0                              /*EMRS*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Mode Reg
    ldr r1, =DMC_mDDR_MR0                               /*MRS*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

#ifdef CONFIG_SMDK6410_X5A
    ldr r1, =DMC1_CHIP1_CFG
    str r1, [r0, #INDEX_DMC_CHIP_1_CFG]

    @DMC0 DDR Chip 0 configuration direct command reg
    ldr r1, =DMC_NOP1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Precharge All
    ldr r1, =DMC_PA1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Auto Refresh   2 time
    ldr r1, =DMC_AR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @MRS
    ldr r1, =DMC_mDDR_EMR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Mode Reg
    ldr r1, =DMC_mDDR_MR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]
#endif

/* 5. 使dramc进入"ready"状态   */
    @Enable DMC1
    mov r1, #0x0
    str r1, [r0, #INDEX_DMC_MEMC_CMD]

check_dmc1_ready:
    ldr r1, [r0, #INDEX_DMC_MEMC_STATUS]
    mov r2, #0x3
    and r1, r1, r2
    cmp r1, #0x1
    bne check_dmc1_ready
    nop
    mov pc, lr                              /*内存控制器初始化完毕，返回*/


/* Below code is for ARM926EJS and ARM1026EJS */
    .globl cleanDCache
cleanDCache:
    mrc p15, 0, pc, c7, c10, 3  /* test/clean D-Cache */
    bne cleanDCache
    mov pc, lr

    .globl cleanFlushDCache
cleanFlushDCache:
    mrc p15, 0, pc, c7, c14, 3  /* test/cleanflush D-Cache */
    bne cleanFlushDCache
    mov pc, lr

    .globl cleanFlushCache
cleanFlushCache:
    mrc p15, 0, pc, c7, c14, 3  /* test/cleanflush D-Cache */
    bne cleanFlushCache
    mcr p15, 0, r0, c7, c5, 0   /* flush I-Cache */
    mov pc, lr

    .ltorg
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lowlevel_init.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/18/lowlevel-init-dot-s/"/>
    <updated>2015-06-18T15:38:36+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/18/lowlevel-init-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;config.h&gt;
#include &lt;version.h&gt;
#include &lt;s3c6410.h&gt;
#include "mini6410_val.h"

_TEXT_BASE:
    .word   TEXT_BASE

    .globl lowlevel_init
lowlevel_init:
    mov r12, lr                     /*bl指令会把下一条指令的地址赋给lr，在这里保存lr是为了最后能够成功地函数返回*/

    /* LED on only #8 */
    ldr r0, =ELFIN_GPIO_BASE        /*Regs.h中的宏定义，就是s3c6410.h中的宏定义*/
    ldr r1, =0x55540000
    str r1, [r0, #GPNCON_OFFSET]    /*GPN15~GPN9均是输出(01),GPN0~GPN8均是输入(00)*/

    ldr r1, =0x55555555
    str r1, [r0, #GPNPUD_OFFSET]    /*GPN0~GPN15均是下拉使能*/

    ldr r1, =0xf000
    str r1, [r0, #GPNDAT_OFFSET]    /*GPN15~GPN12输出高电平，GPN10~11输出低电平*/

    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x1
    str r1, [r0, #GPECON_OFFSET]    /*GPE0设置为输出，GPE1~GPE15设置为输入*/
    ldr r1, =0x0
    str r1, [r0, #GPEDAT_OFFSET]    /*GPE0输出低电平,LCD_BL_EN=0*/

    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x2A5AAAAA
    str r1, [r0, #GPPCON_OFFSET]    /*GPP15设置为输入，GPP11~GPP10设置为输出，其余设置为片内外设功能*/
    ldr r1, =0x0
    str r1, [r0, #GPPDAT_OFFSET]    /*GPP11和GPP10输出低电平*/


    ldr r1, =0x55555555
    str r1, [r0, #MEM1DRVCON_OFFSET]    /*由于ddr芯片的工作电压在1.8V，所以驱动电流设置为7mA*/

    /* Disable Watchdog */              /*关闭片内看门狗*/
    ldr r0, =0x7e000000     @0x7e004000
    orr r0, r0, #0x4000
    mov r1, #0
    str r1, [r0]

    @ External interrupt pending clear
    ldr r0, =(ELFIN_GPIO_BASE+EINTPEND_OFFSET)  /*EINTPEND*/
    ldr r1, [r0]                        /*读一次外部中断就能清楚外部中断信号*/
    str r1, [r0]

    ldr r0, =ELFIN_VIC0_BASE_ADDR   @0x71200000
    ldr r1, =ELFIN_VIC1_BASE_ADDR   @0x71300000

    @ Disable all interrupts (VIC0 and VIC1)
    mvn r3, #0x0                        /*0取反为全1*/
    str r3, [r0, #oINTMSK]              /*禁用所有中断*/
    str r3, [r1, #oINTMSK]

    @ Set all interrupts as IRQ
    mov r3, #0x0
    str r3, [r0, #oINTMOD]              /*将所有中断设置为IRQ中断*/
    str r3, [r1, #oINTMOD]

    @ Pending Interrupt Clear
    mov r3, #0x0                        /*清除所有当前激活的中断服务程序的地址*/
    str r3, [r0, #oVECTADDR]
    str r3, [r1, #oVECTADDR]

    /* init system clock */
    bl system_clock_init                /*初始化系统时钟*/

    /* for UART */
    bl uart_asm_init                    /*初始化串口*/

#if defined(CONFIG_NAND)
    /* simple init for NAND */
    bl nand_asm_init                    /*nand flash初始化*/
#endif

    bl  mem_ctrl_asm_init               /*内存控制器初始化,函数位于/CPU/s3c6410/CPU_init.S*/

    ldr     r0, =(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)       /*7e00_f904-&gt;RST_STAT*/
    ldr     r1, [r0]
    bic     r1, r1, #0xfffffff7
    cmp     r1, #0x8                    /*bit[3]=1,表明从SLEEP状态中唤醒*/
    beq     wakeup_reset

1:
    ldr r0, =ELFIN_UART_BASE
    ldr r1, =0x4b4b4b4b                 /*通过串口发送字母“K”*/
    str r1, [r0, #UTXH_OFFSET]

    mov lr, r12
    mov pc, lr                          /*lowlevel_init结束，返回*/

wakeup_reset:

    ldr r0, =(ELFIN_CLOCK_POWER_BASE+WAKEUP_STAT_OFFSET)
    ldr r1, [r0]
    str r1, [r0]                        /*Clear wakeup status register*/

    /*LED test*/
    ldr     r0, =ELFIN_GPIO_BASE
    ldr     r1, =0x3000
    str     r1, [r0, #GPNDAT_OFFSET]

    /*Load return address and jump to kernel*/
    ldr r0, =(ELFIN_CLOCK_POWER_BASE+INF_REG0_OFFSET)       /*0x4c00_0a00-&gt;INFORM0*/
    ldr r1, [r0]                                            /* r1 = physical address of s3c6400_cpu_resume function*/
    mov pc, r1                                              /*Jump to kernel (sleep-s3c6400.S)*/
    nop
    nop

/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
    ldr r0, =ELFIN_CLOCK_POWER_BASE @0x7e00f000

#ifdef  CONFIG_SYNC_MODE
    ldr r1, [r0, #OTHERS_OFFSET]
    mov r2, #0x40
    orr r1, r1, r2
    str r1, [r0, #OTHERS_OFFSET]                

    nop
    nop
    nop
    nop
    nop

    ldr r2, =0x80
    orr r1, r1, r2
    str r1, [r0, #OTHERS_OFFSET]            /*bit[6],bit[7]都置1，设置成同步模式*/

check_syncack:                              /*等待时钟完成同步*/
    ldr r1, [r0, #OTHERS_OFFSET]
    ldr r2, =0xf00
    and r1, r1, r2                          /*只查看bit[8]~bit[11]，这几位是SYNC mode相应位，只读,只有在AYNC模式才能读1*/
    cmp r1, #0xf00
    bne check_syncack
#else                                       /* 否则配置成异步时钟模式 */
    nop
    nop
    nop
    nop
    nop

    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0xC0
    orr r1, r1, #0x40                       /*bit[6]置1，bit[7]清0*/
    str r1, [r0, #OTHERS_OFFSET]            

wait_for_async:
    ldr r1, [r0, #OTHERS_OFFSET]
    and r1, r1, #0xf00
    cmp r1, #0x0
    bne wait_for_async

    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0x40                       /*bit[6]清0*/
    str r1, [r0, #OTHERS_OFFSET]
#endif

    mov r1, #0xff00
    orr r1, r1, #0xff                       /*设置各PLL的LOCK_TIME,使用最大值*/
    str r1, [r0, #APLL_LOCK_OFFSET]         /*APLL_LOCK，供cpu使用*/ 
    str r1, [r0, #MPLL_LOCK_OFFSET]         /*MPLL_LOCK，供AHB(存储/中断/lcd等控制器)/APB(看门狗，定时器，SD等)总线上的设备使用*/
    str r1, [r0, #EPLL_LOCK_OFFSET]         /*EPLL_LOCK，供UART,IIS,IIC使用*/

#if defined(CONFIG_CLKSRC_CLKUART)
    ldr     r1, [r0, #CLK_DIV2_OFFSET]
    bic r1, r1, #0x70000
    orr r1, r1, #0x30000                    /*CLK_DIV2的bit[16]~bit[19]即UART_RATIO,设置为3,CLKUART(66.5Mhz)=CLKUART_input(532/2=266Mhz)/(UART_RATIO(3)+1)*/
    str r1, [r0, #CLK_DIV2_OFFSET]
#endif

    ldr     r1, [r0, #CLK_DIV0_OFFSET]      /*Set Clock Divider*/
    bic r1, r1, #0x30000
    bic r1, r1, #0xff00
    bic r1, r1, #0xff
    ldr r2, =CLK_DIV_VAL
    orr r1, r1, r2
    str r1, [r0, #CLK_DIV0_OFFSET]          /*设置时钟的分频系数*/

    ldr r1, =APLL_VAL                       /*设置APLL_MDIV=266,APLL_PDIV=3,APLL_SDIV=1*/
    str r1, [r0, #APLL_CON_OFFSET]          /*FOUT = MDIV X FIN / (PDIV X 2^SDIV) = 266*12/(3*2^1) = 532MHz*/
    ldr r1, =MPLL_VAL                       /*设置MPLL_MDIV=266,MPLL_PDIV=3,MPLL_SDIV=1*/
    str r1, [r0, #MPLL_CON_OFFSET]          /*FOUT = MDIV X FIN / (PDIV X 2^SDIV) = 266*12/(3*2^1) = 532MHz*/

    ldr r1, =0x80200102                     /*设置EPLL_MDIV=32,EPLL_PDIV=1,EPLL_SDIV=2*/
    str r1, [r0, #EPLL_CON0_OFFSET]         /*FOUT = (MDIV+KDIV/2^16) X FIN / (PDIV X 2^SDIV) = (32+0)*12/(1*2^2) = 96MHz*/
    ldr r1, =0x0                            /*设置EPLL_KDIV=0*/
    str r1, [r0, #EPLL_CON1_OFFSET]

    ldr r1, [r0, #CLK_SRC_OFFSET]           /*读取CLK_SRC寄存器的值*/

#if defined(CONFIG_CLKSRC_CLKUART)
    ldr r2, =0x2007                                 
#else
    ldr r2, =0x7
#endif
    orr r1, r1, r2                          /*APLL,MPLL,EPLL的时钟源选择各自的Fout；UART的时钟源选择DOUT_MPLL*/

    str r1, [r0, #CLK_SRC_OFFSET]

    mov r1, #0x10000                        /*等待所有时钟稳定，至少200us*/
1:  subs    r1, r1, #1                      /*非0则跳转*/
    bne 1b

#ifdef CONFIG_SYNC_MODE                     /* Synchronization for VIC port */
    ldr r1, [r0, #OTHERS_OFFSET]
    orr r1, r1, #0x20
    str r1, [r0, #OTHERS_OFFSET]
#else
    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0x20
    str r1, [r0, #OTHERS_OFFSET]
#endif

    mov pc, lr                              /*系统时钟初始化完成，返回*/


/*
 * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
 * void uart_asm_init(void)
 */
uart_asm_init:
    /*配置GPIO的功能为串口UART*/
    /*UART0_RXD=GPA0,UART0_TXD=GPA1,UART1_RXD=GPA4,UART1_TXD=GPA5*/
    /*UART2_RXD=GPB0,UART2_TXD=GPB1,UART3_RXD=GPB2,UART3_TXD=GPB3*/
    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x22222222
    str     r1, [r0, #GPACON_OFFSET]        /*配置UART0和UART1使用的GPIO引脚,UART0和UART1具有流控功能(GPA0~GPA7)*/
    ldr r1, =0x2222
    str     r1, [r0, #GPBCON_OFFSET]        /*配置UART2和UART3使用的GPIO引脚,UART2和UART3不具有流控功能(GPB0~GPB3)*/

    ldr r0, =ELFIN_UART_CONSOLE_BASE        /*ELFIN_UART_CONSOLE_BASE=0x7F005000,即UART0*/
    mov r1, #0x0
    str r1, [r0, #UFCON_OFFSET]             /*禁止使用FIFO*/
    str r1, [r0, #UMCON_OFFSET]             /*禁止流控，调制解调功能*/

    mov r1, #0x3                            /*配置UART0：数据位:8, 无校验, 停止位: 1, 8n1*/
    str r1, [r0, #ULCON_OFFSET]

/*设置波特率 */
/*DIV_VAL = (EXT_UCLK1 / (bps x 16 ) ) - 1 = (66500000/(115200x16))-1 = 35.08*/
/*DIV_VAL = 35.08 = UBRDIVn + (num of 1’s in UDIVSLOTn)/16*/
#if defined(CONFIG_CLKSRC_CLKUART)
    ldr r1, =0xe45                          /* UARTCLK_SRC=11 =&gt; EXT_UCLK1,EXT_UCLK1由MPLL或者EPLL分频得到,这里是66.5MHz。串口数据接收发送采用轮训或者中断的方式*/
#else
    ldr r1, =0x245                          /* UARTCLK_SRC=x0 =&gt; PCLK */
#endif
    str r1, [r0, #UCON_OFFSET]

#if defined(CONFIG_UART_50)
    ldr r1, =0x1A
#elif defined(CONFIG_UART_66)
    ldr r1, =0x23
#else
    ldr r1, =0x1A
#endif
    str r1, [r0, #UBRDIV_OFFSET]            /*UBRDIV0=35*/

#if defined(CONFIG_UART_50)
    ldr r1, =0x3
#elif defined(CONFIG_UART_66)
    ldr r1, =0x0080
#else
    ldr r1, =0x3
#endif
    str r1, [r0, #UDIVSLOT_OFFSET]          /*UDIVSLOT0中有1个‘1’*/

    ldr r1, =0x4f4f4f4f
    str r1, [r0, #UTXH_OFFSET]              /*UART0串口发送字母‘O’*/

    mov pc, lr                              /*串口配置结束，返回*/

/*
 * Nand Interface Init for SMDK6410 
 * /
nand_asm_init:                              /*初始化NandFlash控制器*/
    ldr r0, =ELFIN_NAND_BASE
    ldr r1, [r0, #NFCONF_OFFSET]
    orr r1, r1, #0x70                       /*TWRPH1=7*/
    orr r1, r1, #0x7700                     /*TWRPH0=7,TACLS=7*/
    str     r1, [r0, #NFCONF_OFFSET]

    ldr r1, [r0, #NFCONT_OFFSET]
    orr r1, r1, #0x03                       /*使能NandFlash控制器*/
    str     r1, [r0, #NFCONT_OFFSET]

    mov pc, lr                              /*NandFlash控制器初始化完毕，返回*/


#ifdef CONFIG_ENABLE_MMU
                                            /*为Uboot服务的MMU页表在这里创建*/
                                            /* form a first-level section entry */
/*定义一个可以生成描述符的宏*/
/*描述符的最低两位00为无效，01为二级页表方式（由高地址12位的一级页表(TTB的高18位指定的虚拟基地址)位置取出对应二级页表(coarse page table)的基地址，由中间地址8位的二级页表取出对应4KB页表（small page）的基地址，最后由低12为地址的页表取出最终的内存值），10为一级页表方式（如果bit18为0，则为section，bit18为1，则为supersection），11保留。*/
.macro FL_SECTION_ENTRY base,ap,d,c,b       
    .word (\base &lt;&lt; 20) | (\ap &lt;&lt; 10) | \
          (\d &lt;&lt; 5) | (1&lt;&lt;4) | (\c &lt;&lt; 3) | (\b &lt;&lt; 2) | (1&lt;&lt;1)
.endm

/*按照section方式映射，每个section必须是1M，占20位地址，这里共256M物理内存，映射到整个4G地址空间，所以共有4096（0x1000）个描述符。虚拟地址的高12位（4096）作为描述符位置，低20位作为section里面的地址*/
.section .mmudata, "a"                      /*指名该段的名称是.mmudata,在u-boot.lds中会为该段分配具体的空间，.a表示这是一个需要鉴权的段*/
    .align 14                               /*对齐到0x4000*/
    // the following alignment creates the mmu table at address 0x4000.
    .globl mmu_table                        /*mmu页表地址需要在start.S中告诉CPU以启动MMU，因此需要声明为全局变量*/
mmu_table:
    .set __base,0
    // 1:1 mapping for debugging
    .rept 0xA00                             /*共2048个描述符*/
    FL_SECTION_ENTRY __base,3,0,0,0         /*ap为3表示读允许,d为0表示这些描述符都属于domain0，domain用来做权限控制,c和b为0表示共享，互斥读写*/
    .set __base,__base+1
    .endr

    // access is not allowed.
    .rept 0xC00 - 0xA00                     /*共512个描述符*/
    .word 0x00000000                        /*ap为0表示不允许访问*/
    .endr

    // 128MB for SDRAM 0xC0000000 -&gt; 0x50000000
    .set __base, 0x500
    .rept 0xC80 - 0xC00                     /*共128个描述符*/
    FL_SECTION_ENTRY __base,3,0,1,1         /*ap为3表示读允许,d为0表示这些描述符都属于domain0，domain用来做权限控制,c和b为1表示内存输入输出都为回写模式*/
    .set __base,__base+1
    .endr

    // access is not allowed.
    .rept 0x1000 - 0xc80                        /*共896个描述符*/
    .word 0x00000000                        /*ap为0表示不允许访问*/
    .endr

#endif
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mini6410.h]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/17/mini6410-dot-h/"/>
    <updated>2015-06-17T11:49:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/17/mini6410-dot-h</id>
    <content type="html"><![CDATA[<pre><code class="C">#define CONFIG_S3C6410      1       /* in a SAMSUNG S3C6410 SoC */
#define CONFIG_S3C64XX      1       /* in a SAMSUNG S3C64XX Family  */
#define CONFIG_MINI6410     1       /* in a FriendlyARM MINI6410 Board */

#define CFG_UBOOT_SIZE      (2*1024*1024)   /*定义Uboot大小为2M字节*/

#define CONFIG_ENABLE_MMU   /*在Uboot中开启MMU,目的为了开启DCache来提高运行速度*/
#define MEMORY_BASE_ADDRESS 0x50000000  /*DDR起始地址*/
#define CFG_PHY_UBOOT_BASE  MEMORY_BASE_ADDRESS + 0x7e00000 /*Uboot的物理地址0x57e00000*/

#ifdef CONFIG_ENABLE_MMU
#define CFG_UBOOT_BASE      0xc7e00000
#else
#define CFG_UBOOT_BASE      0x57e00000
#endif

#define CFG_ENV_OFFSET      0x00040000      /*Uboot中环境变量偏移地址*/
#define CFG_ENV_SIZE        0x20000         /* Total Size of Environment Sector */


/***********************************************Size of malloc() pool********************************/
#define CFG_MALLOC_LEN      (CFG_ENV_SIZE + 1024*1024)
#define CFG_GBL_DATA_SIZE   128 /* size in bytes reserved for initial data */

#define CFG_STACK_SIZE      512*1024

/****************************************NANDFlash宏定义*********************************************/
#define CFG_MAX_NAND_DEVICE     1
#define CFG_NAND_BASE           (0x70200010)
#define NAND_MAX_CHIPS          1

#define NAND_DISABLE_CE()   (NFCONT_REG |= (1 &lt;&lt; 1))
#define NAND_ENABLE_CE()    (NFCONT_REG &amp;= ~(1 &lt;&lt; 1))
#define NF_TRANSRnB()       do { while(!(NFSTAT_REG &amp; (1 &lt;&lt; 0))); } while(0)

#define CFG_NAND_SKIP_BAD_DOT_I 1  /* ".i" read skips bad blocks   */
#define CFG_NAND_WP     1
#define CFG_NAND_YAFFS_WRITE    1  /* support yaffs write */

#if defined(FRIENDLYARM_BOOT_MEDIA_NAND)    /*启动介质是NandFlash*/
#define CONFIG_BOOT_NAND
#elif defined(FRIENDLYARM_BOOT_MEDIA_SD)    /*启动介质是SD Card*/
#define CONFIG_BOOT_MOVINAND
#else
#error Boot media not defined
#endif

#define CONFIG_NAND
#define CONFIG_MOVINAND

#define CONFIG_MEMORY_UPPER_CODE            /*用户内存位于代码之上*/

#undef CONFIG_USE_IRQ                       /* Uboot中不使用IRQ/FIQ*/



/******************************************系统时钟宏定义*******************************************/
#define CONFIG_CLK_532_133_66               /*FIN=12MHz,Fout=532MHz*/
#define APLL_MDIV   266
#define APLL_PDIV   3
#define APLL_SDIV   1
#define CONFIG_SYNC_MODE
#define set_pll(mdiv, pdiv, sdiv)   (1&lt;&lt;31 | mdiv&lt;&lt;16 | pdiv&lt;&lt;8 | sdiv)
#define APLL_VAL    set_pll(APLL_MDIV, APLL_PDIV, APLL_SDIV)
#define Startup_APLL    (CONFIG_SYS_CLK_FREQ/(APLL_PDIV&lt;&lt;APLL_SDIV)*APLL_MDIV)

#define MPLL_MDIV   266                     /* fixed MPLL 533MHz */
#define MPLL_PDIV   3
#define MPLL_SDIV   1
#define MPLL_VAL    set_pll(MPLL_MDIV, MPLL_PDIV, MPLL_SDIV)
#define Startup_MPLL    ((CONFIG_SYS_CLK_FREQ)/(MPLL_PDIV&lt;&lt;MPLL_SDIV)*MPLL_MDIV)

#define Startup_APLLdiv     0
#define Startup_HCLKx2div   1
#define Startup_PCLKdiv     3
#define Startup_HCLKdiv     1
#define Startup_MPLLdiv     1

#define CLK_DIV_VAL ((Startup_PCLKdiv&lt;&lt;12)|(Startup_HCLKx2div&lt;&lt;9)|(Startup_HCLKdiv&lt;&lt;8)|(Startup_MPLLdiv&lt;&lt;4)|Startup_APLLdiv)

#if defined(CONFIG_SYNC_MODE)
#define Startup_HCLK    (Startup_APLL/(Startup_HCLKx2div+1)/(Startup_HCLKdiv+1))
#else
#define Startup_HCLK    (Startup_MPLL/(Startup_HCLKx2div+1)/(Startup_HCLKdiv+1))
#endif

#define CONFIG_CLKSRC_CLKUART
#define CONFIG_UART_66                      /*CLKUART=66.5MHz*/



/*****************************************DDR控制器宏定义*******************************************/
#if defined(FRIENDLYARM_BOOT_RAM256)
#define DMC1_MEM_CFG        ((1&lt;&lt;30) | (2&lt;&lt;15) | (3&lt;&lt;3) | (2&lt;&lt;0))   /*column address(10):A0~A9;row address(14):A0~A13;Burst Length =4*/
#define DMC1_CHIP0_CFG      0x150F0                                 /*Bank-Row-Column organization */
#define PHYS_SDRAM_1_SIZE   0x10000000 /* 256 MB */
#elif defined(FRIENDLYARM_BOOT_RAM128)
#define DMC1_MEM_CFG        ((1&lt;&lt;30) | (2&lt;&lt;15) | (2&lt;&lt;3)| (2&lt;&lt;0))
#define DMC1_CHIP0_CFG      0x150F8
#define PHYS_SDRAM_1_SIZE   0x8000000 /* 128 MB */
#else
#error RAM size must be defined
#endif

#define DMC1_MEM_CFG2       0xB41       /*Memory with=32,Mobile DDR SDRAM,Read delay 1 cycle*/
#define DMC_DDR_32_CFG      0x0         

/* DDR Parameters */
#define DDR_tREFRESH        7800        /* ns */
#define DDR_tRAS        45      /* ns (min: 45ns)*/
#define DDR_tRC         68      /* ns (min: 67.5ns)*/
#define DDR_tRCD        23      /* ns (min: 22.5ns)*/
#define DDR_tRFC        80      /* ns (min: 80ns)*/
#define DDR_tRP         23      /* ns (min: 22.5ns)*/
#define DDR_tRRD        15      /* ns (min: 15ns)*/
#define DDR_tWR         15      /* ns (min: 15ns)*/
#define DDR_tXSR        120     /* ns (min: 120ns)*/
#define DDR_CASL        3       /* CAS Latency 3 */

#define DMC_DDR_BA_EMRS     2
#define DMC_DDR_MEM_CASLAT  3
#define DMC_DDR_CAS_LATENCY (DDR_CASL&lt;&lt;1)                       //6   Set Cas Latency to 3
#define DMC_DDR_t_DQSS      1                           // Min 0.75 ~ 1.25
#define DMC_DDR_t_MRD       2                           //Min 2 tck
#define DMC_DDR_t_RAS       (((Startup_HCLK / 1000 * DDR_tRAS) - 1) / 1000000 + 1)  //7, Min 45ns
#define DMC_DDR_t_RC        (((Startup_HCLK / 1000 * DDR_tRC) - 1) / 1000000 + 1)   //10, Min 67.5ns
#define DMC_DDR_t_RCD       (((Startup_HCLK / 1000 * DDR_tRCD) - 1) / 1000000 + 1)  //4,5(TRM), Min 22.5ns
#define DMC_DDR_schedule_RCD    ((DMC_DDR_t_RCD - 3) &lt;&lt; 3)
#define DMC_DDR_t_RFC       (((Startup_HCLK / 1000 * DDR_tRFC) - 1) / 1000000 + 1)  //11,18(TRM) Min 80ns
#define DMC_DDR_schedule_RFC    ((DMC_DDR_t_RFC - 3) &lt;&lt; 5)
#define DMC_DDR_t_RP        (((Startup_HCLK / 1000 * DDR_tRP) - 1) / 1000000 + 1)   //4, 5(TRM) Min 22.5ns
#define DMC_DDR_schedule_RP ((DMC_DDR_t_RP - 3) &lt;&lt; 3)
#define DMC_DDR_t_RRD       (((Startup_HCLK / 1000 * DDR_tRRD) - 1) / 1000000 + 1)  //3, Min 15ns
#define DMC_DDR_t_WR        (((Startup_HCLK / 1000 * DDR_tWR) - 1) / 1000000 + 1)   //Min 15ns
#define DMC_DDR_t_WTR       2
#define DMC_DDR_t_XP        2                           //1tck + tIS(1.5ns)
#define DMC_DDR_t_XSR       (((Startup_HCLK / 1000 * DDR_tXSR) - 1) / 1000000 + 1)  //17, Min 120ns
#define DMC_DDR_t_ESR       DMC_DDR_t_XSR
#define DMC_DDR_REFRESH_PRD (((Startup_HCLK / 1000 * DDR_tREFRESH) - 1) / 1000000)  // TRM 2656
#define DMC_DDR_USER_CONFIG 1                           // 2b01 : mDDR

#define CONFIG_NR_DRAM_BANKS    1      /* we have 2 bank of DRAM */
#define PHYS_SDRAM_1        MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */

/***************************************************************************************************************/
#define CONFIG_DISPLAY_CPUINFO
#define CONFIG_DISPLAY_BOARDINFO

/************************************************DM9000*********************************************************/
#define CONFIG_DRIVER_DM9000    1
#define CONFIG_DRIVER_DM9000_NO_EEPROM  1
#define CONFIG_DM9000_USE_16BIT 1
#define CONFIG_DM9000_BASE  0x18000300
#define DM9000_IO CONFIG_DM9000_BASE
#define DM9000_DATA (CONFIG_DM9000_BASE+4)

/***************************************************************************************************************/
#define CONFIG_INCLUDE_TEST

#define CONFIG_ZIMAGE_BOOT
#define CONFIG_IMAGE_BOOT

#define BOARD_LATE_INIT

#define CONFIG_SETUP_MEMORY_TAGS
#define CONFIG_CMDLINE_TAG
#define CONFIG_INITRD_TAG

/******************************************************Shell*******************************************************/
#define CONFIG_SERIAL1          1           /* we use SERIAL 1 on SMDK6410 */
#define CFG_HUSH_PARSER                     /* use "hush" command parser    */

#ifdef CFG_HUSH_PARSER
#define CFG_PROMPT_HUSH_PS2 "&gt; "
#endif

/*******************************************************Command definition*****************************************/
#define CONFIG_COMMANDS \
                        (CONFIG_CMD_DFL | \
                        CFG_CMD_CACHE   | \
                        CFG_CMD_USB     | \
                        CFG_CMD_REGINFO | \
                        CFG_CMD_LOADS   | \
                        CFG_CMD_LOADB   | \
                        CFG_CMD_ENV     | \
                        CFG_CMD_NAND    | \
                        CFG_CMD_PING    | \
                        CFG_CMD_MOVINAND) \
                        &amp; ~(CFG_CMD_AUTOSCRIPT  | \
                                CFG_CMD_BOOTD   | \
                                CFG_CMD_IMI     | \
                                CFG_CMD_RUN     | \
                                CFG_CMD_CONSOLE | \
                                CFG_CMD_DOCG3P3 | \
                                CFG_CMD_EEPROM  | \
                                CFG_CMD_I2C     | \
                                0)

/*********************************************************************************************************************/
#include &lt;cmd_confdefs.h&gt;

#define CONFIG_BOOTDELAY    0
#define CONFIG_BOOTARGS     "root=/dev/mtdblock2 rootfstype=yaffs2 init=/linuxrc console=ttySAC0,115200"
#define CONFIG_ETHADDR      08:90:90:90:90:90
#define CONFIG_NETMASK          255.255.255.0
#define CONFIG_IPADDR       192.168.1.230
#define CONFIG_SERVERIP     192.168.1.88
#define CONFIG_GATEWAYIP    192.168.1.1
#define CONFIG_DEVICENUM    0

#define CONFIG_ZERO_BOOTDELAY_CHECK

/************************************************************************************************************************/
#define CFG_LONGHELP                /* undef to save memory     */
#define CFG_PROMPT      "iggsensor # "  /* Monitor Command Prompt   */
#define CFG_CBSIZE      256     /* Console I/O Buffer Size  */
#define CFG_PBSIZE      384     /* Print Buffer Size */
#define CFG_MAXARGS     16      /* max number of command args   */
#define CFG_BARGSIZE        CFG_CBSIZE  /* Boot Argument Buffer Size    */

/*************************************************************************************************************************/
#define MACH_TYPE       2520
#define UBOOT_MAGIC     (0x43090000 | MACH_TYPE)
</code></pre>
]]></content>
  </entry>
  
</feed>
