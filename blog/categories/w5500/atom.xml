<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: w5500 | WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/blog/categories/w5500/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-09-15T20:21:14+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[W5500-Introduce]]></title>
    <link href="http://suda-morris.github.io/blog/2015/08/17/w5500-introduce/"/>
    <updated>2015-08-17T09:50:48+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/08/17/w5500-introduce</id>
    <content type="html"><![CDATA[<h2>W5500网络模块简介</h2>

<ol>
<li>公司：Wiznet</li>
<li>使用硬件逻辑门电路实现TCP/IP协议栈的传输层及网络层（如：TCP，UDP，ICMP，IPv4，ARP，IGMP，PPPoE等协议），并集成了数据链路层，物理层(10BaseT/100BaseTX)，以及32K字节片上RAM作为数据收发缓存，使得上位机主控芯片只需承担TCP/IP应用层控制信息的处理任务，大大节省了上位机对于数据复制、协议处理和中断处理等方面的工作量，提升了系统利用率及可靠性</li>
<li>操作过程中，用户可以近似将W5500作为MCU的一个外设RAM来使用，非常简易。W5500对外接口通常为通用的80MHz高速SPI</li>
<li>W5500支持同时的8个socket，方便和不同的IP和设备进行通讯；为了减小系统能耗，W5500提供了网络环形模式(WOL)以及掉电模式供客户选择使用；W5500是非可攻击性的硬件网络引擎，可以防止类似于洪流，诈骗式以及注入式网络攻击，提高了网络安全</li>
<li>支自动协商(10/100-Based全双工/半双工)</li>
<li>3.3V工作电压，I/O信号口5V耐压</li>
<li>W5500 不支持Auto-MDI-X，也就是不支持交叉直连自动切换，对于某些比较老的设备，可能需要特定的交叉线或者直连线。比如模块连模块，需要使用交叉线，模块连路由器或者交换机需要使用直连线。</li>
<li>W5500不支持自动极性变换功能，因此用户需要使用直连线与交换机或者路由器连接，使用交叉线与终端设备(如服务器，工作站或者其他W5500)相连接。然而用户可以使用任何一种类型的网线与具有自动极性变换的其他设备相连。</li>
<li>W5500以太网芯片的内核由传输层的TCP、UDP、ICMP、IGMP等协议、网络层的IP、ARP、PPPoE等协议以及链路层的MAC构成，再加上物理层的PHY和外围的寄存器、内存、SPI接口组成了这一整套硬件化的以太网解决方案</li>
<li>SPI时钟设定值速率为80MHz，但是高速信号在受电磁串扰和长信号线的影响下可能会失真，实测具有稳定波形的始终速率为33.3MHz</li>
</ol>


<h2>W5500初始化主要使用的几个文件：</h2>

<ol>
<li>W5500_conf.c->主要配置W5500的MAC、IP地址，W5500基本的数据读写过程，复位设置函数等</li>
<li>Socket.c->主要介绍了W5500的SOCKET相关配置函数，比如SOCKET的打开、关闭以及接收数据、发送数据等等</li>
<li>Utility.c->主要介绍了基本的延时函数，还有数据格式转化函数</li>
<li>w5500.c->主要介绍W5500的寄存器读写过程</li>
</ol>


<h2>W5500的Socket初始化</h2>

<ol>
<li>W5500的操作需要设置一下寄存器的参数：

<ol>
<li>模式寄存器(MR)</li>
<li>中断屏蔽寄存器(IMR)</li>
<li>重发时间寄存器(RTR)</li>
<li>重发计数寄存器(RCR)</li>
</ol>
</li>
<li>设置网络信息，下面的寄存器是关于网络的基本设置，需要根据网络环境来进行设置

<ol>
<li>网关地址寄存器(GAR)</li>
<li>本机物理地址寄存器(SHAR)</li>
<li>子网掩码寄存器(SUBR)</li>
<li>本机IP地址寄存器(SIPR)</li>
</ol>
</li>
<li>设置端口存储信息，这一步设置端口TX/RX存储信息，每个端口的基地址和屏蔽地址在这里确定并保存。

<ol>
<li>W5500有一个通用寄存器，8个Socket寄存器区，以及对应每个Socket的收发缓存区。每一个Socket的发送缓存区都在一个16KB的物理接收内存中，初始化分配为2KB。无论给每个Socket分配多达的收发缓存，都必须在16为的偏移地址范围内(0x0000~0xFFFF).16KB的发送内存初始化被分配为每个SOcket 2KB发送缓存区(2KB*8=16KB)。</li>
<li>初始化分配的2KB Socket发送缓存，可以通过使用Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)重新分配，一旦所有的Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)配置完成，16KB的发送内存就会按照配置分配给每个Socket的发送缓存，并按照从Socket0到7顺序分配。16KB物理内存的地址是可以自增的，但是为了避免数据传输错误，需要避免发送缓存大小寄存器(Sn_TXBUF_SIZE)的和超过16</li>
<li>16KB的发送内存中分配了对应Socket n的发送缓存区，用于为来自主机传输的数据做缓存。Socket n发送缓存区的16位偏移地址支持64KB的寻址范围(从0x0000到0xFFFF)</li>
</ol>
</li>
</ol>


<h2>SPI工作协议</h2>

<ol>
<li>SPI协议定义了四种工作模式(模式0，1，2，3)。每种模式的区别是根据SCLK的极性及相位不同定义的。SPI的模式0和模式3唯一不同的就是在非活动状态下，SCLK信号的极性，SPI模式0在时钟空闲状态时钟极性为低电平。SPI的模式0和3，数据都是在SCLK的上升沿锁存，在下降沿输出。W5500支持SPI模式0以及模式3，MISO和MOSI信号无论是接收或者发送，均遵从从最高标志位(MSB)到最低标志位(LSB)的传输序列。</li>
<li>W5500与外设主机的通讯受SPI数据帧控制，W5500的帧分为3段：地址段，控制段，数据段</li>
<li>地址段为W5500寄存器或者TX/RX内存指定的16位的偏移地址。</li>
<li>控制段指定了地址段设定的偏移区域的归属，读写访问模式以及SPI工作模式(可变长度模式/固定长度模式)</li>
<li>数据段可以设定为任意长度(N字节)或者是固定长度：1字节，2字节或4字节；如果SPI工作模式设置为可变数据长度模式(VDM),SPI的SCSn信号需要由外部主机通过SPI帧控制。</li>
<li>在可变长度模式下，SCSn控制SPI帧的开始和停止：

<ol>
<li>SCSn信号拉低，即代表W5500的SPI帧开始(地址段)</li>
<li>SCSn信号拉低，即代表W5500的SPI帧结束(数据段的随机N字节数据结尾)</li>
</ol>
</li>
<li>W5500的SPI数据帧包括了16为地址段的偏移地址，8为控制段和N字节数据段。8为控制段可以通过修改区域选择位(BSB[4:0]),读写访问模式位(RWB)以及SPI工作模式位(OM[1:0])来重新定义。区域选择位选择了归属于偏移地址的区域</li>
<li>W5500支持数据的连续读写。其流程为数据从(2/4/N字节连续数据的)偏移地址的基址开始传输，偏移地址会自增寻址(加1)传输接下来的数据</li>
<li>SPI数据帧控制段对应位的说明：

<ol>
<li>区域选择位BSB[4:0]-> 【00000】= 通用寄存器；【00001】= Socket0寄存器；【00010】=Socket0发送缓存；【00011】=Socket0接收缓存；【00101】=Socket1寄存器；【00110】=Socket1发送缓存；【00111】=Socket1接收缓存；【01001】= Socket2寄存器；【01010】=Socket2发送缓存；【01011】=Socket2接收缓存；【10101】=Socket3寄存器；【01110】=Socket3发送缓存；【01111】=Socket3接收缓存；【10001】= Socket4寄存器；【10010】=Socket4发送缓存；【10011】=Socket4接收缓存；【10101】=Socket5寄存器；【10110】=Socket5发送缓存；【10111】=Socket5接收缓存；【11001】= Socket6寄存器；【11010】=Socket6发送缓存；【11011】=Socket6接收缓存；【11101】=Socket7寄存器；【11110】=Socket7发送缓存；【11111】=Socket7接收缓存；</li>
<li>读写访问模式位RWB-> 【0】=读；【1】=写</li>
<li>工作模式位OM[1:0]-> 【00】=可变数据长度模式，N字节数据段(1≤N)；【01】=固定数据长度模式，1字节数据长度(N=1)；【10】=固定数据长度模式，2字节数据长度(N=2)；【11】=固定数据长度模式，4字节数据长度(N=4)；</li>
</ol>
</li>
<li>W5500有一个通用寄存器，8个Socket寄存器，以及对应每个Socket的收发缓存区。每个区域均通过SPI数据帧的区域选择位BSB[4:0]来选取。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212635.png" alt="SPI模式0/3" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212850.png" alt="SPI数据帧" /></li>
</ol>


<h2>物理层</h2>

<blockquote><p>由计算机和网络介质之间的实际界面组成，可定义电器信号、符号、线的状态和时钟要求、数据编码和数据传输用的连接器。如最常用的RS-232规范、10BASE-T的曼彻斯特编码以及RJ-45就属于这一层。</p></blockquote>

<h2>数据链路层</h2>

<blockquote><ol>
<li>数据链路层通过物理网络链路提供可靠的数据传输。不同的数据链路层定义了不同的网络和协议特征，其中包括物理编址、网络拓扑结构、错误校验、帧序列以及流控</li>
<li>以太网协议规定，一组电信号构成一个数据包，叫做“帧”，每一帧分成三个部分：以太网首部、数据及以太网尾部。</li>
<li>以太网首部包含数据帧的一些说明，比如发送者、接收者、数据类型等等；数据部分则是数据的具体内容；以太网尾部则是CRC校验码</li>
<li>以太网首部的长度固定为14字节。数据的长度最短为46字节，最长为1500字节。以太网尾部的长度固定为4字节。因此，整个数据帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送</li>
<li>数据链路层实际上由两个独立的部分组成：介质存取控制(MAC)和逻辑链路控制(LLC)。MAC描述在共享介质环境中如何进行站的调度、发生和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据流向。一般来讲，MAC只在共享介质环境中才是重要的，只有在共享介质环境中多个节点才能连接到同一传输介质上。</li>
<li>一块网卡如何知道另一块网卡的MAC地址?ARP协议(网络层)可以解决这个问题。以太网数据帧必须知道接收方的MAC地址然后才能发送。有了数据帧的定义，网卡的MAC地址，广播的发送方式，数据链路层就可以在多台计算机之间传送数据了</li>
</ol>
</blockquote>

<h2>网络层</h2>

<blockquote><ol>
<li>网络层负责在源和终点之间建立连接。它一般包括网络寻址，还可能包括流量控制、错误检查等。相同MAC标准的不同网段之间的数据传输一般只涉及到数据链路层，而不同的MAC标准之间的数据传输都涉及到网络层。IP路由器工作在网络层，因为可以实现多种网络间的互联。</li>
<li>IP数据包分为“标头”和“数据”两个部分。标头部分主要包括版本、长度、IP地址等细心，数据部分则是IP数据报的具体内容。IP数据报的标头部分长度为20到60字节，整个数据报的总长度最大为65535字节，因此理论上，一个数据报的数据部分最长为65515字节。以太网数据帧的数据部分最长只有1500字节，因此如果IP数据报超过了1500字节，它就要分割成几个以太网数据帧分开发送了。</li>
</ol>
</blockquote>

<h2>传输层</h2>

<blockquote><ol>
<li>传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能一般包括流控、多路传输、虚电路管路以及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接受设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到物理链路上；虚电路由传输层建立、维护和终止；差错校验包括为检测传输错误而建立的各种不同结构；而差错回复包括所采取的行动，以便解决发生的任何错误。</li>
<li>必须要在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，UDP数据段也是有“标头”和“数据”两部分组成</li>
<li>标头部分主要定义了发出端口和接收端口，“数据”部分就是具体的内容，然后把整个UDP数据段放入IP数据报的“数据”部分，而IP数据报又是放在以太网数据帧之中的。</li>
<li>UDP数据段非常简单，标头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据报</li>
<li>为了提高网络可靠性，诞生了TCP协议，这个协议非常复杂，但可以近似认为，他就是有确认机制的UDP协议，没发出一个数据都要求确认。如果有一个数据缺失，就收不到确认，发送方就知道有必要重发这个数据了</li>
<li>TCP数据段没有长度限制，理论上可以无限长，但是为了保证网络的效率。通常TCP数据段的长度不会超过IP数据报的长度，以确保单个TCP数据段不必再分割。</li>
</ol>
</blockquote>

<h2>应用层</h2>

<blockquote><p>应用层是最接近终端用户的第一层，这就意味着应用层与用户之间是通过应用软件直接相互作用。应用层并非由计算机上云sing的实际应用软件组成，而是由向应用程序提供访问网络资源的API组成。</p></blockquote>

<h2>寄存器</h2>

<h3>W5500通用寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823140450.png" alt="W5500通用寄存器" /></p>

<h3>Socket寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823141841.png" alt="Socket寄存器" /></p>

<ol>
<li>通用寄存器区配置了W5500的基本信息，如IP以及MAC地址</li>
<li>W5500支持8个Socket作为通讯信道，每一个Socket通过Socket n寄存器控制。Socket n寄存器可以通过SPI数据帧中的区域选择寄存器BSB[4:0]来选定对应的寄存器n。</li>
</ol>


<h2>TCP/IP协议族</h2>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgW5500%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95%E6%9D%BF%E6%95%99%E7%A8%8B.png" alt="TCP/IP协议族" /></p>

<h2>TCP协议</h2>

<ol>
<li>TCP协议通过三个报文段完成连接的建立，这个过程称为三次握手。TCP连接建立过程：

<ol>
<li>第一次握手：建立连接时，客户端发送SYN包(seq=j)到服务器，并进入SYN_SEND状态，等待服务器确认</li>
<li>第二次握手：服务器收到SYN包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(seq=k),即SYN+ACK包，此时服务器进入SYN_RECV状态</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISH状态，完成三次握手</li>
</ol>
</li>
<li>终止一个TCP连接需要四次挥手，这是由TCP的半关闭(half-close)造成的

<ol>
<li>第一次挥手：主动方发出设置了FIN位的报文，表示主动终止从本地到远端的单向链接；此时主动方进入FIN_WAIT1状态，意思是它在等待远端的FIN报文</li>
<li>第二次挥手：远端收到FIN后，会立即发送ACK；主动方收到ACK后，进入FIN_WAIT2状态，所以FIN_WAIT1状态持续的时间非常短；此时远端进入CLOSE-WAIT状态，一条单向链接终止了，但另一条还没有，处于HALF-CLOSE连接状态</li>
<li>第三次挥手：当远端进行了必要的数据发送后，它发送FIN，表示它出发的单向连接也要关闭，同时它进入LAST_ACK状态</li>
<li>第四次挥手：主动方收到FIN后，回应一个ACK；远端就此进入CLOSED状态，连接关闭；主动方进入TIME WAIT状态，确保最后一个ACK没有丢失，防止新连接占用刚刚关闭的主动方的地址端口，使得网络中流浪的老连接的返祖被误认为新连接的分组</li>
</ol>
</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手/四次挥手" /></li>
<li>当W5500初始化完成后，程序进入主循环，此时读取Socket的状态值，并选择进入哪种模式。当Socket处于关闭状态时，在进行通信之前，我们先将该Socket初始化，这个Socket作为服务器端，端口号要固定为侦听的端口。当socket将处于初始化完成状态，即SOCK_INIT状态，此时，作为TCP服务器就要执行listen()函数来侦听端口。由于W5500内嵌了TCP/IP协议，连接过程是不需要单片机干预的。如果连接过程中出错造成超时，该Socket将会被关闭，重新进入SOCK_CLOSE状态。待TCP连接的3次握手完成后，socket的状态将会转变为连接建立状态，即代码中定义的SOCK_ESTABLISHED状态。在进入SOCK_ESTABLISHED状态后，便可进行数据收发。数据通信完毕之后执行disconnect()函数，在收到对方FIN数据包之前，该socket将进入SOCK_CLOSE_WAIT状态。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPServer%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPServer流程图" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPClient%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPClient流程图" /></li>
</ol>


<h2>UDP协议</h2>

<ol>
<li><img src="http://i.imgur.com/ceIUeSz.png" alt="UDP通信流程图" /></li>
<li>当socket处于关闭状态时，在进行通信之前我们先将该UDP模式的socket端口初始化。当socket将处于初始化完成状态即SOCK_UDP状态，此时就可以通过广播方式发送数据了。</li>
<li><img src="http://i.imgur.com/FxqWkWp.png" alt="UDP报文" /></li>
</ol>


<h2>DHCP协议</h2>

<ol>
<li>W5500作为DHCP客户端，路由器作为DHCP服务器端，在DHCP请求的过程中，包括4个主要阶段：发现阶段、提供阶段、选择阶段以及确认阶段</li>
<li>首次W5500客户端发送DHCPDISCOVER消息(IP地址租用申请)，这个消息通过广播方式发出，所有网络中的DHCP服务器都将接收到这个消息。随后，网络中的DHCP服务器会回应一个DHCPOFFER消息(IP地址租用提供)，由于这个时候客户端还没有网络地址，所以DHCPOFFER也是通过广播的方式发送出去的。然后，向该服务器发送DHCPREQUEST消息。在DHCPREQUEST消息中将包含客户端申请的IP地址。最后，DHCP服务器将会送DHCPACK的相应消息来通知客户端可以使用该IP地址，该确认里面包含了分配的IP地址和该地址的一个稳定期限的租约(默认是8天)，并同时更新DHCP数据库</li>
<li>DHCP初始化完成以后，通过获取DHCP_SOCKET的状态来获取动态IP地址。第一个状态DHCP_RET_NONE就是获取不成功，第二个状态DHCP_RET_TIMEOUT是获取IP地址超时，都不符合条件。第三个状态DHCP_RET_UPDATE就是获取动态IP地址成功，此时将得到的IP地址通过SPI写入W5500的寄存器。如果是DHCP_RET_CONFLICT冲突状态，就要返回DHCP服务重新获取</li>
<li><img src="http://i.imgur.com/sqc1tce.jpg" alt="DHCP报文格式" /></li>
<li>报文格式解析：

<ol>
<li>OP：若是client送给server的封包，设为1，反之为2</li>
<li>HTYPE：硬件类别，10MB以太网为1，100MB以太网为2</li>
<li>HLEN：硬件地址长度，Ethernet为6</li>
<li>HOPS：若封包需要经过router传送，每站加1，若在同一网段内，为0</li>
<li>TRANSACTION ID：DHCP REQUEST时产生的数值，以作为DHCPREPLY时的依据</li>
<li>SECONDS：Client端启动时间(秒)</li>
<li>FLAGS：从0到15共16bits，最左1bit为1时表示server将以广播方式传送封包给client，其余尚未使用</li>
<li>ciaddr：yhaoshiclient端想继续使用之前取得的IP地址，则列于这里</li>
<li>yiaddr：从server送回client的DHCP OFFER与DHCPACK封包中，此栏填写分配给client的IP地址</li>
<li>siaddr：若client需要透过网络开机，从server送出的DHCP OFFER、DHCPACK、DHCPNACK封包中，此栏填写开机程序代码所在server的地址</li>
<li>giaddr：若需跨网域进行DHCP发放，此栏为relay agent的地址，否则为0</li>
<li>chaddr：client的硬件地址</li>
<li>sname：sever的名称字符串，以0x00结尾</li>
<li>file：若client需要透过网络开机，此栏将指出开机程序名称，稍后以TFTP传送</li>
<li>options：允许厂商定义选项，提供更多的设定信息，其长度可变，同时可携带多个选项，每一个选项的第一个字节为信息代码，其后一个自己为该项数据长度，最后为项目内容</li>
</ol>
</li>
</ol>


<h2>DNS协议</h2>

<ol>
<li>客户端初始化完毕之后，如果DNS运行标志位是1或者DNS发送次数超过3次就直接返回。如果不是上面的情况，并且DNS Server的IP不是0.0.0.0时，进入switch函数。当处于DNS域名解析成功状态时，DNS_OK置1，发送请求报文次数置0。当DNS解析域名失败时，标志位置0，请求报文次数加1，然后跳出循环。</li>
</ol>


<h2>SMTP协议</h2>

<ol>
<li><img src="http://i.imgur.com/9TsOlUJ.png" alt="邮件发送过程示意图" /></li>
<li>SMTP在TCP协议25号端口监听连续请求。SMTP连接和发送过程：

<ol>
<li>建立TCP连接</li>
<li>客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端正希望以OK作为相应，表明准备接收</li>
<li>客户端发送RCPT命令，以表示该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件</li>
<li>协商结束，发送邮件，用命令DATA发送</li>
<li>以“.”号表示结束并将内容一起发出去，结束此次发送，用QUIT命令退出</li>
</ol>
</li>
</ol>


<h2>ICMP协议</h2>

<ol>
<li>ICMP是Internet控制报文协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令，这个ping的过程实际上就是ICMP协议工作的过程。Ping命令利用ICMP回射请求报文和回射应答报文来测试目标系统是否可达。</li>
<li>执行ping后，首先向目标服务器发出回送请求报文。计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求。这个ICMP回送回答报文在IP层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP地址字段被交换了，类型字段里填入了表示回送回答的0，这两点，也就是，从送信方式来看，自己送出的ICMP报文从目标服务器哪里像鹦鹉学舌那样原样返回了</li>
</ol>


<h2>NetBIOS</h2>

<p><img src="http://i.imgur.com/OAHwfCG.png" alt="NetBIOS实现过程" /></p>

<ol>
<li>NetBIOS协议是一种在局域网上的程序可以使用的应用程序编程接口，为v横须提供了请求低级服务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能，几乎所有的局域网都是在NetBIOS协议的基础上工作的。NetBIOS协议，简单来说就是通过访问设备名称就可以实现对IP地址的访问。</li>
<li>在Windows操作系统中，默认情况下在安装TCP/IP协议后会自动安装NetBIOS协议。</li>
<li>ping主机名的第一个数据包就是NBNS(NetBIOS Name Server)协议包，它是TCP/IP上的NetBIOS协议族的一部分，它在基于NetBIOS名称访问的网络上提供主机名和地址映射方法。NBNS是动态DNS的一种。Microsoft的NBNS实现称为WINS。NetBIOS的报文类型较多，结构复杂，在不同的网络化境和不同的用途中会使用不同的报文，可用端口进行区分。如图所示NetBIOS协议架构
<img src="http://i.imgur.com/MxZkqby.jpg" alt="NetBIOS协议架构" /></li>
<li>NetBIOS数据报有很多不同格式，主要取决于服务和信息类型，以及用以传送NetBIOS数据报的传输协议。NetBIOS协议架构包含三种基本服务：NAME、SESSION和DATAGRAM，其中NAME所用协议就是NBNS协议</li>
<li>WINS协议使用的报文即为NetBIOS的名字报文，其总体格式如下图所示
<img src="http://i.imgur.com/i2pWvfO.png" alt="NetBIOS名字报文格式" />其中2字节通用标志中更详细的字段划分为：操作代码(5bits)操作标志(7bits)结果代码(4bits)

<ol>
<li>事物ID：请求方为每次名字服务请求所设定的ID值，响应方在相应的响应报文中要填入这个事物ID值</li>
<li>操作代码：指示报文的类型,最高位为0表示数据包为Reauest请求，最高位为1表示数据包为Response应答，其余4个比特均为0</li>
<li>操作标志：操作标志位，最低位为1表示广播或者多播，最低位为0表示单播，其他位均为0</li>
<li>结果代码：在相应报文中指示请求的结果，一般为0</li>
<li>问题记录个数：请求查询问题的个数，对于Request数据包，该值为1，对于Response数据包，该值为0</li>
<li>回答记录个数：对于Response数据包有用，Response数据包中响应问题的个数，一般为1</li>
<li>权威记录个数：在权威记录部分的记录数量，用不到的时候为0</li>
<li>附加记录个数：在附加记录部分数量，用不到的时候为0</li>
</ol>
</li>
<li>报文的前12字节总称NetBIOS名字报文的首部，通过首部可以判断是否为名字查询的报文。NetBIOS名字报文中最常见的是携带问题记录的报文，问题记录的格式是：问题名称(若干字节) 问题类型(2字节) 问题类别(2字节)。通过携带问题记录的报文，我们可以得到要查询的名字字符，如果和本机名相符，就发送报文响应，相应中带有IP地址，发送广播的主机就会得到该IP地址</li>
<li>NETBIOS会话报文具有通用的4字节首部和与类型相关的报文内容：类型(1字节) 标志(1字节) 长度(2字节) 内容(若干字节)

<ol>
<li>类型：指名NetBIOS会话报文的类型，可用的值有：

<ul>
<li>0x00:会话消息</li>
<li>0x81:会话请求</li>
<li>0x82:正面会话响应</li>
<li>0x83:负面会话响应</li>
<li>0x84:重定向会话响应</li>
<li>0x85:会话保活</li>
</ul>
</li>
<li>标志：0~6位保留未用，第7位作为扩展的长度位，使NetBIOS会话报文的内容部分最多可以达到128K字节</li>
<li>长度：NetBIOS会话报文的内容部分的长度，不包括首部的4字节</li>
</ol>
</li>
<li><img src="http://i.imgur.com/O24egoi.png" alt="NBNS" />计算机1向计算机2的137端口发送一个NODE STATUS REQUEST请求数据包，计算机2收到该数据包后，向计算机1返回一个NODE STATUS RESPONSE响应数据包，该数据包中包含计算机2的MAC地址、机器地址、所属的工作组等信息</li>
<li>NODE STATUS REQUEST数据包由12字节的HEADER域和38字节的QUESTION ENTRIES域两个部分组成，HEADER域分为8个字段：
<img src="http://i.imgur.com/VKpTVaA.png" alt="NetBIOS HEADER" /></li>
<li>QUESTION ENTRIES域组成
<img src="http://i.imgur.com/93RGC0D.png" alt="QUESTION ENTRIES" />其中：

<ul>
<li>QUESTION_NAME为要查询的远程计算机的名称，长度为34字节。NBNS规定，计算机NetBIOS的名称不超过16字节，且最后一个字节必须为0x0；</li>
<li>QUESTION_TYPE对于REQUEST数据包取值为0x0021</li>
<li>QUESTION_CLASS取值为0x0001</li>
</ul>
</li>
<li>当某台机器的137端口收到NODE STATUS REQUEST请求数据包之后，由该机器的NETBIOS服务随即生成并返回一个NODE STATUS RESPONSE响应数据包。该响应数据包由HEADER域和RESOURCE RECORD域两部分组成。RESOURCE RECORD域组成如图所示：
<img src="http://i.imgur.com/IPEjagx.png" alt="RESOURCE RECORD" /></li>
</ol>


<h2>NTP协议</h2>

<ol>
<li>NTP是网络时间协议，是用来使设备时间同步化的一种协议，在一些应用长河里，时间同步时十分重要的，贴别是随着设备运行时间增长，时间误差就越来越大，因为设备中晶振自身会产生误差，那么NTP协议就可以解决这个问题。</li>
</ol>

]]></content>
  </entry>
  
</feed>
