<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: u-boot | WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/blog/categories/u-boot/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-06-21T11:23:11+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[board.c]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/20/board-dot-c/"/>
    <updated>2015-06-20T15:23:31+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/20/board-dot-c</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;common.h&gt;
#include &lt;command.h&gt;
#include &lt;malloc.h&gt;
#include &lt;devices.h&gt;
#include &lt;version.h&gt;
#include &lt;net.h&gt;
#include &lt;asm/io.h&gt;

#if defined(CONFIG_BOOT_MOVINAND)
#include &lt;movi.h&gt;
#endif

#ifdef CONFIG_DRIVER_SMC91111
#include "../drivers/smc91111.h"
#endif
#ifdef CONFIG_DRIVER_LAN91C96
#include "../drivers/lan91c96.h"
#endif

/* Note: volatile register variable is *NOT* volatile in gcc 4.5.1+ */
#if 0
DECLARE_GLOBAL_DATA_PTR;
#else
gd_t *gd;
#endif

#if (CONFIG_COMMANDS &amp; CFG_CMD_NAND)
void nand_init (void);
#endif

#ifdef CONFIG_ONENAND
void onenand_init(void);
#endif

ulong monitor_flash_len;

#ifdef CONFIG_HAS_DATAFLASH
extern int  AT91F_DataflashInit(void);
extern void dataflash_print_info(void);
#endif

#ifndef CONFIG_IDENT_STRING
#define CONFIG_IDENT_STRING ""
#endif

const char version_string[] =
    "   kdm ver1.01" CONFIG_IDENT_STRING;

#ifdef CONFIG_DRIVER_CS8900
extern void cs8900_get_enetaddr (uchar * addr);
#endif

#ifdef CONFIG_DRIVER_RTL8019
extern void rtl8019_get_enetaddr (uchar * addr);
#endif

/*
 * Begin and End of memory area for malloc(), and current "brk"
 */
static ulong mem_malloc_start = 0;
static ulong mem_malloc_end = 0;
static ulong mem_malloc_brk = 0;

static
void mem_malloc_init (ulong dest_addr)
{
    mem_malloc_start = dest_addr;
    mem_malloc_end = dest_addr + CFG_MALLOC_LEN;
    mem_malloc_brk = mem_malloc_start;

    /* memset ((void *) mem_malloc_start, 0,
            mem_malloc_end - mem_malloc_start); */
}

void *sbrk (ptrdiff_t increment)
{
    ulong old = mem_malloc_brk;
    ulong new = old + increment;

    if ((new &lt; mem_malloc_start) || (new &gt; mem_malloc_end)) {
        return (NULL);
    }
    mem_malloc_brk = new;

    return ((void *) old);
}

/************************************************************************
 * Init Utilities                           *
 ************************************************************************
 * Some of this code should be moved into the core functions,
 * or dropped completely,
 * but let's get it working (again) first...
 */

static int init_baudrate (void)
{
    char tmp[64];   /* long enough for environment variables */
    int i = getenv_r ("baudrate", tmp, sizeof (tmp));
    gd-&gt;bd-&gt;bi_baudrate = gd-&gt;baudrate = (i &gt; 0)
            ? (int) simple_strtoul (tmp, NULL, 10)
            : CONFIG_BAUDRATE;

    return (0);
}

static int display_banner (void)
{
    printf ("\n\n%s\n\n", version_string);
    debug ("U-Boot code: %08lX -&gt; %08lX  BSS: -&gt; %08lX\n",
           _armboot_start, _bss_start, _bss_end);
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
    debug("\t\bMalloc and Stack is above the U-Boot Code.\n");
#else
    debug("\t\bMalloc and Stack is below the U-Boot Code.\n");
#endif
#ifdef CONFIG_MODEM_SUPPORT
    debug ("Modem Support enabled\n");
#endif
#ifdef CONFIG_USE_IRQ
    debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
    debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

    return (0);
}

/*
 * WARNING: this code looks "cleaner" than the PowerPC version, but
 * has the disadvantage that you either get nothing, or everything.
 * On PowerPC, you might see "DRAM: " before the system hangs - which
 * gives a simple yet clear indication which part of the
 * initialization if failing.
 */
static int display_dram_config (void)
{
    int i;

#ifdef DEBUG
    puts ("RAM Configuration:\n");

    for(i=0; i&lt;CONFIG_NR_DRAM_BANKS; i++) {
        printf ("Bank #%d: %08lx ", i, gd-&gt;bd-&gt;bi_dram[i].start);
        print_size (gd-&gt;bd-&gt;bi_dram[i].size, "\n");
    }
#else
    ulong size = 0;

    for (i=0; i&lt;CONFIG_NR_DRAM_BANKS; i++) {
        size += gd-&gt;bd-&gt;bi_dram[i].size;
    }

    puts("DRAM:    ");
    print_size(size, "\n");
#endif

    return (0);
}

#ifndef CFG_NO_FLASH
static void display_flash_config (ulong size)
{
    puts ("Flash:  ");
    print_size (size, "\n");
}
#endif /* CFG_NO_FLASH */


/*
 * Breathe some life into the board...
 *
 * Initialize a serial port as console, and carry out some hardware
 * tests.
 *
 * The first part of initialization is running from Flash memory;
 * its main purpose is to initialize the RAM so that we
 * can relocate the monitor code to RAM.
 */

/*
 * All attempts to come up with a "common" initialization sequence
 * that works for all boards and architectures failed: some of the
 * requirements are just _too_ different. To get rid of the resulting
 * mess of board dependent #ifdef'ed code we now make the whole
 * initialization sequence configurable to the user.
 *
 * The requirements for any new initalization function is simple: it
 * receives a pointer to the "global data" structure as it's only
 * argument, and returns an integer return code, where 0 means
 * "continue" and != 0 means "fatal error, hang the system".
 */
typedef int (init_fnc_t) (void);

int print_cpuinfo (void); /* test-only */

init_fnc_t *init_sequence[] = {
    cpu_init,       /* basic cpu dependent setup */
    board_init,     /* basic board dependent setup */
    interrupt_init,     /* set up exceptions */
    env_init,       /* initialize environment */
    init_baudrate,      /* initialze baudrate settings */
    serial_init,        /* serial communications setup */
    console_init_f,     /* stage 1 init of console */
    display_banner,     /* say that we are here */
#if defined(CONFIG_DISPLAY_CPUINFO)
    print_cpuinfo,      /* display cpu info (and speed) */
#endif
#if defined(CONFIG_DISPLAY_BOARDINFO)
    checkboard,     /* display board info */
#endif
    dram_init,      /* configure available RAM banks */
    display_dram_config,
    NULL,
};

void start_armboot (void)
{
    init_fnc_t **init_fnc_ptr;
    char *s;
#ifndef CFG_NO_FLASH
    ulong size;
#endif

#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
    unsigned long addr;
#endif

#if defined(CONFIG_BOOT_MOVINAND)
    uint *magic = (uint *) (PHYS_SDRAM_1);
#endif

    /* Pointer is writable since we allocated a register for it */
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
    ulong gd_base;

    gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t);
#ifdef CONFIG_USE_IRQ
    gd_base -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
#endif
    gd = (gd_t*)gd_base;
#else
    gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
#endif

    /* compiler optimization barrier needed for GCC &gt;= 3.4 */
    __asm__ __volatile__("": : :"memory");

    memset ((void*)gd, 0, sizeof (gd_t));
    gd-&gt;bd = (bd_t*)((char*)gd - sizeof(bd_t));
    memset (gd-&gt;bd, 0, sizeof (bd_t));

    monitor_flash_len = _bss_start - _armboot_start;

    for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
        if ((*init_fnc_ptr)() != 0) {
            hang ();
        }
    }

#ifndef CFG_NO_FLASH
    /* configure available FLASH banks */
    size = flash_init ();
    display_flash_config (size);
#endif /* CFG_NO_FLASH */

#ifdef CONFIG_VFD
#   ifndef PAGE_SIZE
#     define PAGE_SIZE 4096
#   endif
    /*
     * reserve memory for VFD display (always full pages)
     */
    /* bss_end is defined in the board-specific linker script */
    addr = (_bss_end + (PAGE_SIZE - 1)) &amp; ~(PAGE_SIZE - 1);
    size = vfd_setmem (addr);
    gd-&gt;fb_base = addr;
#endif /* CONFIG_VFD */

#ifdef CONFIG_LCD
#   ifndef PAGE_SIZE
#     define PAGE_SIZE 4096
#   endif
    /*
     * reserve memory for LCD display (always full pages)
     */
    /* bss_end is defined in the board-specific linker script */
    addr = (_bss_end + (PAGE_SIZE - 1)) &amp; ~(PAGE_SIZE - 1);
    size = lcd_setmem (addr);
    gd-&gt;fb_base = addr;
#endif /* CONFIG_LCD */

    /* armboot_start is defined in the board-specific linker script */
#ifdef CONFIG_MEMORY_UPPER_CODE /* by scsuh */
    mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);
#else
    mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
#endif

#if defined(CONFIG_SMDK6400) || defined(CONFIG_SMDK6410) || defined(CONFIG_SMDK6430) || defined(CONFIG_SMDK2450) || defined(CONFIG_SMDK2416) || \
defined(CONFIG_MINI6410)

#if defined(CONFIG_NAND)
    puts ("NAND:    ");
    nand_init();        /* go init the NAND */
    NAND_Init();
#endif

#if defined(CONFIG_ONENAND)
    puts ("OneNAND: ");
    onenand_init();     /* go init the One-NAND */
#endif

#if defined(CONFIG_BOOT_MOVINAND)
    puts ("MMC:     ");

    if ((0x24564236 == magic[0]) &amp;&amp; (0x20764316 == magic[1])) {
        printf("Boot up for burning\n");
    } else {
        movi_set_capacity();
        movi_set_ofs(MOVI_TOTAL_BLKCNT);
        movi_init();
    }
#endif

#else

#if (CONFIG_COMMANDS &amp; CFG_CMD_NAND)
    puts ("NAND:    ");
    nand_init();        /* go init the NAND */
#endif

#endif

#ifdef CONFIG_HAS_DATAFLASH
    AT91F_DataflashInit();
    dataflash_print_info();
#endif

    /* initialize environment */
    env_relocate ();

#ifdef CONFIG_VFD
    /* must do this after the framebuffer is allocated */
    drv_vfd_init();
#endif /* CONFIG_VFD */

    /* IP Address */
    gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr ("ipaddr");

    /* MAC Address */
    {
        int i;
        ulong reg;
        char *s, *e;
        char tmp[64];

        i = getenv_r ("ethaddr", tmp, sizeof (tmp));
        s = (i &gt; 0) ? tmp : NULL;

        for (reg = 0; reg &lt; 6; ++reg) {
            gd-&gt;bd-&gt;bi_enetaddr[reg] = s ? simple_strtoul (s, &amp;e, 16) : 0;
            if (s)
                s = (*e) ? e + 1 : e;
        }

#ifdef CONFIG_HAS_ETH1
        i = getenv_r ("eth1addr", tmp, sizeof (tmp));
        s = (i &gt; 0) ? tmp : NULL;

        for (reg = 0; reg &lt; 6; ++reg) {
            gd-&gt;bd-&gt;bi_enet1addr[reg] = s ? simple_strtoul (s, &amp;e, 16) : 0;
            if (s)
                s = (*e) ? e + 1 : e;
        }
#endif
    }

    devices_init ();    /* get the devices list going. */

#ifdef CONFIG_CMC_PU2
    load_sernum_ethaddr ();
#endif /* CONFIG_CMC_PU2 */

    jumptable_init ();

    console_init_r ();  /* fully init console as a device */

#if defined(CONFIG_MISC_INIT_R)
    /* miscellaneous platform dependent initialisations */
    misc_init_r ();
#endif

    /* enable exceptions */
    enable_interrupts ();

    /* Perform network card initialisation if necessary */
#if defined(CONFIG_DRIVER_DM9000) &amp;&amp; defined(CONFIG_DRIVER_DM9000_NO_EEPROM)
extern int eth_set_mac(bd_t * bd);
    if (getenv ("ethaddr")) {
        eth_set_mac(gd-&gt;bd);
    }
#endif

#ifdef CONFIG_DRIVER_CS8900
    cs8900_get_enetaddr (gd-&gt;bd-&gt;bi_enetaddr);
#endif

#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
    if (getenv ("ethaddr")) {
        smc_set_mac_addr(gd-&gt;bd-&gt;bi_enetaddr);
    }
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

    /* Initialize from environment */
    if ((s = getenv ("loadaddr")) != NULL) {
        load_addr = simple_strtoul (s, NULL, 16);
    }
#if (CONFIG_COMMANDS &amp; CFG_CMD_NET)
    if ((s = getenv ("bootfile")) != NULL) {
        copy_filename (BootFile, s, sizeof (BootFile));
    }
#endif  /* CFG_CMD_NET */

#ifdef BOARD_LATE_INIT
    board_late_init ();
#endif
#if (CONFIG_COMMANDS &amp; CFG_CMD_NET)
#if defined(CONFIG_NET_MULTI)
    puts ("Net:     ");
#endif
    eth_initialize(gd-&gt;bd);
#endif
    /* main_loop() can return to retry autoboot, if so just run it again. */
    for (;;) {
        main_loop ();
    }

    /* NOTREACHED - no way out of command loop except booting */
}

void hang (void)
{
    puts ("### ERROR ### Please RESET the board ###\n");
    for (;;);
}

#ifdef CONFIG_MODEM_SUPPORT
static inline void mdm_readline(char *buf, int bufsiz);

/* called from main loop (common/main.c) */
extern void  dbg(const char *fmt, ...);
int mdm_init (void)
{
    char env_str[16];
    char *init_str;
    int i;
    extern char console_buffer[];
    extern void enable_putc(void);
    extern int hwflow_onoff(int);

    enable_putc(); /* enable serial_putc() */

#ifdef CONFIG_HWFLOW
    init_str = getenv("mdm_flow_control");
    if (init_str &amp;&amp; (strcmp(init_str, "rts/cts") == 0))
        hwflow_onoff (1);
    else
        hwflow_onoff(-1);
#endif

    for (i = 1;;i++) {
        sprintf(env_str, "mdm_init%d", i);
        if ((init_str = getenv(env_str)) != NULL) {
            serial_puts(init_str);
            serial_puts("\n");
            for(;;) {
                mdm_readline(console_buffer, CFG_CBSIZE);
                dbg("ini%d: [%s]", i, console_buffer);

                if ((strcmp(console_buffer, "OK") == 0) ||
                    (strcmp(console_buffer, "ERROR") == 0)) {
                    dbg("ini%d: cmd done", i);
                    break;
                } else /* in case we are originating call ... */
                    if (strncmp(console_buffer, "CONNECT", 7) == 0) {
                        dbg("ini%d: connect", i);
                        return 0;
                    }
            }
        } else
            break; /* no init string - stop modem init */

        udelay(100000);
    }

    udelay(100000);

    /* final stage - wait for connect */
    for(;i &gt; 1;) { /* if 'i' &gt; 1 - wait for connection
                  message from modem */
        mdm_readline(console_buffer, CFG_CBSIZE);
        dbg("ini_f: [%s]", console_buffer);
        if (strncmp(console_buffer, "CONNECT", 7) == 0) {
            dbg("ini_f: connected");
            return 0;
        }
    }

    return 0;
}

/* 'inline' - We have to do it fast */
static inline void mdm_readline(char *buf, int bufsiz)
{
    char c;
    char *p;
    int n;

    n = 0;
    p = buf;
    for(;;) {
        c = serial_getc();

        /*      dbg("(%c)", c); */

        switch(c) {
        case '\r':
            break;
        case '\n':
            *p = '\0';
            return;

        default:
            if(n++ &gt; bufsiz) {
                *p = '\0';
                return; /* sanity check */
            }
            *p = c;
            p++;
            break;
        }
    }
}
#endif  /* CONFIG_MODEM_SUPPORT */
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nand_cp.c]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/20/nand-cp-dot-c/"/>
    <updated>2015-06-20T15:17:22+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/20/nand-cp-dot-c</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;common.h&gt;
#ifdef CONFIG_S3C64XX
#include &lt;asm/io.h&gt;
#include &lt;linux/mtd/nand.h&gt;
#include &lt;regs.h&gt;

static int nandll_read_page (uchar *buf, ulong addr, int large_block)
{
    int i;
    int page_size = 512;

    if (large_block)    
        page_size = 2048;

        NAND_ENABLE_CE();               /*使能芯片*/

        NFCMD_REG = NAND_CMD_READ0;     /*读命令*/

        /* Write Address */
        NFADDR_REG = 0;                 /*页内起始地址*/

    if (large_block)
            NFADDR_REG = 0;

    NFADDR_REG = (addr) &amp; 0xff;         /*页地址*/
    NFADDR_REG = (addr &gt;&gt; 8) &amp; 0xff;
    NFADDR_REG = (addr &gt;&gt; 16) &amp; 0xff;

    if (large_block)
        NFCMD_REG = NAND_CMD_READSTART;

        NF_TRANSRnB();                  /*循环判断是否已经准备好 */

    for(i=0; i &lt; page_size; i++) {
                *buf++ = NFDATA8_REG;   /*从NandFlash数据寄存器读取*/
        }

        NAND_DISABLE_CE();
        return 0;
}

/*
 * Read data from NAND.
 */
static int nandll_read_blocks (ulong dst_addr, ulong size, int large_block)
{
        uchar *buf = (uchar *)dst_addr;                     /*这里buf就是指定的0x57e0 0000物理地址*/
        int i;
    uint page_shift = 9;

    if (large_block)
        page_shift = 11;

        /* Read pages */
        for (i = 0; i &lt; (0x50000&gt;&gt;page_shift); i++, buf+=(1&lt;&lt;page_shift)) {
                nandll_read_page(buf, i, large_block);      /*一次读取一个页*/
        }

        return 0;
}

int copy_uboot_to_ram (void)
{
    int large_block = 0;
    int i;
    vu_char id;

    NAND_ENABLE_CE();               /*使能芯片*/
    NFCMD_REG = NAND_CMD_READID;
    NFADDR_REG =  0x00;             /*取第二次的返回值*/

    /* wait for a while */
        for (i=0; i&lt;200; i++);
    id = NFDATA8_REG;
    id = NFDATA8_REG;

    if (id &gt; 0x80)                  //判断读取的id是否大于0x80
        large_block = 1;

    /* read NAND Block.
     * 128KB -&gt;240KB because of U-Boot size increase. by scsuh
     * So, read 0x3c000 bytes not 0x20000(128KB).
     */
    return nandll_read_blocks(CFG_PHY_UBOOT_BASE, 0x50000, large_block);
}

#endif
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cpu_init.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/19/cpu-init-dot-s/"/>
    <updated>2015-06-19T17:28:03+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/19/cpu-init-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;config.h&gt;                     /*里面包含mini6410.h*/
#include &lt;s3c6410.h&gt;

    .globl mem_ctrl_asm_init
mem_ctrl_asm_init:
    ldr r0, =ELFIN_MEM_SYS_CFG          @Memory sussystem address 0x7e00f120
    mov r1, #0xd                        @ Xm0CSn2 = NFCON CS0, Xm0CSn3 = NFCON CS1
    str r1, [r0]

    ldr r0, =ELFIN_DMC1_BASE            @DMC1 base address 0x7e001000

/* 1. 使dramc进入"config"状态 */
    ldr r1, =0x04
    str r1, [r0, #INDEX_DMC_MEMC_CMD]   

/* 2. 设置timing parameter*/
    ldr r1, =DMC_DDR_REFRESH_PRD
    str r1, [r0, #INDEX_DMC_REFRESH_PRD]        /*刷新周期7.8us */

    ldr r1, =DMC_DDR_CAS_LATENCY
    str r1, [r0, #INDEX_DMC_CAS_LATENCY]        /*CAS Latency:指的是内存存取数据所需的延迟时间，简单的说，就是内存接到CPU的指令后的反应速度。一般的参数值是2和3*/

    ldr r1, =DMC_DDR_t_DQSS
    str r1, [r0, #INDEX_DMC_T_DQSS]

    ldr r1, =DMC_DDR_t_MRD
    str r1, [r0, #INDEX_DMC_T_MRD]

    ldr r1, =DMC_DDR_t_RAS                      /*RAS=45ns*/
    str r1, [r0, #INDEX_DMC_T_RAS]

    ldr r1, =DMC_DDR_t_RC                       /*RC=68ns*/
    str r1, [r0, #INDEX_DMC_T_RC]

    ldr r1, =DMC_DDR_t_RCD
    ldr r2, =DMC_DDR_schedule_RCD
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RCD]

    ldr r1, =DMC_DDR_t_RFC
    ldr r2, =DMC_DDR_schedule_RFC
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RFC]

    ldr r1, =DMC_DDR_t_RP
    ldr r2, =DMC_DDR_schedule_RP
    orr r1, r1, r2
    str r1, [r0, #INDEX_DMC_T_RP]

    ldr r1, =DMC_DDR_t_RRD
    str r1, [r0, #INDEX_DMC_T_RRD]

    ldr r1, =DMC_DDR_t_WR
    str r1, [r0, #INDEX_DMC_T_WR]

    ldr r1, =DMC_DDR_t_WTR
    str r1, [r0, #INDEX_DMC_T_WTR]

    ldr r1, =DMC_DDR_t_XP
    str r1, [r0, #INDEX_DMC_T_XP]

    ldr r1, =DMC_DDR_t_XSR
    str r1, [r0, #INDEX_DMC_T_XSR]

    ldr r1, =DMC_DDR_t_ESR
    str r1, [r0, #INDEX_DMC_T_ESR]

/* 3.设置chip configuration*/
    ldr r1, =DMC1_MEM_CFG
    str r1, [r0, #INDEX_DMC_MEMORY_CFG]

    ldr r1, =DMC1_MEM_CFG2
    str r1, [r0, #INDEX_DMC_MEMORY_CFG2]

    ldr r1, =DMC1_CHIP0_CFG
    str r1, [r0, #INDEX_DMC_CHIP_0_CFG]

    ldr r1, =DMC_DDR_32_CFG
    str r1, [r0, #INDEX_DMC_USER_CONFIG]

/* 4. 初始化sdram */
    @DMC0 DDR Chip 0 configuration direct command reg
    ldr r1, =DMC_NOP0                                   /* NOP*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Precharge All
    ldr r1, =DMC_PA0                                    /*precharge*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Auto Refresh   2 time
    ldr r1, =DMC_AR0
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]                 /*auto refresh*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @MRS
    ldr r1, =DMC_mDDR_EMR0                              /*EMRS*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Mode Reg
    ldr r1, =DMC_mDDR_MR0                               /*MRS*/
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

#ifdef CONFIG_SMDK6410_X5A
    ldr r1, =DMC1_CHIP1_CFG
    str r1, [r0, #INDEX_DMC_CHIP_1_CFG]

    @DMC0 DDR Chip 0 configuration direct command reg
    ldr r1, =DMC_NOP1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Precharge All
    ldr r1, =DMC_PA1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Auto Refresh   2 time
    ldr r1, =DMC_AR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @MRS
    ldr r1, =DMC_mDDR_EMR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]

    @Mode Reg
    ldr r1, =DMC_mDDR_MR1
    str r1, [r0, #INDEX_DMC_DIRECT_CMD]
#endif

/* 5. 使dramc进入"ready"状态   */
    @Enable DMC1
    mov r1, #0x0
    str r1, [r0, #INDEX_DMC_MEMC_CMD]

check_dmc1_ready:
    ldr r1, [r0, #INDEX_DMC_MEMC_STATUS]
    mov r2, #0x3
    and r1, r1, r2
    cmp r1, #0x1
    bne check_dmc1_ready
    nop
    mov pc, lr                              /*内存控制器初始化完毕，返回*/


/* Below code is for ARM926EJS and ARM1026EJS */
    .globl cleanDCache
cleanDCache:
    mrc p15, 0, pc, c7, c10, 3  /* test/clean D-Cache */
    bne cleanDCache
    mov pc, lr

    .globl cleanFlushDCache
cleanFlushDCache:
    mrc p15, 0, pc, c7, c14, 3  /* test/cleanflush D-Cache */
    bne cleanFlushDCache
    mov pc, lr

    .globl cleanFlushCache
cleanFlushCache:
    mrc p15, 0, pc, c7, c14, 3  /* test/cleanflush D-Cache */
    bne cleanFlushCache
    mcr p15, 0, r0, c7, c5, 0   /* flush I-Cache */
    mov pc, lr

    .ltorg
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lowlevel_init.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/18/lowlevel-init-dot-s/"/>
    <updated>2015-06-18T15:38:36+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/18/lowlevel-init-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C">#include &lt;config.h&gt;
#include &lt;version.h&gt;
#include &lt;s3c6410.h&gt;
#include "mini6410_val.h"

_TEXT_BASE:
    .word   TEXT_BASE

    .globl lowlevel_init
lowlevel_init:
    mov r12, lr                     /*bl指令会把下一条指令的地址赋给lr，在这里保存lr是为了最后能够成功地函数返回*/

    /* LED on only #8 */
    ldr r0, =ELFIN_GPIO_BASE        /*Regs.h中的宏定义，就是s3c6410.h中的宏定义*/
    ldr r1, =0x55540000
    str r1, [r0, #GPNCON_OFFSET]    /*GPN15~GPN9均是输出(01),GPN0~GPN8均是输入(00)*/

    ldr r1, =0x55555555
    str r1, [r0, #GPNPUD_OFFSET]    /*GPN0~GPN15均是下拉使能*/

    ldr r1, =0xf000
    str r1, [r0, #GPNDAT_OFFSET]    /*GPN15~GPN12输出高电平，GPN10~11输出低电平*/

    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x1
    str r1, [r0, #GPECON_OFFSET]    /*GPE0设置为输出，GPE1~GPE15设置为输入*/
    ldr r1, =0x0
    str r1, [r0, #GPEDAT_OFFSET]    /*GPE0输出低电平*/

    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x2A5AAAAA
    str r1, [r0, #GPPCON_OFFSET]    /*GPP15设置为输入，GPP11~GPP10设置为输出，其余设置为片内外设功能*/
    ldr r1, =0x0
    str r1, [r0, #GPPDAT_OFFSET]    /*GPP11和GPP10输出低电平*/


    ldr r1, =0x55555555
    str r1, [r0, #MEM1DRVCON_OFFSET]    /*由于ddr芯片的工作电压在1.8V，所以驱动电流设置为7mA*/

    /* Disable Watchdog */              /*关闭片内看门狗*/
    ldr r0, =0x7e000000     @0x7e004000
    orr r0, r0, #0x4000
    mov r1, #0
    str r1, [r0]

    @ External interrupt pending clear
    ldr r0, =(ELFIN_GPIO_BASE+EINTPEND_OFFSET)  /*EINTPEND*/
    ldr r1, [r0]                        /*读一次外部中断就能清楚外部中断信号*/
    str r1, [r0]

    ldr r0, =ELFIN_VIC0_BASE_ADDR   @0x71200000
    ldr r1, =ELFIN_VIC1_BASE_ADDR   @0x71300000

    @ Disable all interrupts (VIC0 and VIC1)
    mvn r3, #0x0                        /*0取反为全1*/
    str r3, [r0, #oINTMSK]              /*禁用所有中断*/
    str r3, [r1, #oINTMSK]

    @ Set all interrupts as IRQ
    mov r3, #0x0
    str r3, [r0, #oINTMOD]              /*将所有中断设置为IRQ中断*/
    str r3, [r1, #oINTMOD]

    @ Pending Interrupt Clear
    mov r3, #0x0                        /*清除所有当前激活的中断服务程序的地址*/
    str r3, [r0, #oVECTADDR]
    str r3, [r1, #oVECTADDR]

    /* init system clock */
    bl system_clock_init                /*初始化系统时钟*/

    /* for UART */
    bl uart_asm_init                    /*初始化串口*/

#if defined(CONFIG_NAND)
    /* simple init for NAND */
    bl nand_asm_init                    /*nand flash初始化*/
#endif

    bl  mem_ctrl_asm_init               /*内存控制器初始化,函数位于/CPU/s3c6410/CPU_init.S*/

    ldr     r0, =(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)       /*7e00_f904-&gt;RST_STAT*/
    ldr     r1, [r0]
    bic     r1, r1, #0xfffffff7
    cmp     r1, #0x8                    /*bit[3]=1,表明从SLEEP状态中唤醒*/
    beq     wakeup_reset

1:
    ldr r0, =ELFIN_UART_BASE
    ldr r1, =0x4b4b4b4b                 /*通过串口发送字母“K”*/
    str r1, [r0, #UTXH_OFFSET]

    mov lr, r12
    mov pc, lr                          /*lowlevel_init结束，返回*/

wakeup_reset:

    ldr r0, =(ELFIN_CLOCK_POWER_BASE+WAKEUP_STAT_OFFSET)
    ldr r1, [r0]
    str r1, [r0]                        /*Clear wakeup status register*/

    /*LED test*/
    ldr     r0, =ELFIN_GPIO_BASE
    ldr     r1, =0x3000
    str     r1, [r0, #GPNDAT_OFFSET]

    /*Load return address and jump to kernel*/
    ldr r0, =(ELFIN_CLOCK_POWER_BASE+INF_REG0_OFFSET)       /*0x4c00_0a00-&gt;INFORM0*/
    ldr r1, [r0]                                            /* r1 = physical address of s3c6400_cpu_resume function*/
    mov pc, r1                                              /*Jump to kernel (sleep-s3c6400.S)*/
    nop
    nop

/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
    ldr r0, =ELFIN_CLOCK_POWER_BASE @0x7e00f000

#ifdef  CONFIG_SYNC_MODE
    ldr r1, [r0, #OTHERS_OFFSET]
    mov r2, #0x40
    orr r1, r1, r2
    str r1, [r0, #OTHERS_OFFSET]                

    nop
    nop
    nop
    nop
    nop

    ldr r2, =0x80
    orr r1, r1, r2
    str r1, [r0, #OTHERS_OFFSET]            /*bit[6],bit[7]都置1，设置成同步模式*/

check_syncack:                              /*等待时钟完成同步*/
    ldr r1, [r0, #OTHERS_OFFSET]
    ldr r2, =0xf00
    and r1, r1, r2                          /*只查看bit[8]~bit[11]，这几位是SYNC mode相应位，只读,只有在AYNC模式才能读1*/
    cmp r1, #0xf00
    bne check_syncack
#else                                       /* 否则配置成异步时钟模式 */
    nop
    nop
    nop
    nop
    nop

    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0xC0
    orr r1, r1, #0x40                       /*bit[6]置1，bit[7]清0*/
    str r1, [r0, #OTHERS_OFFSET]            

wait_for_async:
    ldr r1, [r0, #OTHERS_OFFSET]
    and r1, r1, #0xf00
    cmp r1, #0x0
    bne wait_for_async

    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0x40                       /*bit[6]清0*/
    str r1, [r0, #OTHERS_OFFSET]
#endif

    mov r1, #0xff00
    orr r1, r1, #0xff                       /*设置各PLL的LOCK_TIME,使用最大值*/
    str r1, [r0, #APLL_LOCK_OFFSET]         /*APLL_LOCK，供cpu使用*/ 
    str r1, [r0, #MPLL_LOCK_OFFSET]         /*MPLL_LOCK，供AHB(存储/中断/lcd等控制器)/APB(看门狗，定时器，SD等)总线上的设备使用*/
    str r1, [r0, #EPLL_LOCK_OFFSET]         /*EPLL_LOCK，供UART,IIS,IIC使用*/

#if defined(CONFIG_CLKSRC_CLKUART)
    ldr     r1, [r0, #CLK_DIV2_OFFSET]
    bic r1, r1, #0x70000
    orr r1, r1, #0x30000                    /*CLK_DIV2的bit[16]~bit[19]即UART_RATIO,设置为3,CLKUART(66.5Mhz)=CLKUART_input(532/2=266Mhz)/(UART_RATIO(3)+1)*/
    str r1, [r0, #CLK_DIV2_OFFSET]
#endif

    ldr     r1, [r0, #CLK_DIV0_OFFSET]      /*Set Clock Divider*/
    bic r1, r1, #0x30000
    bic r1, r1, #0xff00
    bic r1, r1, #0xff
    ldr r2, =CLK_DIV_VAL
    orr r1, r1, r2
    str r1, [r0, #CLK_DIV0_OFFSET]          /*设置时钟的分频系数*/

    ldr r1, =APLL_VAL                       /*设置APLL_MDIV=266,APLL_PDIV=3,APLL_SDIV=1*/
    str r1, [r0, #APLL_CON_OFFSET]          /*FOUT = MDIV X FIN / (PDIV X 2^SDIV) = 266*12/(3*2^1) = 532MHz*/
    ldr r1, =MPLL_VAL                       /*设置MPLL_MDIV=266,MPLL_PDIV=3,MPLL_SDIV=1*/
    str r1, [r0, #MPLL_CON_OFFSET]          /*FOUT = MDIV X FIN / (PDIV X 2^SDIV) = 266*12/(3*2^1) = 532MHz*/

    ldr r1, =0x80200102                     /*设置EPLL_MDIV=32,EPLL_PDIV=1,EPLL_SDIV=2*/
    str r1, [r0, #EPLL_CON0_OFFSET]         /*FOUT = (MDIV+KDIV/2^16) X FIN / (PDIV X 2^SDIV) = (32+0)*12/(1*2^2) = 96MHz*/
    ldr r1, =0x0                            /*设置EPLL_KDIV=0*/
    str r1, [r0, #EPLL_CON1_OFFSET]

    ldr r1, [r0, #CLK_SRC_OFFSET]           /*读取CLK_SRC寄存器的值*/

#if defined(CONFIG_CLKSRC_CLKUART)
    ldr r2, =0x2007                                 
#else
    ldr r2, =0x7
#endif
    orr r1, r1, r2                          /*APLL,MPLL,EPLL的时钟源选择各自的Fout；UART的时钟源选择DOUT_MPLL*/

    str r1, [r0, #CLK_SRC_OFFSET]

    mov r1, #0x10000                        /*等待所有时钟稳定，至少200us*/
1:  subs    r1, r1, #1                      /*非0则跳转*/
    bne 1b

#ifdef CONFIG_SYNC_MODE                     /* Synchronization for VIC port */
    ldr r1, [r0, #OTHERS_OFFSET]
    orr r1, r1, #0x20
    str r1, [r0, #OTHERS_OFFSET]
#else
    ldr r1, [r0, #OTHERS_OFFSET]
    bic r1, r1, #0x20
    str r1, [r0, #OTHERS_OFFSET]
#endif

    mov pc, lr                              /*系统时钟初始化完成，返回*/


/*
 * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
 * void uart_asm_init(void)
 */
uart_asm_init:
    /*配置GPIO的功能为串口UART*/
    /*UART0_RXD=GPA0,UART0_TXD=GPA1,UART1_RXD=GPA4,UART1_TXD=GPA5*/
    /*UART2_RXD=GPB0,UART2_TXD=GPB1,UART3_RXD=GPB2,UART3_TXD=GPB3*/
    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0x22222222
    str     r1, [r0, #GPACON_OFFSET]        /*配置UART0和UART1使用的GPIO引脚,UART0和UART1具有流控功能(GPA0~GPA7)*/
    ldr r1, =0x2222
    str     r1, [r0, #GPBCON_OFFSET]        /*配置UART2和UART3使用的GPIO引脚,UART2和UART3不具有流控功能(GPB0~GPB3)*/

    ldr r0, =ELFIN_UART_CONSOLE_BASE        /*ELFIN_UART_CONSOLE_BASE=0x7F005000,即UART0*/
    mov r1, #0x0
    str r1, [r0, #UFCON_OFFSET]             /*禁止使用FIFO*/
    str r1, [r0, #UMCON_OFFSET]             /*禁止流控，调制解调功能*/

    mov r1, #0x3                            /*配置UART0：数据位:8, 无校验, 停止位: 1, 8n1*/
    str r1, [r0, #ULCON_OFFSET]

/*设置波特率 */
/*DIV_VAL = (EXT_UCLK1 / (bps x 16 ) ) - 1 = (66500000/(115200x16))-1 = 35.08*/
/*DIV_VAL = 35.08 = UBRDIVn + (num of 1’s in UDIVSLOTn)/16*/
#if defined(CONFIG_CLKSRC_CLKUART)
    ldr r1, =0xe45                          /* UARTCLK_SRC=11 =&gt; EXT_UCLK1,EXT_UCLK1由MPLL或者EPLL分频得到,这里是66.5MHz。串口数据接收发送采用轮训或者中断的方式*/
#else
    ldr r1, =0x245                          /* UARTCLK_SRC=x0 =&gt; PCLK */
#endif
    str r1, [r0, #UCON_OFFSET]

#if defined(CONFIG_UART_50)
    ldr r1, =0x1A
#elif defined(CONFIG_UART_66)
    ldr r1, =0x23
#else
    ldr r1, =0x1A
#endif
    str r1, [r0, #UBRDIV_OFFSET]            /*UBRDIV0=35*/

#if defined(CONFIG_UART_50)
    ldr r1, =0x3
#elif defined(CONFIG_UART_66)
    ldr r1, =0x0080
#else
    ldr r1, =0x3
#endif
    str r1, [r0, #UDIVSLOT_OFFSET]          /*UDIVSLOT0中有1个‘1’*/

    ldr r1, =0x4f4f4f4f
    str r1, [r0, #UTXH_OFFSET]              /*UART0串口发送字母‘O’*/

    mov pc, lr                              /*串口配置结束，返回*/

/*
 * Nand Interface Init for SMDK6410 
 * /
nand_asm_init:                              /*初始化NandFlash控制器*/
    ldr r0, =ELFIN_NAND_BASE
    ldr r1, [r0, #NFCONF_OFFSET]
    orr r1, r1, #0x70                       /*TWRPH1=7*/
    orr r1, r1, #0x7700                     /*TWRPH0=7,TACLS=7*/
    str     r1, [r0, #NFCONF_OFFSET]

    ldr r1, [r0, #NFCONT_OFFSET]
    orr r1, r1, #0x03                       /*使能NandFlash控制器*/
    str     r1, [r0, #NFCONT_OFFSET]

    mov pc, lr                              /*NandFlash控制器初始化完毕，返回*/


#ifdef CONFIG_ENABLE_MMU
                                            /*为Uboot服务的MMU页表在这里创建*/
                                            /* form a first-level section entry */
/*定义一个可以生成描述符的宏*/
/*描述符的最低两位00为无效，01为二级页表方式（由高地址12位的一级页表(TTB的高18位指定的虚拟基地址)位置取出对应二级页表(coarse page table)的基地址，由中间地址8位的二级页表取出对应4KB页表（small page）的基地址，最后由低12为地址的页表取出最终的内存值），10为一级页表方式（如果bit18为0，则为section，bit18为1，则为supersection），11保留。*/
.macro FL_SECTION_ENTRY base,ap,d,c,b       
    .word (\base &lt;&lt; 20) | (\ap &lt;&lt; 10) | \
          (\d &lt;&lt; 5) | (1&lt;&lt;4) | (\c &lt;&lt; 3) | (\b &lt;&lt; 2) | (1&lt;&lt;1)
.endm

/*按照section方式映射，每个section必须是1M，占20位地址，这里共256M物理内存，映射到整个4G地址空间，所以共有4096（0x1000）个描述符。虚拟地址的高12位（4096）作为描述符位置，低20位作为section里面的地址*/
.section .mmudata, "a"                      /*指名该段的名称是.mmudata,在u-boot.lds中会为该段分配具体的空间，.a表示这是一个需要鉴权的段*/
    .align 14                               /*对齐到0x4000*/
    // the following alignment creates the mmu table at address 0x4000.
    .globl mmu_table                        /*mmu页表地址需要在start.S中告诉CPU以启动MMU，因此需要声明为全局变量*/
mmu_table:
    .set __base,0
    // 1:1 mapping for debugging
    .rept 0xA00                             /*共2048个描述符*/
    FL_SECTION_ENTRY __base,3,0,0,0         /*ap为3表示读允许,d为0表示这些描述符都属于domain0，domain用来做权限控制,c和b为0表示共享，互斥读写*/
    .set __base,__base+1
    .endr

    // access is not allowed.
    .rept 0xC00 - 0xA00                     /*共512个描述符*/
    .word 0x00000000                        /*ap为0表示不允许访问*/
    .endr

    // 128MB for SDRAM 0xC0000000 -&gt; 0x50000000
    .set __base, 0x500
    .rept 0xC80 - 0xC00                     /*共128个描述符*/
    FL_SECTION_ENTRY __base,3,0,1,1         /*ap为3表示读允许,d为0表示这些描述符都属于domain0，domain用来做权限控制,c和b为1表示内存输入输出都为回写模式*/
    .set __base,__base+1
    .endr

    // access is not allowed.
    .rept 0x1000 - 0xc80                        /*共896个描述符*/
    .word 0x00000000                        /*ap为0表示不允许访问*/
    .endr

#endif
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mini6410.h]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/17/mini6410-dot-h/"/>
    <updated>2015-06-17T11:49:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/17/mini6410-dot-h</id>
    <content type="html"><![CDATA[<pre><code class="C">#define CONFIG_S3C6410      1       /* in a SAMSUNG S3C6410 SoC */
#define CONFIG_S3C64XX      1       /* in a SAMSUNG S3C64XX Family  */
#define CONFIG_MINI6410     1       /* in a FriendlyARM MINI6410 Board */

#define CFG_UBOOT_SIZE      (2*1024*1024)   /*定义Uboot大小为2M字节*/

#define CONFIG_ENABLE_MMU   /*在Uboot中开启MMU,目的为了开启DCache来提高运行速度*/
#define MEMORY_BASE_ADDRESS 0x50000000  /*DDR起始地址*/
#define CFG_PHY_UBOOT_BASE  MEMORY_BASE_ADDRESS + 0x7e00000 /*Uboot的物理地址0x57e00000*/

#ifdef CONFIG_ENABLE_MMU
#define CFG_UBOOT_BASE      0xc7e00000
#else
#define CFG_UBOOT_BASE      0x57e00000
#endif

#define CFG_ENV_OFFSET      0x00040000      /*Uboot中环境变量偏移地址*/
#define CFG_ENV_SIZE        0x20000         /* Total Size of Environment Sector */

/****************************************NANDFlash宏定义*********************************************/
#define CFG_MAX_NAND_DEVICE     1
#define CFG_NAND_BASE           (0x70200010)
#define NAND_MAX_CHIPS          1

#define NAND_DISABLE_CE()   (NFCONT_REG |= (1 &lt;&lt; 1))
#define NAND_ENABLE_CE()    (NFCONT_REG &amp;= ~(1 &lt;&lt; 1))
#define NF_TRANSRnB()       do { while(!(NFSTAT_REG &amp; (1 &lt;&lt; 0))); } while(0)

#define CFG_NAND_SKIP_BAD_DOT_I 1  /* ".i" read skips bad blocks   */
#define CFG_NAND_WP     1
#define CFG_NAND_YAFFS_WRITE    1  /* support yaffs write */

#if defined(FRIENDLYARM_BOOT_MEDIA_NAND)    /*启动介质是NandFlash*/
#define CONFIG_BOOT_NAND
#elif defined(FRIENDLYARM_BOOT_MEDIA_SD)    /*启动介质是SD Card*/
#define CONFIG_BOOT_MOVINAND
#else
#error Boot media not defined
#endif

#define CONFIG_NAND
#define CONFIG_MOVINAND

#define CONFIG_MEMORY_UPPER_CODE

#undef CONFIG_USE_IRQ                       /* Uboot中不使用IRQ/FIQ*/



/******************************************系统时钟宏定义*******************************************/
#define CONFIG_CLK_532_133_66               /*FIN=12MHz,Fout=532MHz*/
#define APLL_MDIV   266
#define APLL_PDIV   3
#define APLL_SDIV   1
#define CONFIG_SYNC_MODE
#define set_pll(mdiv, pdiv, sdiv)   (1&lt;&lt;31 | mdiv&lt;&lt;16 | pdiv&lt;&lt;8 | sdiv)
#define APLL_VAL    set_pll(APLL_MDIV, APLL_PDIV, APLL_SDIV)
#define Startup_APLL    (CONFIG_SYS_CLK_FREQ/(APLL_PDIV&lt;&lt;APLL_SDIV)*APLL_MDIV)

#define MPLL_MDIV   266                     /* fixed MPLL 533MHz */
#define MPLL_PDIV   3
#define MPLL_SDIV   1
#define MPLL_VAL    set_pll(MPLL_MDIV, MPLL_PDIV, MPLL_SDIV)
#define Startup_MPLL    ((CONFIG_SYS_CLK_FREQ)/(MPLL_PDIV&lt;&lt;MPLL_SDIV)*MPLL_MDIV)

#define Startup_APLLdiv     0
#define Startup_HCLKx2div   1
#define Startup_PCLKdiv     3
#define Startup_HCLKdiv     1
#define Startup_MPLLdiv     1

#define CLK_DIV_VAL ((Startup_PCLKdiv&lt;&lt;12)|(Startup_HCLKx2div&lt;&lt;9)|(Startup_HCLKdiv&lt;&lt;8)|(Startup_MPLLdiv&lt;&lt;4)|Startup_APLLdiv)

#if defined(CONFIG_SYNC_MODE)
#define Startup_HCLK    (Startup_APLL/(Startup_HCLKx2div+1)/(Startup_HCLKdiv+1))
#else
#define Startup_HCLK    (Startup_MPLL/(Startup_HCLKx2div+1)/(Startup_HCLKdiv+1))
#endif

#define CONFIG_CLKSRC_CLKUART
#define CONFIG_UART_66                      /*CLKUART=66.5MHz*/



/*****************************************DDR控制器宏定义*******************************************/
#if defined(FRIENDLYARM_BOOT_RAM256)
#define DMC1_MEM_CFG        ((1&lt;&lt;30) | (2&lt;&lt;15) | (3&lt;&lt;3) | (2&lt;&lt;0))   /*column address(10):A0~A9;row address(14):A0~A13;Burst Length =4*/
#define DMC1_CHIP0_CFG      0x150F0                                 /*Bank-Row-Column organization */
#define PHYS_SDRAM_1_SIZE   0x10000000 /* 256 MB */
#elif defined(FRIENDLYARM_BOOT_RAM128)
#define DMC1_MEM_CFG        ((1&lt;&lt;30) | (2&lt;&lt;15) | (2&lt;&lt;3)| (2&lt;&lt;0))
#define DMC1_CHIP0_CFG      0x150F8
#define PHYS_SDRAM_1_SIZE   0x8000000 /* 128 MB */
#else
#error RAM size must be defined
#endif

#define DMC1_MEM_CFG2       0xB41       /*Memory with=32,Mobile DDR SDRAM,Read delay 1 cycle*/
#define DMC_DDR_32_CFG      0x0         

/* DDR Parameters */
#define DDR_tREFRESH        7800        /* ns */
#define DDR_tRAS        45      /* ns (min: 45ns)*/
#define DDR_tRC         68      /* ns (min: 67.5ns)*/
#define DDR_tRCD        23      /* ns (min: 22.5ns)*/
#define DDR_tRFC        80      /* ns (min: 80ns)*/
#define DDR_tRP         23      /* ns (min: 22.5ns)*/
#define DDR_tRRD        15      /* ns (min: 15ns)*/
#define DDR_tWR         15      /* ns (min: 15ns)*/
#define DDR_tXSR        120     /* ns (min: 120ns)*/
#define DDR_CASL        3       /* CAS Latency 3 */

#define DMC_DDR_BA_EMRS     2
#define DMC_DDR_MEM_CASLAT  3
#define DMC_DDR_CAS_LATENCY (DDR_CASL&lt;&lt;1)                       //6   Set Cas Latency to 3
#define DMC_DDR_t_DQSS      1                           // Min 0.75 ~ 1.25
#define DMC_DDR_t_MRD       2                           //Min 2 tck
#define DMC_DDR_t_RAS       (((Startup_HCLK / 1000 * DDR_tRAS) - 1) / 1000000 + 1)  //7, Min 45ns
#define DMC_DDR_t_RC        (((Startup_HCLK / 1000 * DDR_tRC) - 1) / 1000000 + 1)   //10, Min 67.5ns
#define DMC_DDR_t_RCD       (((Startup_HCLK / 1000 * DDR_tRCD) - 1) / 1000000 + 1)  //4,5(TRM), Min 22.5ns
#define DMC_DDR_schedule_RCD    ((DMC_DDR_t_RCD - 3) &lt;&lt; 3)
#define DMC_DDR_t_RFC       (((Startup_HCLK / 1000 * DDR_tRFC) - 1) / 1000000 + 1)  //11,18(TRM) Min 80ns
#define DMC_DDR_schedule_RFC    ((DMC_DDR_t_RFC - 3) &lt;&lt; 5)
#define DMC_DDR_t_RP        (((Startup_HCLK / 1000 * DDR_tRP) - 1) / 1000000 + 1)   //4, 5(TRM) Min 22.5ns
#define DMC_DDR_schedule_RP ((DMC_DDR_t_RP - 3) &lt;&lt; 3)
#define DMC_DDR_t_RRD       (((Startup_HCLK / 1000 * DDR_tRRD) - 1) / 1000000 + 1)  //3, Min 15ns
#define DMC_DDR_t_WR        (((Startup_HCLK / 1000 * DDR_tWR) - 1) / 1000000 + 1)   //Min 15ns
#define DMC_DDR_t_WTR       2
#define DMC_DDR_t_XP        2                           //1tck + tIS(1.5ns)
#define DMC_DDR_t_XSR       (((Startup_HCLK / 1000 * DDR_tXSR) - 1) / 1000000 + 1)  //17, Min 120ns
#define DMC_DDR_t_ESR       DMC_DDR_t_XSR
#define DMC_DDR_REFRESH_PRD (((Startup_HCLK / 1000 * DDR_tREFRESH) - 1) / 1000000)  // TRM 2656
#define DMC_DDR_USER_CONFIG 1                           // 2b01 : mDDR

#define CONFIG_NR_DRAM_BANKS    1      /* we have 2 bank of DRAM */
#define PHYS_SDRAM_1        MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
</code></pre>
]]></content>
  </entry>
  
</feed>
