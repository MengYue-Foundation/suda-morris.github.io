<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: study | WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2016-03-24T21:57:06+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[初识Nginx]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/29/about-nginx/"/>
    <updated>2015-06-29T10:21:37+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/29/about-nginx</id>
    <content type="html"><![CDATA[<h2>Nginx简介</h2>

<blockquote><ol>
<li>Nginx是一种服务器软件，Nginx是一种高性能的HTTP和反向代理服务器，同时是一个代理邮件服务器，也就是Ngix上可以发布网站，也可以实现负载均衡，还可以作为邮件服务器实现收发邮件的功能</li>
<li>所谓负载均衡，是指当同时有N多个用户访问我们服务器的时候，为了减小服务器压力，我们需要将用户分别引入各服务器，分担服务器压力</li>
<li>优点：高并发，部署简单，内存消耗少，成本低</li>
<li>缺点：rewrite功能不够强大，模块没有Apache多</li>
</ol>
</blockquote>

<h2>其它服务器</h2>

<ol>
<li>IIS服务器只能在Windows上运行，Windows服务器性能不如Linux服务器</li>
<li>Tomcat服务器面向的是Java语言，是一种重量级的服务器</li>
<li>Apache服务器稳定，开源，跨平台，但是不支持高并发</li>
</ol>


<h2>Nginx环境的搭建</h2>

<ol>
<li><a href="http://nginx.org">进入官网下载最新版</a></li>
<li>安装gcc:<code>yum -y install gcc gcc-c++ autoconf automake</code></li>
<li>安装PCRE库文件：<code>yum -y install pcre pcre-devel</code></li>
<li>安装zlib库文件：<code>yum -y install zlib zlib-devel</code></li>
<li>解压缩Nginx压缩包，然后进入解压后文件夹，<code>./config --prefix=/software</code>,成功后执行<code>make $$ make install</code></li>
<li>启动服务器：<code>/software/nginx/sbin/nginx -c /software/nginx/conf/nginx.conf</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言知识点]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/27/c-language-review/"/>
    <updated>2015-06-27T15:17:24+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/27/c-language-review</id>
    <content type="html"><![CDATA[<h2><code>#ifdef和#if defined的差别</code></h2>

<p>注意两者都有个define的作用，区别在于使用方式上。前者的通常用法是:
<figure class='code'><figcaption><span>只能在两者中选择是否有定义</p></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">ifdef</span>  <span class="n">XXX</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="o">&amp;</span><span class="n">hellip</span><span class="p">;.</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="k">else</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="o">&amp;</span><span class="n">hellip</span><span class="p">;.</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">endif</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="err">对于后者，常用法是：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="k">if</span> <span class="n">defined</span> <span class="n">xxx1</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="o">&amp;</span><span class="n">hellip</span><span class="p">;.</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">elif</span> <span class="n">defined</span> <span class="n">xxx2</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="o">&amp;</span><span class="n">hellip</span><span class="p">;.</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">elif</span> <span class="n">defined</span> <span class="n">xxx3</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="o">&amp;</span><span class="n">hellip</span><span class="p">;.</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">endif</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="cp">##小细节</span>
</span><span class='line'><span class="mf">1.</span> <span class="n">C</span><span class="o">++</span><span class="err">并不支持</span><span class="kt">void</span><span class="o">*</span><span class="err">隐式转换为其他类型的指针，但是</span><span class="n">C</span><span class="err">语言允许</span>
</span><span class='line'><span class="mf">2.</span> <span class="err">变量命名，所有字符都使用小写，含义多的可以用</span><span class="o">**</span><span class="n">_</span><span class="o">**</span><span class="err">进行辅助</span>
</span><span class='line'><span class="mf">3.</span> <span class="err">全局变量能少用就少用，必须要用的情况下，可以考虑添加前缀</span><span class="o">**</span><span class="n">g_</span><span class="o">**</span>
</span><span class='line'><span class="mf">4.</span> <span class="err">不要将</span><span class="o">**</span><span class="n">_</span><span class="o">**</span><span class="err">作为宏的开头或者结尾</span>
</span><span class='line'><span class="mf">5.</span> <span class="err">要使用</span><span class="o">**</span><span class="err">#</span><span class="k">if</span><span class="o">**</span><span class="err">而不是</span><span class="o">**</span><span class="err">#</span><span class="n">ifdef</span><span class="o">**</span><span class="err">，可以使用</span><span class="o">**</span><span class="n">define</span><span class="err">（）</span><span class="o">**</span><span class="err">来替代</span><span class="o">**</span><span class="err">#</span><span class="n">ifdef</span><span class="o">**</span><span class="err">的功能</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="k">if</span> <span class="o">!</span><span class="n">define</span><span class="p">(</span><span class="n">USERS_DEFINE</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="err">#</span><span class="n">define</span> <span class="n">USERS_DEFINE</span> <span class="p">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="err">#</span><span class="n">endif</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>volatile关键字</h2>

<p>一旦使用了，就是告诉编译器，即使这个变量没有被使用或修改其他内存单元，它的值也可能发生变化。通俗地讲，告诉编译器，不要把你的那一套优化策略用在我的身上</p>

<h2>两种不太常见的格式：%[]和%*</h2>

<ol>
<li>%[]用于限制读取类型，常见于字符串的过滤。
<code>C
//假设输入：22 hello,string to me!
scanf("%d %[a-z]", &amp;tmp, str);//22 hello
scanf("%d %[^i]", &amp;tmp, str);//22 hello,str
scanf("%d %[^,]", &amp;tmp, str);//22 hello
</code></li>
<li>%*是忽略第一个输入，也可以理解为文件宽度(域宽)
<code>C
//假设输入：22 33
scanf("%*d %d", &amp;tmp);//读到33
</code>
<code>C
char str[10] = "dir";
printf("%*s%s",4 ,"" , str);//输出:    dir,前面有四个空白占位   
</code></li>
</ol>


<h2>select机制</h2>

<ol>
<li>select()的机制中提供一fd_set的数据结构，实际上是一long类型的数组， 每一个数组元素都能与一打开的文件句柄（不管是Socket句柄，还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读或可写。</li>
<li>程序去select的时候，如果没有数据输入，程序会一直等待，直到有数据为止，也就是程序中无需循环和sleep</li>
<li>使用Select就可以完成非阻塞（所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生，则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的程序，它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。</li>
<li>返回值：准备就绪的描述符数，若超时则返回0，若出错则返回-1。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GNS3_Install]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/08/gns3-install/"/>
    <updated>2015-06-08T11:24:09+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/08/gns3-install</id>
    <content type="html"><![CDATA[<h2>GNS3模拟器安装步骤</h2>

<ol>
<li><a href="https://community.gns3.com/community/software/download/">下载GNS3</a>，并且安装</li>
<li><a href="https://community.gns3.com/community/software/download/">下载GNS3 IOU VM虚拟机镜像</a></li>
<li>下载路由器和交换机的IOS镜像文件(百度搜索并下载)

<ul>
<li>i86bi-linux-l2-ipbasek9-15.1g.bin(交换机)</li>
<li>i86bi-linux-l3-adventerprisek9-15.4.1T.bin(路由器)</li>
</ul>
</li>
<li>安装virtualbox</li>
<li>导入步骤2中下载的GNS3虚拟机镜像，设置网卡为hostonly，并启动虚拟机</li>
<li>GNS3是基于linux系统的，root用户登录，密码为cisco，然后查看网卡ip地址ifconfig</li>
<li>在浏览器中输入刚才查找到的IP地址，并指名端口号8000下的upload，例如：<a href="http://192.168.172.101:8000/upload">http://192.168.172.101:8000/upload</a></li>
<li>打开GNS3软件，在edit->Preference->Server中添加虚拟机的IP地址以及端口(ip地址来自步骤6)</li>
<li>在edit->Preference->IOS on UNIX中，指名iourc.txt的路径</li>
<li>在edit->Preference->IOU devices中，添加switch和router镜像路径(路径为上传到虚拟机中的具体路径，例如：/home/gns3/GNS3/images/IOU/i86bi-linux-l2-ipbasek9-15.1g.bin)</li>
<li>启动设备</li>
</ol>


<p><img src="http://i.imgur.com/Nn7Krru.gif" alt="suda-morris" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python-BaseKnowledge]]></title>
    <link href="http://suda-morris.github.io/blog/2015/05/28/python-baseknowledge/"/>
    <updated>2015-05-28T21:42:24+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/05/28/python-baseknowledge</id>
    <content type="html"><![CDATA[<h2>Python中的常量</h2>

<pre><code class="Python 常量定义">class _const(object)
    class ConstError(TypeError): pass

    def __setattr__(self,name,value):
        if self.__dict__.has_key(name):
            raise self.ConstError,"Can't rebind const(%s)" % name
        self.__dict__[name] = value

    def __delattr__(self,name):
        if name in self.__dict__:
            raise self.ConstError,"Can't unbind const(%s)" % name
        raise NameError, name
import sys
sys.modules[__name__] = _const()
</code></pre>

<ul>
<li>把以上代码变成const.py文件放到Python安装目录的Lib文件夹下</li>
</ul>


<h2>引号的使用与区别</h2>

<ol>
<li>单引号与双引号可以交叉使用，即双引号中的单引号维持原样，单引号中的双引号维持原样</li>
<li>三引号里面不能使用单引号和双引号，三引号中的格式维持不变，该回车就回车，该空格就空格</li>
<li>当需要把转义字符原样输出的时候可以使用自然字符串，即在字符串前面加r</li>
<li>子字符串运算方法：

<ul>
<li>索引运算（从0开始索引）</li>
<li>切片运算（[a:b]是指从第a下标开始到第b-1下标结束，同样第一位下标为0）</li>
</ul>
</li>
<li>列表中的元素是有序的

<ul>
<li>students=[&ldquo;小明&rdquo;,&ldquo;小华&rdquo;,&ldquo;小李&rdquo;,&ldquo;小娟&rdquo;,&ldquo;小云&rdquo;]，下标从0开始</li>
</ul>
</li>
<li>元祖里面的内容只能读取，不能修改，列表里面的内容既可以修改，又能读取

<ul>
<li>students=(&ldquo;小明&rdquo;,&ldquo;小华&rdquo;,&ldquo;小李&rdquo;,&ldquo;小娟&rdquo;,&ldquo;小云&rdquo;)</li>
</ul>
</li>
<li>Python中集合主要有两个功能，一个功能是建立关系，另一个是消除重复元素，集合的格式是：set(元素)

<ul>
<li>交集：&amp;</li>
<li>并集：|</li>
<li>差集：-</li>
<li>消除重复元素：new=set(a)</li>
</ul>
</li>
<li>字典也叫关联数组，用大括号括起来

<ul>
<li>k={&ldquo;name&rdquo;:&ldquo;Java&rdquo;,&ldquo;IDE&rdquo;:&ldquo;Eclipse&rdquo;}</li>
<li>print k[&ldquo;IDE&rdquo;]</li>
<li>添加字典里面的项目k[&ldquo;User&rdquo;]=&ldquo;morris&rdquo;</li>
</ul>
</li>
<li>Python中的标识符第一个字符必须只能是字母或者下划线，之后的部分可以使字母，下划线或者数组</li>
<li>在Python中，如果有一些对象需要持久性存储，并且不丢失我们这个对象的类型与数据，我们需要将这些对象进行序列化，序列化之后，需要使用的时候我们再回复为原来的数据。序列化的这种过程我们称之为pickle（腌制）

<ul>
<li>import pickle</li>
<li>lista=[&ldquo;mingyue&rdquo;,&ldquo;jishi&rdquo;,&ldquo;you&rdquo;]</li>
<li>listb=pickle.dumps(lista)#序列化</li>
<li>listc=pickle.loads(listb)#将对象原样恢复</li>
<li>group1=(&ldquo;bajiu&rdquo;,&ldquo;wen&rdquo;,&ldquo;qingtian&rdquo;)</li>
<li>f1=file(&lsquo;1.pkl&rsquo;,&lsquo;wb&rsquo;)</li>
<li>pickle.dump(group1,f1,True)</li>
<li>f1.close()</li>
<li>f2=file(&lsquo;1.pkl&rsquo;,&lsquo;rb&rsquo;)</li>
<li>t=pickle.load(f2)</li>
<li>f2.close()</li>
</ul>
</li>
<li>Python的行连接符：\</li>
</ol>


<h2>数据类型</h2>

<ol>
<li>Python语言的类型有：数字类型，字符串类型，元组类型，列表类型，文件类型，字典类型</li>
<li>数字类型

<ol>
<li>复数类型的表示：z=a+bj,其中a是实数部分，b是虚数部分，a和b都是浮点类型</li>
</ol>
</li>
<li>字符串类型

<ol>
<li>假设字符串长度为L，那么字一个字符的序号为0或者-L，最后一字符的序号是L-1或者-1</li>
<li>字符串之间可以通过+或*进行连接，加法操作将两个字符串连接成为一个新的字符串，乘法操作构建一个由其本身字符串重复连接而成的字符串</li>
<li>大多数数据类型都可以通过str()函数转换为字符串</li>
<li>遍历字符串中每个字符：<code>for &lt;var&gt; in &lt;string&gt;</code>
<img src="http://i.imgur.com/s0unbao.png" alt="字符串处理方法" /></li>
</ol>
</li>
<li>元祖类型

<ol>
<li>元祖是包含多个元素的类型，元素之间用逗号分隔。元祖可以是空的，元祖外侧可以使用括号，也可以不使用</li>
<li>元祖中元素可以是不同类型，元组中各元素存在先后关系，可以通过索引访问元祖中元素，元祖定义后不能修改，也不能删除</li>
</ol>
</li>
<li>列表类型

<ol>
<li>列表与元祖类似，列表中每个元素可以不一样，访问列表中元素时采用索引形式</li>
<li>列表的大小没有限制，可以随时修改
<img src="http://i.imgur.com/d3bAmPU.png" alt="列表的操作" /></li>
</ol>
</li>
<li>文件类型

<ol>
<li>文件的打开模式
<img src="http://i.imgur.com/ojObujt.png" alt="文件的打开模式" /></li>
<li>文件读取
<img src="http://i.imgur.com/pmBgVxd.png" alt="文件读取" /></li>
<li>文件写入
<img src="http://i.imgur.com/n9jBYXM.png" alt="文件写入" /></li>
<li>遍历文件的模板
<img src="http://i.imgur.com/q0yCMAT.png" alt="遍历文件的模板" /></li>
</ol>
</li>
<li>字典

<ol>
<li>针对非序列集合而提供的一种数据类型</li>
<li>通过任意键值查找集合中信息的过程叫映射，python中通过字典实现映射。字典就是一个键值对的集合</li>
<li>使用大括号创建字典</li>
<li>使用中括号为字典增加一项：dictionaryName[key]=value</li>
<li>访问字典中的值：dictionaryName[key]返回键key对应的value</li>
<li>删除字典中的一项：del dictionaryName[key]</li>
<li>字典的遍历
<img src="http://i.imgur.com/PK0vmFN.png" alt="字典的遍历" /></li>
<li>判断一个键是否在字典中，可以使用命令in或者not in</li>
<li>字典的标准操作符
<img src="http://i.imgur.com/BsWzsmx.png" alt="字典的标准操作符" /></li>
<li>字典方法
<img src="http://i.imgur.com/9RX4ISh.png" alt="字典方法" /></li>
</ol>
</li>
</ol>


<h2>文件拷贝</h2>

<pre><code class="python">def main():
    f1 = input("Enter a source file name:").strip()
    f2 = input("Enter a destination file name:").strip()

    infile = open(f1, 'r')
    outfile = open(f2, 'w')

    count_lines = count_chars = 0
    for line in infile:
        count_lines += 1
        count_chars += len(line)
        outfile.write(line)

    print(count_lines, "lines and", count_chars, "chars copied")

    infile.close()
    outfile.close()


main()
</code></pre>

<h2>词频统计</h2>

<pre><code class="python"></code></pre>

<h2>数学库及其应用</h2>

<p><img src="http://i.imgur.com/ashlYUy.png" alt="数学库及其应用" /></p>

<h2>随机数库及其应用</h2>

<p><img src="http://i.imgur.com/s7wJNuN.png" alt="随机数库及其应用" /></p>

<h2>Python异常处理机制</h2>

<p>Python使用try&hellip;except&hellip;else&hellip;finally，可使程序不因运行错误而崩溃,异常捕获机制可以捕捉任何类型的错误，比如：输入非数值类型（NameError），输入无效的表达式(SyntaxError)等。只有当try中的语句没有发生异常，else语句才会被执行，finally无论有无异常都会被执行
<code>python
try:
    &lt;body&gt;
except &lt;ErrorType1&gt;:
    &lt;handler1&gt;
except &lt;ErrorType2&gt;:
    &lt;handler2&gt;
except:
    &lt;handler0&gt;
else:
    &lt;process_else&gt;
finally:
    &lt;process_finally&gt;
</code></p>

<h2>ETC</h2>

<ol>
<li>使用同步赋值语句实现x与y的值交换：x,y=y,x</li>
<li>val=pow(2,1000),用一行代码返回val结果的长度值:len(str(val))</li>
<li>布尔运算符的优先级从高到低依次是：not，and，or</li>
<li>对于数字的零值被认为是false，任何非零值都是true。对序列类型来说，空序列被认为是false，非空序列认为是true</li>
<li>常用编码

<ol>
<li>ASCII码是标准化字符集，用7个二进制位编码表示128个字符</li>
<li>Unicode跨语言，跨平台，同意且唯一的二进制编码，每个字符两个字节长</li>
<li>UTF8编码，可变长度的Unicode，英文对应1个字节，中文对应3个字节</li>
</ol>
</li>
<li>python中字符串类型未编码，可以用encode()进行编码，decode()进行解码
<img src="http://i.imgur.com/6CefLm3.png" alt="python中的编解码" /></li>
</ol>


<h2>turtle库的常用指令</h2>

<ol>
<li>turtle库以屏幕中心为坐标原点</li>
<li>forward（distance）将箭头移到某一指定坐标</li>
<li>left（angle）/right（angle）向左/右旋转一个角度</li>
<li>penup（）提起笔，用于另起一个地方绘制时使用，与pendown()配对使用</li>
<li>goto(x,y)</li>
<li>home()</li>
<li>circle(radius)</li>
<li>speed()</li>
</ol>


<h2>使用turtle库绘制五角星</h2>

<pre><code class="python">import turtle

p = turtle.Turtle()
p.speed(3)
p.pensize(5)
p.color("black")
p.fillcolor("red")
p.begin_fill()
for i in range(5):
    p.forward(200)
    p.right(144)
p.end_fill()
</code></pre>

<h2>使用turtle库绘制蟒蛇</h2>

<pre><code class="python">import turtle

def draw_snake(rad, angle, len, neckrad):
    for i in range(len):
        turtle.circle(rad, angle)
        turtle.circle(-rad, angle)
    turtle.circle(rad, angle, 2)
    turtle.fd(rad)
    turtle.circle(neckrad + 1, 180)
    turtle.fd(rad * 2 / 3)

def main():
    turtle.setup(1300, 800, 0, 0)
    pythonsize = 30
    turtle.pensize(pythonsize)
    turtle.pencolor("blue")
    turtle.seth(-40)
    draw_snake(40, 80, 5, pythonsize / 2)

main()
</code></pre>

<h2>使用turtle库绘制树</h2>

<pre><code class="python">import turtle


def tree(plist, l, a, f):
    """
    plist is a list of pens
    l is the length od branch
    a is half of angle between 2 branches
    f is factor by which branch is shortened from level to level
    """
    if l &gt; 5:
        lst = []
        for p in plist:
            p.forward(l)
            q = p.clone()
            p.left(a)
            q.right(a)
            lst.append(p)
            lst.append(q)
        tree(lst, l * f, a, f)


def maketree(x, y):
    p = turtle.Turtle()
    p.color("green")
    p.pensize(5)
    p.hideturtle()
    # p.speed(5)
    p.getscreen().tracer(30, 0)  # 调整绘画的速率
    p.left(90)
    p.penup()
    p.goto(x, y)
    p.pendown()
    tree([p], 110, 65, 0.707)


def main():
    turtle.title("使用turtle绘制树")
    turtle.setup(1200, 800, 0, 0)
    maketree(-300, -300)
    maketree(0, 0)
    maketree(300, -300)


main()
</code></pre>

<h2>数据驱动的动态路径绘制</h2>

<pre><code class="python">import turtle


def main():
    turtle.title("数据驱动的动态路径绘制")
    turtle.setup(800, 600, 0, 0)

    pen = turtle.Turtle()
    pen.color('red')
    pen.width(5)
    pen.shape("turtle")
    pen.speed(5)

    result = []
    file = open("a.txt", 'r')
    for line in file:
        result.append(list(map(float, line.split(','))))
    print(result)

    for i in range(len(result)):
        pen.color((result[i][3], result[i][4], result[i][5]))
        pen.forward(result[i][0])
        if result[i][1]:
            pen.right(result[i][2])
        else:
            pen.left(result[i][2])

    pen.goto(0, 0)


if __name__ == '__main__':
    main()
</code></pre>

<h2>使用蒙特卡洛方法估计圆周率的值</h2>

<pre><code class="python">from random import *
from math import  *
from time import *

DARTS = 1000000
hits = 0
clock()
for i in range(1,DARTS):
    x,y=random(),random()
    dist = sqrt(x**2+y**2)
    if(dist &lt;= 1.0):
        hits = hits+1
pi = 4*(hits/DARTS)
print("Pi的值是:%s"%pi)
print("程序运行时间是 %-5.5ss"%clock())
</code></pre>

<h2>寻找素数</h2>

<pre><code class="python">for n in range(2,100):
    for x in range(2,n):
        if n % x == 0:
            print(n, "equals", x, "*", n//x)
            break;
    else:
        print(n, "is a prime number")
</code></pre>

<h2>文件循环</h2>

<pre><code class="python">def main():
    file_name = input("What's the file path?")
    try:
        infile = open(file_name, 'r')
    except FileNotFoundError:
        print("\nFile not found")
    else:
        msum = 0.0
        count = 0
        line = infile.readline()
        while line != "":
            msum += eval(line)
            count += 1
            line = infile.readline()
        print("\nThe average of the numbers is", msum / count)


main()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cordova-Startup]]></title>
    <link href="http://suda-morris.github.io/blog/2015/05/28/cordova-startup/"/>
    <updated>2015-05-28T10:43:48+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/05/28/cordova-startup</id>
    <content type="html"><![CDATA[<h2>Cordova环境部署</h2>

<ul>
<li><a href="https://nodejs.org">安装nodejs</a>,注意添加到环境变量PATH中</li>
<li>安装Cordova CLI： npm install -g cordova</li>
<li><a href="http://java.oracle.com">安装Java JDK</a>,注意添加环境变量CLASSPATH，和PATH</li>
<li><a href="http://developer.android.com/sdk/index.html">安装Android SDK</a>，注意把platform-tools和tools添加到PATH环境变量</li>
<li><a href="http://ant.apache.org/">安装Ant</a>,注意把bin目录添加到PATH环境变量中</li>
<li>测试：

<ol>
<li>npm -v</li>
<li>java -version</li>
<li>adb version</li>
<li>ant -v</li>
<li>cordova -v</li>
</ol>
</li>
<li>cordova常用命令：

<ol>
<li><code>cordova creat 项目名称 包名 APP显示名称</code></li>
<li><code>cordova build</code></li>
<li><code>cordova run --device</code></li>
</ol>
</li>
</ul>


<h2>Cordova启动流程</h2>

<ol>
<li>原生代码启动</li>
<li>splashscreen</li>
<li>Load HTML</li>
<li>顺序执行JavaScript，执行$(document).ready()</li>
<li>Cordova.js执行(异步执行)</li>
<li>deviceready</li>
<li>Cordova插件可用</li>
</ol>


<p><img src="http://i.imgur.com/Nn7Krru.gif" alt="suda-morris" /></p>
]]></content>
  </entry>
  
</feed>
