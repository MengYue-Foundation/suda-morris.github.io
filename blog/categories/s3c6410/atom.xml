<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: s3c6410 | WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/blog/categories/s3c6410/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-06-15T15:03:54+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[raw_machine_code]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/14/raw-machine-code/"/>
    <updated>2015-06-14T19:39:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/14/raw-machine-code</id>
    <content type="html"><![CDATA[<h3>把外设的基地址告诉CPU</h3>

<pre><code class="C">ldr r0, =0x70000000                     //对于6410来说,内存(0x00000000～0x60000000),外设(0x70000000-0x7fffffff)
orr r0, r0, #0x13                       //外设大小:256M
mcr p15,0,r0,c15,c2,4                   //把r0的值(包括了外设基地址+外设大小)告诉cpu
</code></pre>

<h3>关看门狗</h3>

<pre><code class="C">ldr r0, =0x7E004000
mov r1, #0
str r1, [r0]
</code></pre>

<h3>是否开启icaches</h3>

<pre><code class="C">#ifdef  CONFIG_SYS_ICACHE_OFF
    bic r0, r0, #0x00001000                 @ clear bit 12 (I) I-cache
#else
    orr r0, r0, #0x00001000                 @ set bit 12 (I) I-cache
#endif
    mcr p15, 0, r0, c1, c0, 0
</code></pre>

<h3>死循环</h3>

<pre><code class="C">halt:
    b halt
</code></pre>

<blockquote><p>b与bl都是跳转指令，但是bl会把下一条指令的地址保存到寄存器lr中</p></blockquote>

<h3>Makefile</h3>

<pre><code class="C">led.bin : start.o clock.o led.o
    arm-linux-ld -T leds.lds -o led.elf start.o clock.o led.o
    arm-linux-objcopy -O binary led.elf led.bin
    arm-linux-objdump -D led.elf &gt; led.dis
%.o : %.S
    arm-linux-gcc -o $@ @&lt; -c
%.o : %.c
    arm-linux-gcc -o $@ @&lt; -c
clean:
    rm *.o led.elf led.bin led.dis
</code></pre>

<blockquote><ol>
<li>6410一上电后，nandflash前8K内容会被硬件原原本本地复制到片内的一个叫stepping stone的区域，该区域被映射到CPU内存地址0处</li>
<li>在ARM中，pc:r15,lr:r14,ip:r12,fp:r11</li>
</ol>
</blockquote>

<h3>CPU时钟设置</h3>

<pre><code class="C">clock_init:
    // 1. 设置各PLL的LOCK_TIME,使用默认值  
    ldr r0, =0x7E00F000                         // APLL_LOCK，供cpu使用 
    ldr r1, =0x0000FFFF
    str r1, [r0]

    str r1, [r0, #4]                            // MPLL_LOCK，供AHB(存储/中断/lcd等控制器)/APB(看门狗，定时器，SD等)总线上的设备使用 
    str r1, [r0, #8]                            // EPLL_LOCK，供UART,IIS,IIC使用 

    // 2. 设置为异步模式(Asynchronous mode)  
#define OTHERS  0x7E00F900
    ldr r0, =OTHERS                             // OTHERS
                                                // 《linux installation for u-boot》3.7中：用MPLL作为HCLK和PCLK的Source是异步(ASYNC)模式(当内存时钟与CPU时钟源不一样时需要设置成异步模式)
                                                // 用APLL是同步(SYNC)模式
    ldr r1, [r0]
    bic r1, r1, #0xc0                           // bit[6:7]清0,即SYNCMODE=0/SYNCMUXSEL=0
    str r1, [r0]
loop:           
    ldr r0, =OTHERS
    ldr r1, [r0]
    and r1, r1, #0xf00                  
    cmp r1, #0
    bne loop        

    // 3. 设置分频系数  
#define ARM_RATIO    0                          // ARMCLK   = DOUTAPLL / (ARM_RATIO + 1)    = 532/(0+1) = 532  MHz
#define MPLL_RATIO   0                          // DOUTMPLL = MOUTMPLL / (MPLL_RATIO + 1)   = 532/(0+1) = 532  MHz
#define HCLKX2_RATIO 1                          // HCLKX2   = HCLKX2IN / (HCLKX2_RATIO + 1) = 532/(1+1) = 266  MHz
#define HCLK_RATIO   1                          // HCLK     = HCLKX2   / (HCLK_RATIO + 1)   = 266/(1+1) = 133  MHz
#define PCLK_RATIO   3                          // PCLK     = HCLKX2   / (PCLK_RATIO + 1)   = 266/(3+1) = 66.5 MHz

    ldr r0, =0x7E00F020                         // CLK_DIV0
    ldr r1, =(ARM_RATIO) | (MPLL_RATIO &lt;&lt; 4) | (HCLK_RATIO &lt;&lt; 8) | (HCLKX2_RATIO &lt;&lt; 9) | (PCLK_RATIO &lt;&lt; 12)
    str r1, [r0]

    // 4. 设置PLL,放大时钟  
    // 4.1 配置APLL  
#define APLL_CON_VAL  ((1&lt;&lt;31) | (266 &lt;&lt; 16) | (3 &lt;&lt; 8) | (1)) 
    ldr r0, =0x7E00F00C                         // APLL_CON
    ldr r1, =APLL_CON_VAL                       // FOUT = MDIV X FIN / (PDIV X 2SDIV) = 266*12/(3*2^1) = 532MHz
    str r1, [r0]        

    // 4.2 配置MPLL  
#define MPLL_CON_VAL  ((1&lt;&lt;31) | (266 &lt;&lt; 16) | (3 &lt;&lt; 8) | (1))
    ldr r0, =0x7E00F010                         // MPLL_CON
    ldr r1, =MPLL_CON_VAL                       // FOUT = MDIV X FIN / (PDIV X 2SDIV) = 266*12/(3*2^1) = 532MHz
    str r1, [r0]        

#define MPLL_SEL 1
#define APLL_SEL 1  
    // 5.选择PLL的输出作为时钟源  
    ldr r0, =0x7E00F01C                         // CLK_SRC
    ldr r1, =(MPLL_SEL&lt;&lt;1) | (APLL_SEL&lt;&lt;0)
    str r1, [r0]

    mov pc, lr
</code></pre>

<h3>串口UART</h3>

<pre><code class="C">#define ULCON0     (*((volatile unsigned long *)0x7F005000))
#define UCON0      (*((volatile unsigned long *)0x7F005004))
#define UFCON0     (*((volatile unsigned long *)0x7F005008))
#define UMCON0     (*((volatile unsigned long *)0x7F00500C))
#define UTRSTAT0   (*((volatile unsigned long *)0x7F005010))
#define UFSTAT0    (*((volatile unsigned long *)0x7F005018))
#define UTXH0      (*((volatile unsigned char *)0x7F005020))
#define URXH0      (*((volatile unsigned char *)0x7F005024))
#define UBRDIV0    (*((volatile unsigned short *)0x7F005028))
#define UDIVSLOT0  (*((volatile unsigned short *)0x7F00502C))
#define GPACON     (*((volatile unsigned long *)0x7F008000))


void init_uart(void)
{
    /* 1. 配置引脚 */
    GPACON &amp;= ~0xff;
    GPACON |= 0x22;

    /* 2. 设置数据格式等 */
    ULCON0 = 0x3;                   // 数据位:8, 无校验, 停止位: 1, 8n1 
    UCON0  = 0x5;                   // 时钟：PCLK，禁止中断，使能UART发送、接收 
    UFCON0 = 0x01;                  // FIFO ENABLE
    UMCON0 = 0;                     // 无流控

    /* 3. 设置波特率 */
    // DIV_VAL = (PCLK / (bps x 16 ) ) - 1 = (66500000/(115200x16))-1 = 35.08
    // DIV_VAL = 35.08 = UBRDIVn + (num of 1’s in UDIVSLOTn)/16 
    UBRDIV0   = 35;
    UDIVSLOT0 = 0x1;

}

/* 接收一个字符 */
char getchar(void)
{
    while ((UFSTAT0 &amp; 0x7f) == 0);  // 如果RX FIFO空，等待 
    return URXH0;                   // 取数据 
}

/* 发送一个字符 */
void putchar(char c)
{
    while (UFSTAT0 &amp; (1&lt;&lt;14));      // 如果TX FIFO满，等待 
    UTXH0 = c;                      // 写数据 
}
</code></pre>

<h3>链接脚本</h3>

<pre><code class="C">SECTIONS
{
    . = 0x1000;                     /*当前地址*/
    .text : {
        start.o
        * (.text)
    }

    .data : {
        * (.data)
    }

    bss_start = .; 
    .bss : {                        /*二进制文件中并不包含bss数据*/
        * (.bss)
    }
    bss_end  = .;   
}
</code></pre>

<blockquote><ol>
<li>位置无关吗：跳转指令使用相对地址，如b和bl，并且程序中不使用全局变量,静态变量</li>
<li>程序运行时应该位于它的链接地址上</li>
</ol>
</blockquote>

<h3>DRAM控制器初始化</h3>

<pre><code class="C">#define MEMCCMD     0x7e001004
#define P1REFRESH   0x7e001010
#define P1CASLAT    0x7e001014
#define MEM_SYS_CFG 0x7e00f120
#define P1MEMCFG    0x7e00100c
#define P1T_DQSS    0x7e001018
#define P1T_MRD     0x7e00101c
#define P1T_RAS     0x7e001020
#define P1T_RC      0x7e001024
#define P1T_RCD     0x7e001028
#define P1T_RFC     0x7e00102c
#define P1T_RP      0x7e001030
#define P1T_RRD     0x7e001034
#define P1T_WR      0x7e001038
#define P1T_WTR     0x7e00103c
#define P1T_XP      0x7e001040
#define P1T_XSR     0x7e001044
#define P1T_ESR     0x7e001048
#define P1MEMCFG2   0X7e00104c
#define P1_chip_0_cfg   0x7e001200

#define P1MEMSTAT   0x7e001000
#define P1MEMCCMD   0x7e001004
#define P1DIRECTCMD 0x7e001008

#define HCLK    133000000

#define nstoclk(ns) ( ns/(1000000000/HCLK)+1 )          //+1是四舍五入

/* 根据6410手册P192页相关步骤和sdram手册来初始化dram控制器(dramc) */
int sdram_init( void )
{
    /* 1. 使dramc进入"config"状态 */
    set_val(P1MEMCCMD, 0x4);

    /* 2. 设置timing parameter, chip configuration,id configuration registers */
    /* 2.1 刷新周期 */
    set_val(P1REFRESH, nstoclk(7800));                  //刷新周期:(7.8us)/((1/HCLK)s)=(7.8*10^3)/(1/133*10^6)
    /* 2.2 时间参数，下列设置全都是取了最小值 */
    set_val( P1CASLAT, ( 3 &lt;&lt; 1 ) );                    //CAS Latency:指的是内存存取数据所需的延迟时间，简单的说，就是内存接到CPU的指令后的反应速度。一般的参数值是2和3两种。K4X1G163PQ的芯片手册上CAS Latency=3 
    set_val( P1T_DQSS, 0x1 );                           //下列设置均在sdram手册中可查询到              
    set_val( P1T_MRD, 0x2 );                            
    set_val( P1T_RAS, nstoclk(42) );                    
    set_val( P1T_RC, nstoclk(60) );     
    u32 trcd = nstoclk( 18 );                           
    set_val( P1T_RCD, trcd | (( trcd - 3 ) &lt;&lt; 3 ) );
    u32 trfc = nstoclk( 72 );
    set_val( P1T_RFC, trfc | ( ( trfc-3 ) &lt;&lt; 5 ) );   
    u32 trp = nstoclk( 18 );
    set_val( P1T_RP, trp | ( ( trp - 3 ) &lt;&lt; 3 ) ); 
    set_val( P1T_RRD, nstoclk(12) );
    set_val( P1T_WR, nstoclk(12) );

    set_val( P1T_WTR, 0x1 );
    set_val( P1T_XP, 0x1 );
    set_val( P1T_XSR, nstoclk(120) );
    set_val( P1T_ESR, nstoclk(120) );

    /* 2.3 chip configuration */
    set_nbit( P1MEMCFG, 0, 3, 0x2 );                    // column address(10):A0~A9
    set_nbit( P1MEMCFG, 3, 3, 0x3 );                    // row address(14):A0~A13
    set_zero( P1MEMCFG, 6 );                            // A10/AP 
    set_nbit( P1MEMCFG, 15, 3, 0x2 );                   //  Burst Length (2, 4, 8, 16)
    set_nbit( P1MEMCFG2, 0, 4, 0x5 );
    set_2bit( P1MEMCFG2, 6, 0x1 );                      // 32 bit 
    set_nbit( P1MEMCFG2, 8, 3, 0x3 );                   // Mobile DDR SDRAM     
    set_2bit( P1MEMCFG2, 11, 0x1 );
    set_one( P1_chip_0_cfg, 16 );                       // Bank-Row-Column organization 

    /* 3. 初始化sdram */
    set_val( P1DIRECTCMD, 0xc0000 );                    // NOP
    set_val( P1DIRECTCMD, 0x000 );                      // precharge
    set_val( P1DIRECTCMD, 0x40000 );                    // auto refresh
    set_val( P1DIRECTCMD, 0x40000 );                    // auto refresh
    set_val( P1DIRECTCMD, 0xa0000 );                    // EMRS
    set_val( P1DIRECTCMD, 0x80032 );                    // MRS

    set_val( MEM_SYS_CFG, 0x0 );

    /* 4. 使dramc进入"ready"状态   */
    set_val( P1MEMCCMD, 0x000 );
    while( !(( read_val( P1MEMSTAT ) &amp; 0x3 ) == 0x1));// 等待dramc进入"ready"状态     
}
</code></pre>
]]></content>
  </entry>
  
</feed>
