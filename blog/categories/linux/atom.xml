<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-06-14T22:39:01+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[raw_machine_code]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/14/raw-machine-code/"/>
    <updated>2015-06-14T19:39:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/14/raw-machine-code</id>
    <content type="html"><![CDATA[<h3>把外设的基地址告诉CPU</h3>

<pre><code class="C">ldr r0, =0x70000000                     //对于6410来说,内存(0x00000000～0x60000000),外设(0x70000000-0x7fffffff)
orr r0, r0, #0x13                       //外设大小:256M
mcr p15,0,r0,c15,c2,4                   //把r0的值(包括了外设基地址+外设大小)告诉cpu
</code></pre>

<h3>关看门狗</h3>

<pre><code class="C">ldr r0, =0x7E004000
mov r1, #0
str r1, [r0]
</code></pre>

<h3>死循环</h3>

<pre><code class="C">halt:
    b halt
</code></pre>

<blockquote><p>b与bl都是跳转指令，但是bl会把下一条指令的地址保存到寄存器lr中</p>

<h3>Makefile</h3>

<pre><code class="C">led.bin : start.o
    arm-linux-ld -Ttext 0 -o led.elf start.o
    arm-linux-objcopy -O binary led.elf led.bin
    arm-linux-objdump -D led.elf &gt; led.dis
start.o : start.S
    arm-linux-gcc -c -O start.o start.S
clean:
    rm *.o led.elf led.bin led.dis
</code></pre>

<ol>
<li>6410一上电后，nandflash前8K内容会被硬件原原本本地复制到片内的一个叫stepping stone的区域，该区域被映射到CPU内存地址0处</li>
<li>在ARM中，pc:r15,lr:r14,ip:r12,fp:r11</li>
</ol>
</blockquote>

<h3>CPU时钟设置</h3>

<pre><code class="C">clock_init:
    // 1. 设置各PLL的LOCK_TIME,使用默认值  
    ldr r0, =0x7E00F000                         // APLL_LOCK，供cpu使用 
    ldr r1, =0x0000FFFF
    str r1, [r0]

    str r1, [r0, #4]                            // MPLL_LOCK，供AHB(存储/中断/lcd等控制器)/APB(看门狗，定时器，SD等)总线上的设备使用 
    str r1, [r0, #8]                            // EPLL_LOCK，供UART,IIS,IIC使用 

    // 2. 设置为异步模式(Asynchronous mode)  
#define OTHERS  0x7E00F900
    ldr r0, =OTHERS                             // OTHERS
                                                // 《linux installation for u-boot》3.7中：用MPLL作为HCLK和PCLK的Source是异步(ASYNC)模式
                                                // 用APLL是同步(SYNC)模式
    ldr r1, [r0]
    bic r1, r1, #0xc0                           // bit[6:7]清0,即SYNCMODE=0/SYNCMUXSEL=0
    str r1, [r0]
loop:           
    ldr r0, =0x7E00F900
    ldr r1, [r0]
    and r1, r1, #0xf00                  
    cmp r1, #0
    bne loop        

    // 3. 设置分频系数  
#define ARM_RATIO    0                          // ARMCLK   = DOUTAPLL / (ARM_RATIO + 1)    = 532/(0+1) = 532  MHz
#define MPLL_RATIO   0                          // DOUTMPLL = MOUTMPLL / (MPLL_RATIO + 1)   = 532/(0+1) = 532  MHz
#define HCLKX2_RATIO 1                          // HCLKX2   = HCLKX2IN / (HCLKX2_RATIO + 1) = 532/(1+1) = 266  MHz
#define HCLK_RATIO   1                          // HCLK     = HCLKX2   / (HCLK_RATIO + 1)   = 266/(1+1) = 133  MHz
#define PCLK_RATIO   3                          // PCLK     = HCLKX2   / (PCLK_RATIO + 1)   = 266/(3+1) = 66.5 MHz

    ldr r0, =0x7E00F020                         // CLK_DIV0
    ldr r1, =(ARM_RATIO) | (MPLL_RATIO &lt;&lt; 4) | (HCLK_RATIO &lt;&lt; 8) | (HCLKX2_RATIO &lt;&lt; 9) | (PCLK_RATIO &lt;&lt; 12)
    str r1, [r0]

    // 4. 设置PLL,放大时钟  
    // 4.1 配置APLL  
#define APLL_CON_VAL  ((1&lt;&lt;31) | (266 &lt;&lt; 16) | (3 &lt;&lt; 8) | (1))
    ldr r0, =0x7E00F00C                         // APLL_CON
    ldr r1, =APLL_CON_VAL                       // FOUT = MDIV X FIN / (PDIV X 2SDIV) = 266*12/(3*2^1) = 532MHz
    str r1, [r0]        

    // 4.2 配置MPLL  
#define MPLL_CON_VAL  ((1&lt;&lt;31) | (266 &lt;&lt; 16) | (3 &lt;&lt; 8) | (1))
    ldr r0, =0x7E00F010                         // MPLL_CON
    ldr r1, =MPLL_CON_VAL                       // FOUT = MDIV X FIN / (PDIV X 2SDIV) = 266*12/(3*2^1) = 532MHz
    str r1, [r0]        

#define MPLL_SEL 1
#define APLL_SEL 1  
    // 5.选择PLL的输出作为时钟源  
    ldr r0, =0x7E00F01C                         // CLK_SRC
    ldr r1, =(MPLL_SEL&lt;&lt;1) | (APLL_SEL&lt;&lt;0)
    str r1, [r0]

    mov pc, lr
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[start.S]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/13/start-dot-s/"/>
    <updated>2015-06-13T23:15:44+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/13/start-dot-s</id>
    <content type="html"><![CDATA[<pre><code class="C start.S">#include &lt;config.h&gt;
#include &lt;version.h&gt;
#ifdef CONFIG_ENABLE_MMU
#include &lt;asm/proc/domain.h&gt;
#endif
#include &lt;regs.h&gt;

#ifndef CONFIG_ENABLE_MMU
#ifndef CFG_PHY_UBOOT_BASE
#define CFG_PHY_UBOOT_BASE  CFG_UBOOT_BASE
#endif
#endif

/*
 *************************************************************************
 *
 * Jump vector table as in table 3.1 in [1]
 *
 *************************************************************************
 */

.globl _start
_start: b   reset
    ldr pc, _undefined_instruction
    ldr pc, _software_interrupt
    ldr pc, _prefetch_abort
    ldr pc, _data_abort
    ldr pc, _not_used
    ldr pc, _irq
    ldr pc, _fiq

_undefined_instruction:
    .word undefined_instruction
_software_interrupt:
    .word software_interrupt
_prefetch_abort:
    .word prefetch_abort
_data_abort:
    .word data_abort
_not_used:
    .word not_used
_irq:
    .word irq
_fiq:
    .word fiq
_pad:
    .word 0x12345678 /* now 16*4=64 */
.global _end_vect
_end_vect:

    .balignl 16,0xdeadbeef
/*
 *************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * setup Memory and board specific bits prior to relocation.
 * relocate armboot to ram
 * setup stack
 *
 *************************************************************************
 */

_TEXT_BASE:
    .word   TEXT_BASE

/*
 * Below variable is very important because we use MMU in U-Boot.
 * Without it, we cannot run code correctly before MMU is ON.
 * by scsuh.
 */
_TEXT_PHY_BASE:
    .word   CFG_PHY_UBOOT_BASE

.globl _armboot_start
_armboot_start:
    .word _start

/*
 * These are defined in the board-specific linker script.
 */
.globl _bss_start
_bss_start:
    .word __bss_start

.globl _bss_end
_bss_end:
    .word _end

#ifdef CONFIG_USE_IRQ
/* IRQ stack memory (calculated at run-time) */
.globl IRQ_STACK_START
IRQ_STACK_START:
    .word   0x0badc0de

/* IRQ stack memory (calculated at run-time) */
.globl FIQ_STACK_START
FIQ_STACK_START:
    .word 0x0badc0de
#endif

/*
 * the actual reset code
 */

reset:
    /*
     * set the cpu to SVC32 mode
     */
    mrs r0,cpsr
    bic r0,r0,#0x1f
    orr r0,r0,#0xd3
    msr cpsr,r0

/*
 *************************************************************************
 *
 * CPU_init_critical registers
 *
 * setup important registers
 * setup memory timing
 *
 *************************************************************************
 */
         /*
         * we do sys-critical inits only at reboot,
         * not when booting from ram!
         */
cpu_init_crit:
    /*
     * flush v4 I/D caches
     */
    mov r0, #0
    mcr p15, 0, r0, c7, c7, 0   /* flush v3/v4 cache */
    mcr p15, 0, r0, c8, c7, 0   /* flush v4 TLB */

    /*
     * disable MMU stuff and caches
     */
    mrc p15, 0, r0, c1, c0, 0
    bic r0, r0, #0x00002300 @ clear bits 13, 9:8 (--V- --RS)
    bic r0, r0, #0x00000087 @ clear bits 7, 2:0 (B--- -CAM)
    orr r0, r0, #0x00000002 @ set bit 2 (A) Align
    orr r0, r0, #0x00001000 @ set bit 12 (I) I-Cache
    mcr p15, 0, r0, c1, c0, 0

    /* Peri port setup */
    ldr r0, =0x70000000
    orr r0, r0, #0x13
    mcr p15,0,r0,c15,c2,4       @ 256M(0x70000000-0x7fffffff)

#ifdef CONFIG_BOOT_ONENAND
    ldr r0, =0x70000000     @ onenand controller setup
    orr r0, r0, #0x100000
    ldr r1, =0x4000
    orr r1, r1, #0xe0
    str r1, [r0]

#if defined(CONFIG_S3C6410) || defined(CONFIG_S3C6430)
    orr r0, r0, #300        @ disable watchdog
    mov r1, #1
    str r1, [r0]

    mov r1, #0x23000000     @ start buffer register
    orr r1, r1, #0x30000
    orr r1, r1, #0xc800
#else
    mov r1, =0x20000000     @ start buffer register
    orr r1, r1, #0xc30000
    orr r1, r1, #0xc800
#endif

    sub r0, r1, #0x0400     @ start address1 register

    ldr r2, [r1, #0x84]     @ ecc bypass
    orr r2, r2, #0x100
    str r2, [r1, #0x84]

    mov r3, #0x0        @ DFS, FBA
    str r3, [r0, #0x00]
    str r3, [r0, #0x04]     @ select dataram for DDP as 0

    mov r4, #0x104      @ interrupt register
    mov r5, #0x0002     @ FPA, FSA
    mov r6, #0x0800     @ BSA

onenand_bl1_load:
    str r5, [r0, #0x1c]     @ save FPA, FSA
    orr r6, r6, #0x02       @ BSC
    str r6, [r1, #0x00]     @ save BSA, BSC
    str r3, [r1, r4]        @ clear interrupt
    str r3, [r1, #0x80]     @ write load command

    mov r7, #0x100      @ need small delay

onenand_wait_loop1:
    subs    r7, r7, #0x1
    bne onenand_wait_loop1

    add r5, r5, #0x2        @ next FPA, FSA
    sub r6, r6, #0x2
    add r6, r6, #0x200      @ next BSA
    cmp r5, #0x8
    bne onenand_bl1_load
#endif

    /*
     * Go setup Memory and board specific bits prior to relocation.
     */
    bl  lowlevel_init   /* go setup pll,mux,memory */

    /* when we already run in ram, we don't need to relocate U-Boot.
     * and actually, memory controller must be configured before U-Boot
     * is running in ram.
     */
    ldr r0, =0xff000fff
    bic r1, pc, r0      /* r0 &lt;- current base addr of code */
    ldr r2, _TEXT_BASE      /* r1 &lt;- original base addr in ram */
    bic r2, r2, r0      /* r0 &lt;- current base addr of code */
    cmp     r1, r2                  /* compare r0, r1                  */
    beq     after_copy      /* r0 == r1 then skip flash copy   */

#ifdef CONFIG_BOOT_NOR          /* relocate U-Boot to RAM */
    adr r0, _start      /* r0 &lt;- current position of code   */
    ldr r1, _TEXT_PHY_BASE  /* r1 &lt;- destination                */
    ldr r2, _armboot_start
    ldr r3, _bss_start
    sub r2, r3, r2      /* r2 &lt;- size of armboot            */
    add r2, r0, r2      /* r2 &lt;- source end address         */

nor_copy_loop:
    ldmia   r0!, {r3-r10}       /* copy from source address [r0]    */
    stmia   r1!, {r3-r10}       /* copy to   target address [r1]    */
    cmp r0, r2          /* until source end addreee [r2]    */
    ble nor_copy_loop
    b   after_copy
#endif

#ifdef CONFIG_BOOT_NAND
    mov r0, #0x1000
    bl  copy_from_nand
#endif

#ifdef CONFIG_BOOT_MOVINAND
    ldr sp, _TEXT_PHY_BASE
    bl  movi_bl2_copy
    b   after_copy
#endif

#ifdef CONFIG_BOOT_ONENAND
    ldr sp, =0x50000000     @ temporary stack

#ifdef CONFIG_S3C6400
    mov r1, =0x20000000     @ start buffer register
    orr r1, r1, #0xc30000
    orr r1, r1, #0xc800
#else
    mov r1, #0x23000000     @ start buffer register
    orr r1, r1, #0x30000
    orr r1, r1, #0xc800
#endif

    ldr r2, [r1, #0x84]     @ ecc bypass
    orr r2, r2, #0x100
    str r2, [r1, #0x84]

    sub r0, r1, #0x0400     @ start address1 register

    str r3, [r0, #0x00]
    str r3, [r0, #0x04]     @ select dataram for DDP as 0

    mov r4, #0x104      @ interrupt register

    mov r6, #0x0c00     @ fixed dataram1 sector number
    str r6, [r1, #0x00]

    mov r3, #0x0        @ DFS, FBA
    mov r5, #0x0000     @ FPA, FSA
    ldr r9, =CFG_PHY_UBOOT_BASE @ destination

onenand_bl2_load:
    str r3, [r0, #0x00]     @ save DFS, FBA
    str r5, [r0, #0x1c]     @ save FPA, FSA

    mov r7, #0x0        @ clear interrupt
    str r7, [r1, r4]
    str r7, [r1, #0x80]     @ write load command

    mov r8, #0x1000
onenand_wait_loop2:
    subs    r8, r8, #0x1
    bne onenand_wait_loop2

onenand_wait_int:           @ wait INT and RI
    ldr r7, [r1, r4]
    mov r8, #0x8000
    orr r8, r8, #0x80
    tst r7, r8
    beq onenand_wait_int

    mov r7, #0x0        @ clear interrupt
    str r7, [r1, r4]

    mov r8, #0xc00      @ source address (dataram1)
    mov r10, #0x40      @ copy loop count (64 = 2048 / 32)

    stmia   sp, {r0-r7}     @ backup

onenand_copy_to_ram:
    ldmia   r8!, {r0-r7}
    stmia   r9!, {r0-r7}
    subs    r10, r10, #0x1
    bne onenand_copy_to_ram

    ldmia   sp, {r0-r7}     @ restore

    add r5, r5, #0x4        @ next FPA
    cmp r5, #0x100      @ last FPA?
    bne onenand_bl2_load

    /* next block */
    mov r5, #0x0        @ reset FPA
    add r3, r3, #0x1        @ next FBA
    cmp r3, #0x2        @ last FBA?
    bne onenand_bl2_load
    b   after_copy
#endif

#ifdef CONFIG_BOOT_ONENAND_IROM
    ldr sp, _TEXT_PHY_BASE
    bl  onenand_bl2_copy
    b   after_copy
#endif

after_copy:
    ldr r0, =ELFIN_GPIO_BASE
    ldr r1, =0xC00
    str r1, [r0, #GPPDAT_OFFSET]
    ldr r1, [r0, #GPFPUD_OFFSET]
    bic r1, r1, #0xc0000000
    orr r1, r1, #0x80000000
    str r1, [r0, #GPFPUD_OFFSET]
    ldr r1, [r0, #GPFDAT_OFFSET]
    orr r1, r1, #0x8000
    str r1, [r0, #GPFDAT_OFFSET]
    ldr r1, [r0, #GPFCON_OFFSET]
    bic r1, r1, #0xc0000000
    orr r1, r1, #0x40000000
    str r1, [r0, #GPFCON_OFFSET]


#ifdef CONFIG_ENABLE_MMU
enable_mmu:
    /* enable domain access */
    ldr r5, =0x0000ffff
    mcr p15, 0, r5, c3, c0, 0       @ load domain access register

    /* Set the TTB register */
    ldr r0, _mmu_table_base
    ldr r1, =CFG_PHY_UBOOT_BASE
    ldr r2, =0xfff00000
    bic r0, r0, r2
    orr r1, r0, r1
    mcr p15, 0, r1, c2, c0, 0

    /* Enable the MMU */
mmu_on:
    mrc p15, 0, r0, c1, c0, 0
    orr r0, r0, #1          /* Set CR_M to enable MMU */
    mcr p15, 0, r0, c1, c0, 0
    nop
    nop
    nop
    nop
#endif

skip_hw_init:
    /* Set up the stack                         */
stack_setup:
#ifdef CONFIG_MEMORY_UPPER_CODE
    ldr sp, =(CFG_UBOOT_BASE + CFG_UBOOT_SIZE - 0xc)
#else
    ldr r0, _TEXT_BASE      /* upper 128 KiB: relocated uboot   */
    sub r0, r0, #CFG_MALLOC_LEN /* malloc area                      */
    sub r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
#ifdef CONFIG_USE_IRQ
    sub r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
#endif
    sub sp, r0, #12     /* leave 3 words for abort-stack    */

#endif

clear_bss:
    ldr r0, _bss_start      /* find start of bss segment        */
    ldr r1, _bss_end        /* stop here                        */
    mov     r2, #0x00000000     /* clear                            */

clbss_l:
    str r2, [r0]        /* clear loop...                    */
    add r0, r0, #4
    cmp r0, r1
    ble clbss_l

    ldr pc, _start_armboot

_start_armboot:
    .word start_armboot

#ifdef CONFIG_ENABLE_MMU
_mmu_table_base:
    .word mmu_table
#endif

/*
 * copy U-Boot to SDRAM and jump to ram (from NAND or OneNAND)
 * r0: size to be compared
 * Load 1'st 2blocks to RAM because U-boot's size is larger than 1block(128k) size
 */
    .globl copy_from_nand
copy_from_nand:
    mov r10, lr     /* save return address */

    mov r9, r0
    /* get ready to call C functions */
    ldr sp, _TEXT_PHY_BASE  /* setup temp stack pointer */
    sub sp, sp, #12
    mov fp, #0          /* no previous frame, so fp=0 */
    mov r9, #0x1000
    bl  copy_uboot_to_ram

3:  tst     r0, #0x0
    bne copy_failed

    ldr r0, =0x0c000000
    ldr r1, _TEXT_PHY_BASE
1:  ldr r3, [r0], #4
    ldr r4, [r1], #4
    teq r3, r4
    bne compare_failed  /* not matched */
    subs    r9, r9, #4
    bne 1b

4:  mov lr, r10     /* all is OK */
    mov pc, lr

copy_failed:
    nop         /* copy from nand failed */
    b   copy_failed

compare_failed:
    nop         /* compare failed */
    b   compare_failed

/*
 * we assume that cache operation is done before. (eg. cleanup_before_linux())
 * actually, we don't need to do anything about cache if not use d-cache in U-Boot
 * So, in this function we clean only MMU. by scsuh
 *
 * void theLastJump(void *kernel, int arch_num, uint boot_params);
 */
#ifdef CONFIG_ENABLE_MMU
    .globl theLastJump
theLastJump:
    mov r9, r0
    ldr r3, =0xfff00000
    ldr r4, _TEXT_PHY_BASE
    adr r5, phy_last_jump
    bic r5, r5, r3
    orr r5, r5, r4
    mov pc, r5
phy_last_jump:
    /*
     * disable MMU stuff
     */
    mrc p15, 0, r0, c1, c0, 0
    bic r0, r0, #0x00002300 /* clear bits 13, 9:8 (--V- --RS) */
    bic r0, r0, #0x00000087 /* clear bits 7, 2:0 (B--- -CAM) */
    orr r0, r0, #0x00000002 /* set bit 2 (A) Align */
    orr r0, r0, #0x00001000 /* set bit 12 (I) I-Cache */
    mcr p15, 0, r0, c1, c0, 0

    mcr p15, 0, r0, c8, c7, 0   /* flush v4 TLB */

    mov r0, #0
    mov pc, r9
#endif
/*
 *************************************************************************
 *
 * Interrupt handling
 *
 *************************************************************************
 */
@
@ IRQ stack frame.
@
#define S_FRAME_SIZE    72

#define S_OLD_R0    68
#define S_PSR       64
#define S_PC        60
#define S_LR        56
#define S_SP        52

#define S_IP        48
#define S_FP        44
#define S_R10       40
#define S_R9        36
#define S_R8        32
#define S_R7        28
#define S_R6        24
#define S_R5        20
#define S_R4        16
#define S_R3        12
#define S_R2        8
#define S_R1        4
#define S_R0        0

#define MODE_SVC 0x13
#define I_BIT    0x80

/*
 * use bad_save_user_regs for abort/prefetch/undef/swi ...
 * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
 */

    .macro  bad_save_user_regs
    sub sp, sp, #S_FRAME_SIZE       @ carve out a frame on current user stack
    stmia   sp, {r0 - r12}          @ Save user registers (now in svc mode) r0-r12

    ldr r2, _armboot_start
    sub r2, r2, #(CFG_MALLOC_LEN)
    sub r2, r2, #(CFG_GBL_DATA_SIZE+8)  @ set base 2 words into abort stack
    ldmia   r2, {r2 - r3}           @ get values for "aborted" pc and cpsr (into parm regs)
    add r0, sp, #S_FRAME_SIZE       @ grab pointer to old stack

    add r5, sp, #S_SP
    mov r1, lr
    stmia   r5, {r0 - r3}           @ save sp_SVC, lr_SVC, pc, cpsr
    mov r0, sp              @ save current stack into r0 (param register)
    .endm

    .macro  irq_save_user_regs
    sub sp, sp, #S_FRAME_SIZE
    stmia   sp, {r0 - r12}          @ Calling r0-r12
    add r8, sp, #S_PC           @ !!!! R8 NEEDS to be saved !!!! a reserved stack spot would be good.
    stmdb   r8, {sp, lr}^           @ Calling SP, LR
    str lr, [r8, #0]            @ Save calling PC
    mrs r6, spsr
    str r6, [r8, #4]            @ Save CPSR
    str r0, [r8, #8]            @ Save OLD_R0
    mov r0, sp
    .endm

    .macro  irq_restore_user_regs
    ldmia   sp, {r0 - lr}^          @ Calling r0 - lr
    mov r0, r0
    ldr lr, [sp, #S_PC]         @ Get PC
    add sp, sp, #S_FRAME_SIZE
    subs    pc, lr, #4          @ return &amp; move spsr_svc into cpsr
    .endm

    .macro get_bad_stack
    ldr r13, _armboot_start     @ setup our mode stack (enter in banked mode)
    sub r13, r13, #(CFG_MALLOC_LEN) @ move past malloc pool
    sub r13, r13, #(CFG_GBL_DATA_SIZE+8) @ move to reserved a couple spots for abort stack

    str lr, [r13]           @ save caller lr in position 0 of saved stack
    mrs lr, spsr            @ get the spsr
    str lr, [r13, #4]           @ save spsr in position 1 of saved stack

    mov r13, #MODE_SVC          @ prepare SVC-Mode
    @ msr   spsr_c, r13
    msr spsr, r13           @ switch modes, make sure moves will execute
    mov lr, pc              @ capture return pc
    movs    pc, lr              @ jump to next instruction &amp; switch modes.
    .endm

    .macro get_bad_stack_swi
    sub r13, r13, #4            @ space on current stack for scratch reg.
    str r0, [r13]           @ save R0's value.
    ldr r0, _armboot_start      @ get data regions start
    sub r0, r0, #(CFG_MALLOC_LEN)   @ move past malloc pool
    sub r0, r0, #(CFG_GBL_DATA_SIZE+8)  @ move past gbl and a couple spots for abort stack
    str lr, [r0]            @ save caller lr in position 0 of saved stack
    mrs r0, spsr            @ get the spsr
    str lr, [r0, #4]            @ save spsr in position 1 of saved stack
    ldr r0, [r13]           @ restore r0
    add r13, r13, #4            @ pop stack entry
    .endm

    .macro get_irq_stack            @ setup IRQ stack
    ldr sp, IRQ_STACK_START
    .endm

    .macro get_fiq_stack            @ setup FIQ stack
    ldr sp, FIQ_STACK_START
    .endm

/*
 * exception handlers
 */
    .align  5
undefined_instruction:
    get_bad_stack
    bad_save_user_regs
    bl  do_undefined_instruction

    .align  5
software_interrupt:
    get_bad_stack_swi
    bad_save_user_regs
    bl  do_software_interrupt

    .align  5
prefetch_abort:
    get_bad_stack
    bad_save_user_regs
    bl  do_prefetch_abort

    .align  5
data_abort:
    get_bad_stack
    bad_save_user_regs
    bl  do_data_abort

    .align  5
not_used:
    get_bad_stack
    bad_save_user_regs
    bl  do_not_used

#ifdef CONFIG_USE_IRQ

    .align  5
irq:
    get_irq_stack
    irq_save_user_regs
    bl  do_irq
    irq_restore_user_regs

    .align  5
fiq:
    get_fiq_stack
    /* someone ought to write a more effiction fiq_save_user_regs */
    irq_save_user_regs
    bl  do_fiq
    irq_restore_user_regs

#else

    .align  5
irq:
    get_bad_stack
    bad_save_user_regs
    bl  do_irq

    .align  5
fiq:
    get_bad_stack
    bad_save_user_regs
    bl  do_fiq

#endif
    .align 5
.global arm1136_cache_flush
arm1136_cache_flush:
        mcr p15, 0, r1, c7, c5, 0   @ invalidate I cache
        mov pc, lr          @ back to caller

#if defined(CONFIG_INTEGRATOR) &amp;&amp; defined(CONFIG_ARCH_CINTEGRATOR)
/* Use the IntegratorCP function from board/integratorcp/platform.S */
#elif defined(CONFIG_S3C64XX)
/* For future usage of S3C64XX*/
#else
    .align  5
.globl reset_cpu
reset_cpu:
    ldr r1, rstctl  /* get addr for global reset reg */
    mov r3, #0x2    /* full reset pll+mpu */
    str r3, [r1]    /* force reset */
    mov r0, r0
_loop_forever:
    b   _loop_forever
rstctl:
    .word   PM_RSTCTRL_WKUP

#endif
</code></pre>

<p><img src="http://i.imgur.com/Nn7Krru.gif" alt="suda-morris" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[u-boot.lds]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/13/u-boot-dot-lds/"/>
    <updated>2015-06-13T23:06:13+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/13/u-boot-dot-lds</id>
    <content type="html"><![CDATA[<pre><code class="C u-boot.lds">OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
    . = 0x00000000;
    . = ALIGN(4);
    .text      :
    {
      cpu/s3c64xx/start.o   (.text)
      cpu/s3c64xx/s3c6410/cpu_init.o    (.text)
      cpu/s3c64xx/onenand_cp.o  (.text)
      cpu/s3c64xx/nand_cp.o (.text)
      board/samsung/mini6410/nand_6410.fo
      cpu/s3c64xx/movi.o (.text)
      *(.text)
      lib_arm/div0.o
    }
    . = ALIGN(4);
    .rodata : { *(.rodata) }
    . = ALIGN(4);
    .data : { *(.data) }
    . = ALIGN(4);
    .got : { *(.got) }
    __u_boot_cmd_start = .;
    .u_boot_cmd : { *(.u_boot_cmd) }
    __u_boot_cmd_end = .;
    . = ALIGN(4);
    .mmudata : { *(.mmudata) }
    . = ALIGN(4);
    __bss_start = .;
    .bss : { *(.bss) }
    _end = .;
}
</code></pre>

<p><img src="http://i.imgur.com/Nn7Krru.gif" alt="suda-morris" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KDM-DevEnv]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/08/kdm-devenv/"/>
    <updated>2015-06-08T22:30:05+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/08/kdm-devenv</id>
    <content type="html"><![CDATA[<h2>需要知道的知识点</h2>

<ol>
<li>ext4文件系统是Linux在PC机上最常用的磁盘文件系统，在嵌入式设备上则常用jffs2文件系统和yaffs2文件系统</li>
<li>在Linux操作系统中。对于SCSI磁盘。用sd*来表示，第一个磁盘x为a，第二个磁盘x为b，以此类推。磁盘上的第1个分区编号为1，第2个分区编号为2，以此类推。</li>
<li>swap分区用于Linux在运行期间的虚拟内存使用，其作用类似Windows中的交换文件pagefile.sys</li>
<li>ARM core的CPU在复位时通常都从0地址取它的第一条指令

<h2>开发环境搭建</h2>

<blockquote><ol>
<li>所使用的虚拟机是VirtualBox4.3.12，安装的虚拟机是UbuntuMate14.04</li>
<li>使用的开发板是友善出品的Tiny6410</li>
<li>虚拟机网络设置成桥接模式(笔记本的以太网卡，切勿错选成无线网卡)</li>
<li>虚拟机ip地址：192.168.1.88，网关192.168.1.1</li>
</ol>
</blockquote></li>
</ol>


<h2>系统烧写</h2>

<ol>
<li>Uboot中开发板的IP地址:192.168.1.230,网关192.168.1.1</li>
<li>开发板设置从SD卡启动，需要确保有一张烧写好UBoot的SD卡或者SDHC卡，Linux中的烧写方法：
```

<h1>!/bin/sh</h1>

<h1>for SDHC Card,total sectors=15523840</h1>

<h1>dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=16 seek=15522798</h1>

<h1>dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=512 seek=15522030</h1></li>
</ol>


<h1>for SD Card,total sectors=1961984</h1>

<p>dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=16 seek=1961966
dd iflag=dsync oflag=dsync if=u-boot-sd.bin of=/dev/sdb bs=512 count=512 seek=1961198
sync</p>

<h1>BL1:total sectors - 2 - 1024(if your SD Card Size > 2G) -16</h1>

<h1>BL2:total sectors - 2 - 1024(if your SD Card Size > 2G) -16 - 512 - 256</h1>

<p>```</p>

<ol>
<li>进入Uboot后，测试能否ping通虚拟主机：ping 192.168.1.88。在这之前可以先看看开发板的IP地址是否与虚拟主机在一个网段内，使用UBoot下的命令：pri</li>
<li>使用nfs命令获取虚拟主机上的uboot二进制文件供烧写(次UBoot是用来从NandFlash启动的，不能错选从SD卡启动的UBoot),成功以后会提示用户该文件的大小，这里记为filesize(切记要使用十六进制表示的数字)

<ul>
<li>nfs 50000000 192.168.1.88:/embeded/KDM/images/v1/u-boot.bin</li>
</ul>
</li>
<li>烧写uboot至NandFlash中

<ul>
<li>nand write.i 50000000 0 $(filesize)   从0地址开始烧写UBoot</li>
</ul>
</li>
<li>使用nfs命令获取虚拟主机上的kernel文件，成功以后会提示用户该文件的大小，这里记为filesize((切记要使用十六进制表示的数字))

<ul>
<li>nfs 50000000 192.168.1.88:/embeded/KDM/images/v1/Image</li>
</ul>
</li>
<li>烧写kernel到NandFlash中

<ul>
<li>nand write.i 50000000 80000 $(filesize)</li>
</ul>
</li>
<li>使用nfs命令获取虚拟主机上的根文件系统文件，成功以后会提示用户该文件的大小，这里记为filesize((切记要使用十六进制表示的数字))

<ul>
<li>nfs 50000000 192.168.1.88:/embeded/KDM/images/v1/yaff2.img</li>
</ul>
</li>
<li>烧写根文件系统到NandFlash中

<ul>
<li>nand write.yaffs 50000000 580000 $(filesize)</li>
</ul>
</li>
<li>根据需要修改启动参数并保存,例如

<ul>
<li>setenv bootargs root=/dev/mtdblock2 console=ttySAC0,115200</li>
<li>saveenv</li>
</ul>
</li>
</ol>


<h2>测试图形界面程序</h2>

<ul>
<li>图形界面工具使用的触摸屏校准程序为tslib源码附带的校准程序ts_calibrate,所以如果触摸屏没有校准，可以在Linux系统启动后运行/usr/local/bin/ts_calibrate程序对触摸屏进行校准(通过删除/etc/pointercal文件，可以使得图形界面工具自动调用ts_calibrate程序)，校准完毕会在etc目录下生成pointercal标准文件，供触摸屏库程序转换成符合屏幕的坐标，从而达到校准目的。</li>
</ul>


<h2>交叉编译器</h2>

<ul>
<li>arm-linux-gcc是一个“集合命令”，它包含了4个步骤：预处理，汇编，编译和链接，通过链接阶段便生成ELF格式的可执行文件。4个步骤对应执行的程序为arm-linux-cpp，arm-linux-as，ccl，arm-linux-ld。前三个步骤对应的命令行选项为：-E,-S，-c，如果没有任何参数，则代表经过这4个步骤产生可执行文件。</li>
<li>ELF文件的not stripped属性告诉我们在编译的时候产生的编译阶段需要的符号没有被删除</li>
<li>通常被编译出的程序都会使用到系统的动态库，而这些基本的动态库大部分也都是glibc库中的。例如open,read,write,select,ioctl等应用程序中的函数都是libc.so动态库中提供的，而glibc还提供了libm.so(数学库)，libcrypt.so(安全库)，libld.so(加载库)等。其中libld.so作为加载库负责在应用程序运行时，加载程序所使用到的动态库文件。在我们移植系统的过程中，这些最基本的动态库也需要被移植到根文件系统中去，这样才能保证程序被正常启动。</li>
<li>arm-linux-strip test可以删除可执行文件中不需要的编译符号和段描述信息</li>
<li>arm-linux-objcopy -O binary -S test test.bin 通常被用来将生成的ELF格式的文件转化为只含有二进制指令和程序数据的文件test.bin.也只有这样的二进制指令文件才能直接被硬件执行。</li>
<li>arm-linux-dump -D test > test.dis则是反编译，将ELF格式的可执行文件反编译成汇编信息文件test.dis，有助于代码的查看和调试</li>
<li>arm-linux-readelf -a test | grep &lsquo;Shared'用来获取ELF的头信息，grep 'Shared'是获取头信息中test可执行文件调用到的动态文件</li>
<li>arm-linux-gcc 针对arm11的设置：

<ol>
<li>&ndash;with-cpu=arm1176jzf-s</li>
<li>&ndash;with-tune=arm1176jzf-s</li>
<li>&ndash;with-float=softfp</li>
</ol>
</li>
</ul>


<h2>bootloader</h2>

<ul>
<li>目标机上的Bootloader通过串口与主机之间进行文件传输，传输协议通常是xmodem/ymodem/zmodem协议中的一种，但是，串口传输速度有限，因此通过以太网连接并借助tftp或者nfs协议来下载文件是个更好的选择</li>
<li>bootloader的stage1通常包括的步骤：

<ol>
<li>硬件设备初始化

<ul>
<li>屏蔽所有中断</li>
<li>设置CPU的速度和时钟频率</li>
<li>RAM初始化</li>
<li>关闭CPU内部指令/数据cache</li>
</ul>
</li>
<li>为加载Bootloader的stage2准备RAM空间</li>
<li>复制bootloader的stage2到RAM空间</li>
<li>设置好堆栈指针sp</li>
<li>跳转到stage2的C入口点（修改PC寄存器为核实的地址来实现）</li>
</ol>
</li>
<li>bootloader的stage2通常包括的步骤：

<ol>
<li>初始化本阶段要使用到的硬件设备

<ul>
<li>至少一个串口用来和终端用户进行I/O输出信息</li>
</ul>
</li>
<li>检测系统内存映射</li>
<li>将kernel镜像和根文件系统镜像从Flash上读到RAM空间中(需要编写Nand Flash裸驱动)</li>
<li>为内核设置启动参数

<ul>
<li>linux2.4以后的内核都期望以标记列表的形式来传递启动参数，启动参数标记列表以标记ATAG_CORE尅是，以标记ATAG_NONE结束</li>
<li>每个标记由标识被传递参数的tag_header结构以及随后的参数值数据结构来组成，数据结构tag和tag_header定义在Linux内核源码的include/asm/setup.h头文件中</li>
<li>在嵌入式Linux系统中，通常需要由Bootloader设置的常见启动参数有：ATAG_CORE,ATAG_MEN,ATAG_CMDLINE</li>
</ul>
</li>
<li>调用内核，跳转到内核第一条指令处，跳转时要满足下列条件

<ol>
<li>CPU寄存器的设置

<ul>
<li>R0=0</li>
<li>R1=机器类型ID，关于Machine Type Number可以参见linux/arch/arm/tools/mach-types</li>
<li>R2=启动参数标记列表在RAM中的起始基地址</li>
</ul>
</li>
<li>CPU模式

<ul>
<li> 必须禁止中断(IRQs和FIQs)</li>
<li>CPU必须处于SVC模式</li>
</ul>
</li>
<li>Cache和MMU的设置

<ul>
<li>MMU必须关闭</li>
<li>指令Cache可以打开亦可以关闭</li>
<li>数据Cache必须关闭</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>U-boot目录结构

<ol>
<li>与处理器体系结构或者开发板硬件直接相关</li>
<li>通用的函数或者驱动程序</li>
<li>U-Boot的应用程序、工具或者文档</li>
</ol>
</li>
</ul>


<h2>Qt</h2>

<ul>
<li>Qt支持的嵌入式Linux平台需要有frambuffer支持</li>
<li>编译Qt源码

<ol>
<li></li>
</ol>
</li>
</ul>


<h2>编译tslib</h2>

<ol>
<li><a href="http://download.csdn.net/detail/liuqiqi677/3177449">源码下载地址</a></li>
<li>解压缩，进入tslib源码文件夹</li>
<li><code>./autogen.sh</code>生成configure源代码配置文件</li>
<li><code>./configure --host=arm-linux --disable-h3600 --disable-arctic2 --disable-mk712 --disable-collie --disable-corgi --disable-ucb1x00 --with-gnu-ld --prefix=/embeded/tslib_install ac_cv_func_malloc_0_nonnull=yes</code> 这里，&ndash;host的含义是你要安装的目标系统，后面的&ndash;disable 是因为我们不编译对指定触摸屏的支持，我们选择支持的是Linux的input子系统，&ndash;with-gnu-ld是确认使用GNU的LD连接器，因为我们使用的就是GNU的编译器，所以选择这一项。&ndash;prefix选项是指定安装的位置。ac_cv_func_malloc_0_nonnull会在./configure执行阶段测试GNU内置的malloc函数的功能是否可用或者说是否兼容</li>
<li>进入安装目录，这里是/embeded/tslib_install,进入etc目录，打开ts.conf进行修改.其中pthres主要用于处理触摸屏的灵敏度，而variance和dejitter分别用于处理触摸屏的滤波和去噪的算法，linear是触摸屏的坐标变换。

<ul>
<li>module_raw input</li>
<li>module pthres pmin=1</li>
<li>module variance delta=30</li>
<li>module dejitter delta=100</li>
<li>module linear</li>
</ul>
</li>
</ol>


<p><img src="http://i.imgur.com/Nn7Krru.gif" alt="suda-morris" /></p>
]]></content>
  </entry>
  
</feed>
