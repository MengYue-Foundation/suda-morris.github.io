<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-10-10T16:24:02+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cortex-M0]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/06/cortex-m0/"/>
    <updated>2015-10-06T12:23:50+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/06/cortex-m0</id>
    <content type="html"><![CDATA[<h2>ARM体系变种</h2>

<ol>
<li>M变种：

<ol>
<li>长乘法操作：32位整数乘以32位整数，生成64位整数</li>
<li>长乘加操作：32位整数乘以32位整数，加上32位整数，生成64位整数</li>
</ol>
</li>
<li>T变种：

<ol>
<li>Thumb指令集是ARM指令集的一个子集重新编码而成的，它使ARM更加高效地进行运作</li>
</ol>
</li>
<li>E变种：

<ol>
<li>增加了新的16位数据乘法与乘加操作指令</li>
<li>实现饱和的带符号数的加减法操作指令</li>
<li>进行双字数据操作的指令，包含LDRD、STDR、MCRR\MRRC</li>
<li>cache预取指令PLD</li>
</ol>
</li>
<li>J变种：

<ol>
<li>Jazelle技术：将Java代码运行速度提高了8倍，功耗降低了80%</li>
</ol>
</li>
<li>SIMD变种：

<ol>
<li>可同时进行两个16位操作数或者4个8位操作数的运算</li>
<li>用户可以定义饱和运算模式</li>
<li>32位乘以32位的小数MAC</li>
<li>音频\视频处理性能提高了4倍</li>
<li>提供小数算数运算</li>
<li>两套16位操作数的乘加\乘减运算</li>
</ol>
</li>
</ol>


<h2>ARM处理器系列</h2>

<ol>
<li>ARM7系列

<ol>
<li>小型、快速、低能耗、集成式的RISC芯片</li>
<li>冯诺依曼体系结构</li>
<li>三级流水线制</li>
<li>优秀的调试机制</li>
</ol>
</li>
<li>ARM9、ARM9E系列

<ol>
<li>哈佛体系结构：这种体系结构是一种将程序指令存储和数据存储分开的存储器结构，是一种并行体系结构</li>
<li>支持32位的ARM指令和16位Thumb指令</li>
<li>支持一般的操作系统</li>
<li>五级流水处理及分离的Cache结构</li>
<li>ARM9E内核在ARM9内核的基础上增加了紧密耦合存储器的TCM及DSP部分</li>
</ol>
</li>
<li>ARM10E系列

<ol>
<li>支持AMBA总线接口（包含AHB，ASB总线）</li>
<li>六级流水线制</li>
<li>包含DSP指令集</li>
<li>可选浮点协处理器</li>
<li>统一的数据cache和指令cache</li>
<li>能够支持多种商用操作系统</li>
</ol>
</li>
<li>ARM11系列(ARM V6结构)

<ol>
<li>针对媒体处理的SIMD</li>
<li>用以提高安全性能的TrustZone技术</li>
<li>智能能源管理IEM</li>
<li>系统多处理技术</li>
</ol>
</li>
<li>SecurCore系列

<ol>
<li>采用软内核技术</li>
<li>提供面前智能卡和低成本的存储保护单元</li>
<li>可集成用户自己的安全特性和其他处理器</li>
<li>极具安全性</li>
</ol>
</li>
<li>Cortex系列处理器

<ol>
<li>ARM公司在经典处理器ARM11以后的产品改用Cortex命名，并分成A、R和M三类，旨在为各种不同的市场提供服务</li>
<li>A系列面向尖端的基于虚拟内存的操作系统和用户应用</li>
<li>R系列针对实时系统</li>
<li>M系列针对成本和功耗敏感的MCU和终端应用</li>
</ol>
</li>
</ol>


<h2>Cortex-M0/M0+</h2>

<ol>
<li>CortexM0/M0+均是ARMv6M架构,均支持Thumb指令集，支持NVIC和WIC，但不支持Thumb2指令集，其中M0是三级流水线架构，M0+是二级流水线架构</li>
<li>CortexM3，CortexM4均是ARMv7M架构，均支持Thumb，Thumb2指令集，支持NVIC和WIC；CortexA5，CortexA8，CortexA9均是ARMv7A架构</li>
<li>存储器模型：<img src="http://i.imgur.com/KKgz65f.png" alt="ARM CortexM存储器模型" />

<ol>
<li>4GB可寻址线性空间</li>
<li>标准实现，适用于所有Cortex-M系列</li>
<li>无须paging和banking</li>
<li>软件访问可访问性</li>
</ol>
</li>
<li>两种工作模式

<ol>
<li>Thread模式</li>
<li>Handler模式</li>
</ol>
</li>
<li>异常模型

<ol>
<li>异常发生->加载向量列表->异常处理->返回</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+寄存器</h2>

<ol>
<li>32位位宽寄存器：

<ol>
<li>13个通用寄存器：

<ol>
<li>R0-R7（Low registers）</li>
<li>R8-R12(High registers)</li>
</ol>
</li>
<li>3个特殊用处寄存器

<ol>
<li>SP-R13，初始值：0x00000000</li>
<li>LR-R14</li>
<li>PC-R15，初始值0x00000004,Bit[0]为1，表示当前为Thumb代码</li>
</ol>
</li>
<li>特殊寄存器

<ol>
<li>PSR（Program Status Register）</li>
<li>PRIMASK（Interrupt mask register），仅有Bit[0],值为1表示关闭所有中断，只有NMI和硬件错误才能被响应，缺省值为0</li>
<li>CONTROL（control register），只有Bit[0]（定义权限级别，0表示特权级线程模式，1表示普通线程模式，所有的Handler模式都是特权级模式）和Bit[1]（选择当前使用哪个栈指针，0表示选择主栈指针MSP，1表示选择进程栈指针PSP）</li>
</ol>
</li>
</ol>
</li>
<li>寄存器使用方法

<ol>
<li>R0-R3：传递函数参数，返回函数结果，因此也称为a1-a4；也可用于程序内部保存临时变量</li>
<li>R4-R11：保存程序内部的变量值，因此又称为v1-v8，其中r9是个平台相关的寄存器，需要半导体厂商自己定义</li>
<li>R12-R15：专门用途寄存器，R12-IP</li>
</ol>
</li>
<li>程序状态寄存器PSR

<ol>
<li>APSR(Application Program Status Register)，包括Negative，Zero，Carry和Overflow的标志位</li>
<li>IPSR(Interrupt Program Status Register)，包括Exception number(前6位)</li>
<li>EPSR(Execution Program Status Register)，包括Thumb code is executed的指示位</li>
<li>程序状态寄存器的访问指令：MSR和MRS</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+指令集</h2>

<ol>
<li>每条Thumb指令有相同处理器模型所对应的32位ARM指令，比如可以将Thumb指令ADD Rd，#immed_8转换为ARM指令ADD Rd，Rd，#immed_8</li>
<li>Thumb的56条指令分类：

<ol>
<li>存储器访问指令

<ol>
<li>ADR:Generate PC-relative address</li>
<li>LDM:Load Multiple registers</li>
<li>LDR{type}:Load Register using immediate offset</li>
<li>LDR{type}:Load Register using register offset</li>
<li>LDR:Load Register from PC-relative address</li>
<li>POP:Pop register from stack</li>
<li>PUSH:Push registers onto stack</li>
<li>STM:Store Multiple registers</li>
<li>STR{type}:Store Register using immediate offset</li>
<li>STR{type}:Store Register using register offset</li>
</ol>
</li>
<li>数据处理指令</li>
<li>分支和控制指令

<ol>
<li>B{cc}:Branch {conditionally},如果使用了条件执行，那么跳转范围在-256~254字节内；如果没有使用条件执行，那么跳转范围在±1M内</li>
<li>BL:Branch with Link,跳转范围±16MB</li>
<li>BLX:Branch indirect with Link</li>
<li>BX:Branch indirect</li>
</ol>
</li>
<li>杂项指令

<ol>
<li>MRS:Move from special register to register</li>
<li>MSR:Move from register to special register</li>
<li>CPSID:Change Processor State,Disable Interrupts,C语言操作函数:void __disable_irq(void);</li>
<li>CPSIE:Change Processor State,Enable Interrupts,C语言操作函数：void __enable_irq(void);</li>
<li>WFE:Wait For Event,C语言操作函数：void __WFE(void);</li>
<li>WFI:Wait For Interrupt,C语言操作函数：void __WFI(void);</li>
<li>NOP:No Operation,C语言操作函数：void __NOP(void);</li>
<li>SVC:Supervisor Call</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+外设</h2>

<ol>
<li>外设的映射

<ol>
<li>Private Peripheral Bus（PPB）的映射(0xE0000000-0xE00FFFFF)</li>
<li>SysTick:24位计数器，扩展的NVIC特性</li>
<li>NVIC：中断设置与配置</li>
<li>SCB:提供系统实现和系统控制；包括配置、控制和上报系统异常</li>
<li>MPU（Memory Protection Unit）</li>
</ol>
</li>
<li>NVIC接口API：

<ol>
<li>void NVIC_EnableIRQ(IRQn_t IRQn);</li>
<li>void NVIC_DisableIRQ(IRQn_t IRQn);</li>
<li>uint32_t NVIC_GetPendingIRQ(IRQn_t IRQn);</li>
<li>void NVIC_SetPendingIRQ(IRQn_t IRQn);</li>
<li>void NVIC_ClearPendingIRQ(IRQn_t IRQn);</li>
<li>void NVIC_SetPriority(IRQn_t IRQn,uint32_t priority);</li>
<li>uint32_t NVIC_GetPriority(IRQn_t IRQn);</li>
<li>void NVIC_SystemReset(void);请求一次系统复位</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+可执行镜像</h2>

<ol>
<li>ELF：定义了对象文件的内容和格式</li>
<li>BIN：直接的内存镜像</li>
<li>HEX：包含了目标程序镜像的存储地址</li>
<li>AXF：ARM工具链产生，BIN文件内容+调试信息</li>
</ol>


<h2>WEAK和alias属性</h2>

<ol>
<li>当两个或者两个以上行数具有相同的名字，并其中之一声明为weak属性时，则不会引发重定义错误。连接器会忽略弱属性的函数，而使用普通的函数来解析所有对这些符号的引用</li>
<li>如果普通的函数不可用时，连接器会使用weak属性的函数</li>
<li>alias属性：声明别名，当weak和alias属性连用时，可以声明弱别</li>
</ol>


<h2>错误异常</h2>

<ol>
<li>优先级仅次于复位和NMI</li>
<li>引起错误异常的来源：

<ol>
<li>Memory访问异常</li>
<li>程序异常</li>
</ol>
</li>
<li>错误异常分析：<img src="http://i.imgur.com/DrQtd2F.png" alt="错误异常分析" />

<ol>
<li>当异常发生时，处理器首先会保护现场，因此可以得到当前寄存器的值，以及异常发生前被压栈的寄存器的值</li>
<li>判断PC的返回值是否合法，存储器的访问地址是否正确，栈地址是否正确以及是否出现了溢出</li>
<li>访问PSR寄存器来获取当前处理器的状态信息</li>
</ol>
</li>
</ol>


<h2>锁定</h2>

<ol>
<li>锁定（Lockup）的发生：

<ol>
<li>在处理NMI或者HardFault时产生错误异常</li>
<li>异常处理返回，当PSP出栈时，系统总线错误</li>
</ol>
</li>
<li>锁定的退出：

<ol>
<li>复位</li>
<li>Debugger</li>
</ol>
</li>
<li>锁定的预防：

<ol>
<li>尽量缩短NMI和HardFault异常的处理时间</li>
<li>在进入HardFault异常处理前，添加汇编代码，检查SP指针</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wizwiki_W7500]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/04/wizwiki-w7500/"/>
    <updated>2015-10-04T22:51:33+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/04/wizwiki-w7500</id>
    <content type="html"><![CDATA[<h2>WIZwiki-W7500平台介绍</h2>

<ol>
<li>W7500单芯片解决方案：ARM Cortex-M0，48MHz，128KB Flash，16KB RAM，硬件TCP/IP内核，32KB TCP/IP专属RAM，MII接口，8个socket</li>
<li>程序下载方法：

<ol>
<li>CMSIS-DAP USB下载</li>
<li>利用串口的ISP固件下载方式(按住boot键不放，按一下sw键进入boot模式)</li>
</ol>
</li>
<li>SWD(Serial Wire Debug)调试</li>
<li>2路SPI接口，2路I2C接口，3路UART接口，8路ADC(12bit，1Msps)，6路DMA控制器，1个32位的RNG（随机数生成器）</li>
<li>外部PHY芯片：IP101GA

<ol>
<li>自动MDI/MDIX，即自动识别交叉线与直连线</li>
<li>支持MDC与MDIO接口与MAC层通信</li>
</ol>
</li>
<li>CMSIS-DAP实现芯片：LPC11U35FHI33/501

<ol>
<li>CMSIS-DAP功能：

<ol>
<li>通过USB烧写固件到W7500</li>
<li>利用W7500的UART1，通过USB接口与外界进行串口通讯（PC端需要安装驱动，驱动安装成功后会虚拟出串口名如：mbed Seral Port(COMn)）</li>
</ol>
</li>
</ol>
</li>
<li>开发板框图：<img src="http://i.imgur.com/YbsZrdE.png" alt="板子框图" /></li>
<li>W7500芯片框图：<img src="http://i.imgur.com/pLcN78g.png" alt="W7500芯片框图" /></li>
</ol>


<h2>MII</h2>

<ol>
<li>MII即媒体独立接口，也叫介质无关接口，它是IEEE-802.3定义的以太网行业标准，它包括一个数据接口，以及一个MAC和PHY之间的管理接口。</li>
<li>数据接口包括分别用于发送器和接收器的两条独立信道，每条信道都有自己的数据、时钟和控制信号。MII数据接口总共需要16个信号。</li>
<li>管理接口是个双信号接口：一个是时钟信号，另一个是数据信号。通过管理接口，上层能监视和控制PHY</li>
</ol>


<h2>中断和事件</h2>

<ol>
<li>W7500包含26路中断请求IRQ，一个非屏蔽中断NMI，一个事件信号</li>
<li>W7500可以处理内部事件以唤醒内核（WFE），唤醒事件可以通过如下方式产生：

<ol>
<li>DMA进程完成之后</li>
</ol>
</li>
</ol>


<h2>供电</h2>

<ol>
<li>W7500内部嵌入一个稳压器来提供内部1.5V的电压，稳压器没有掉电模式或者休眠模式</li>
<li>ADC参考电压和VDD相同</li>
<li>W7500在系统或电源复位后会处于工作模式，当CPU停止工作时可以采用两种低功耗模式(W7500没有掉电模式)：休眠模式(Sleep)和深度休眠(Deep Sleep)</li>
<li>休眠模式仅仅关闭了CPU时钟，总线时钟依旧开启，深度休眠模式中总线时钟和存储器时钟都被关闭</li>
</ol>


<h2>TOE</h2>

<ol>
<li>TCP/IP卸载引擎(TOE)是一个嵌入式全硬件TCP/IP以太网控制器，它可以提供更简洁的嵌入式网络接入方案。TOE提供WOL(网络唤醒)功能可以大大降低系统功耗</li>
<li>新增网络配置锁存寄存器NCONFLR用来锁定和解锁对网络配置寄存器(SIR,SUBR,GAR和SHAR)的访问。当LOCK处于ON，受保护的寄存器无法进行配置，这汇总情况下，写入NCONFLR寄存器的值是0x01ACCE55，当LOCK处于OFF，受保护的寄存器可以进行配置，这是该寄存器的值为非0x01ACCE55的其他任意值</li>
</ol>


<h2>启动顺序</h2>

<ol>
<li>W7500有三种不同的启动模式，可以通过BOOT引脚和TEST引脚选定。TEST=0，BOOT=0，在主Flash存储器中执行用户代码；TEST=0，BOOT=1，W7500支持ISP功能以便于用串口控制flash</li>
</ol>


<h2>存储器</h2>

<ol>
<li>Flash存储器由长度为32为宽的存储单元构成，可以用于存储代码或者数据</li>
<li>存储器的构成基于一个主Flash存储器块，包含256字节的512扇区，或者4KB的32个块。块和扇区停工读/写保护</li>
</ol>


<h2>时钟复位发生器CRG</h2>

<ol>
<li>CRG包括PLL和POR</li>
<li>三种类型的复位：

<ol>
<li>外部复位，上电复位，系统复位</li>
<li>系统复位是当下面的情况发生时产生复位：

<ol>
<li>看门狗事件</li>
<li>重映射之后</li>
<li>软件复位(在Cortex-M0的SYSRESETREQ为)</li>
</ol>
</li>
</ol>
</li>
<li>两种时钟源可以用来驱动系统时钟：

<ol>
<li>外部振荡器时钟(8MHz~24MHz)(OCLK)</li>
<li>内部8MHz RC振荡器(RCLK)</li>
</ol>
</li>
<li>RNGCLK只有一个源(pll输出)并且没有预分频器</li>
<li>CRG框图：<img src="http://i.imgur.com/xZTW330.png" alt="CRG框图" /></li>
<li>监视时钟源：

<ol>
<li>监视引脚：PA_02</li>
<li>配置寄存器：MONCLK_SSR</li>
</ol>
</li>
</ol>


<h2>随机数发生器RNG</h2>

<ol>
<li>RNG是一个32位随机数发生器，当上电复位时，RNG会产生一个上电随机数，RNG可以通过软件来运行/停止。RNG的初始值和多项式值可以通过软件来更新</li>
</ol>


<h2>外部中断</h2>

<ol>
<li>不管任何功能引脚功能设置，功能引脚都可以被用作一个外部中断源</li>
<li>外部中断控制器的中断极性分为上升沿和下降沿</li>
</ol>


<h2>Pad控制器</h2>

<ol>
<li>W7500具有数字I/O功能引脚和数字/模拟多路复用I/O功能引脚，功能引脚的可控性特性包括上拉，下拉，驱动强度，输入开启和CMOS/Schmitt触发输入缓存</li>
</ol>


<h2>GPIO</h2>

<ol>
<li>屏蔽寄存器可将端口位视为整体而其他位不变</li>
<li>访问屏蔽功能允许一位或者多位在单向传输过程中读或写，这避免了基于软件的读-修改-写操作的非线程安全问题。有了访问屏蔽操作，16-bit I/O被分成两半，低字节和高字节，这个位被定义为两个数组，每一个包含256字节</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yeelink接入]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/02/yeelink/"/>
    <updated>2015-10-02T12:06:42+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/02/yeelink</id>
    <content type="html"><![CDATA[<h2>创建数据点</h2>

<ol>
<li>URL：   <a href="http://api.yeelink.net/v1.0/device/">http://api.yeelink.net/v1.0/device/</a><device_id>/sensor/<sensor_id>/datapoints</li>
<li>数据格式：JSON</li>
<li>Method：POST</li>
<li>返回：HTTP Headers only</li>
<li>一个datapoint是由key和value组成的键值对：

<ol>
<li><strong>数值型传感器</strong>key为timestamp, value为数值;</li>
<li><strong>gps型传感器</strong>key为timestamp, value为JSON格式, 由经度、纬度、速度等GPS信息组成; 同时可以指定是否修正地图上显示的偏移</li>
<li><strong>泛型传感器</strong>key为用户自定义字符串, 大小限定为128个字符; value为JSON格式,由用户自定义具体内容, 大小限定为1024个字符</li>
<li><strong>图像型传感器</strong>key为timestamp, value为图像二进制信息</li>
<li>timestamp为ISO 8601标准时间格式(默认时区为中国标准时间CST), 例如：2012-03-15T16:13:14.</li>
<li>对于数值型传感器和gps型传感器, 如果上传的数据和历史数据的timestamp相同, 则会被丢弃. 若未指定timestamp, 服务器会自动加上当前时间.</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript知识清单]]></title>
    <link href="http://suda-morris.github.io/blog/2015/09/28/javascript/"/>
    <updated>2015-09-28T12:20:50+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/09/28/javascript</id>
    <content type="html"><![CDATA[<h2>==与===的区别</h2>

<ol>
<li>对于string,number等基础类型，==和===是有区别的

<ol>
<li>不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等</li>
<li>同类型比较，直接进行“值”比较，两者结果一样</li>
</ol>
</li>
<li>对于Array,Object等高级类型，==和===是没有区别的

<ul>
<li>进行“指针地址”比较</li>
</ul>
</li>
<li>基础类型与高级类型，==和===是有区别的

<ol>
<li>对于==，将高级转化为基础类型，进行“值”比较</li>
<li>因为类型不同，===结果为false</li>
</ol>
</li>
</ol>


<h2>事件</h2>

<ol>
<li>常用事件

<ul>
<li>onClick单击事件</li>
<li>onMouseOver鼠标经过事件</li>
<li>onMouseOut鼠标移出事件</li>
<li>onChange文本内容改变事件</li>
<li>onSelect文本框选中事件</li>
<li>onFocus光标聚集事件</li>
<li>onBlur移开光标事件</li>
<li>onLoad网页加载事件</li>
<li>onUnload关闭网页事件</li>
</ul>
</li>
<li>事件冒泡

<ul>
<li>由最具体的元素接收，然后逐级向上传播至最不具体的元素的节点(文档)</li>
</ul>
</li>
<li>事件捕获

<ul>
<li>最不具体的节点先接收事件，而最具体的节点应该是最后接收事件</li>
</ul>
</li>
<li>事件处理

<ol>
<li>HTML事件处理

<ul>
<li>直接添加到HTML结构中</li>
</ul>
</li>
<li>DOM0级事件处理

<ul>
<li>把一个函数赋值给一个事件处理程序</li>
<li>同一个元素多个事件会被覆盖，只有最后一个事件起作用</li>
</ul>
</li>
<li>DOM2级事件处理

<ul>
<li>addEventListener(“事件名”，“事件处理函数”，“布尔值”)；</li>
<li>true：事件捕获</li>
<li>false：事件冒泡</li>
<li>removeEventListen();</li>
</ul>
</li>
<li>IE事件处理程序(IE8及以下)

<ul>
<li>attachEvent</li>
<li>detachEvent</li>
</ul>
</li>
</ol>
</li>
<li>事件对象

<ol>
<li>在触发DOM事件的时候都会产生一个对象</li>
<li>事件对象event

<ol>
<li>type：获取事件类型</li>
<li>target：获取事件目标</li>
<li>stopPropagation()；阻止事件冒泡</li>
<li>preventDefault()；阻止事件默认行为(比如超链接)</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>DOM对象</h2>

<ol>
<li>当网页被加载时，浏览器会创建页面的文档对象模型(Document Object Model)
<img src="http://i.imgur.com/EwSndVS.png" alt="DOM对象模型" /></li>
<li>DOM操作HTML

<ol>
<li>改变HTML输出流：

<ul>
<li>注意，绝对不要在文档加载完成后使用document.write(),这会覆盖该文档</li>
</ul>
</li>
<li>寻找元素：

<ul>
<li>通过id找到HTML元素,document.getElementById();</li>
<li>通过标签名找到HTML元素,document.getElementByTagName();</li>
</ul>
</li>
<li>改变HTML内容

<ul>
<li>使用属性：innerHTML</li>
</ul>
</li>
<li>改变HTML属性

<ul>
<li>使用属性：attribute，例如：<code>document.getElementById("aid").href="http://www.baid.com";</code></li>
</ul>
</li>
<li>常用方法：

<ol>
<li>getElementsByName();获取name</li>
<li>getElementsByTagName();获取元素</li>
<li>getAttribute();获取元素属性</li>
<li>setAttribute();设置元素属性</li>
<li>childNodes();访问子节点</li>
<li>parentNode();访问父节点</li>
<li>createElement();创建元素节点</li>
<li>createTextNode();创建文本节点</li>
<li>insertBefore();插入节点</li>
<li>removeChild();删除节点</li>
<li>offsetHeight;网页尺寸,例如：<code>var width=document.body.offsetWidth;</code></li>
<li>crollHeight;网页尺寸</li>
</ol>
</li>
<li>创建节点示例
 <code>var body=document.body;var input=document.creatElement("input");input.type="button";input.value="按钮"；body.appendChild(input);</code></li>
</ol>
</li>
<li>DOM操作CSS

<ol>
<li>基本语法：<code>document.getElementById(id).style.property=new style;</code></li>
</ol>
</li>
<li>DOM操作事件句柄

<ol>
<li>addEventListener();向指定元素添加事件句柄</li>
<li>removeEventListener();移出方法添加的事件句柄</li>
</ol>
</li>
</ol>


<h2>内置对象</h2>

<ol>
<li>String对象

<ol>
<li>字符串可以使用使用单引号或者双引号</li>
<li>获取字符串长度：length属性</li>
<li>在字符串中查找字符串的方法：indexOf(),成功返回位置，失败返回-1</li>
<li>内容匹配的方法：match(),成功返回匹配成功的字符串，失败返回空</li>
<li>替换内容的方法：replace()</li>
<li>字符串大小写转换：toUpperCase()/toLowerCase()</li>
<li>字符串转为数组：split</li>
</ol>
</li>
<li>Date对象

<ol>
<li>常用方法：

<ol>
<li>getFullYear():获取年份</li>
<li>getTime():获取毫秒</li>
<li>setFullYear():设置具体的日期</li>
<li>getDay():获取星期</li>
</ol>
</li>
</ol>
</li>
<li>Array数组对象

<ol>
<li>数组的创建

<ul>
<li><code>var myArray=["Hello","iwen","ime"];</code></li>
</ul>
</li>
<li>数组的访问

<ul>
<li>通过指定数组名以及索引号码(下标从0开始)，可以访问某个特定的元素</li>
</ul>
</li>
<li>常用方法

<ul>
<li>concat();合并数组</li>
<li>sort();排序</li>
<li>push();末尾追加元素</li>
<li>reverse();数组元素翻转</li>
</ul>
</li>
</ol>
</li>
<li>Math对象

<ol>
<li>常用方法

<ul>
<li>round():四舍五入;例如Math.round(2.5)等于3</li>
<li>random();返回0~1之间的随机数;例如parseInt(Math.random()*10);</li>
<li>max();返回最高值</li>
<li>min();返回最低值</li>
<li>abs();返回绝对值</li>
</ul>
</li>
</ol>
</li>
</ol>


<h2>浏览器对象</h2>

<ol>
<li>Window对象

<ul>
<li>window对象时BOM的核心，window对象指当前的浏览器窗口。所有JavaScript全局对象，函数以及变量均自动成为window对象的成员；全局变量是window对象的属性，全局函数是window对象的方法，甚至HTML DOM的document也是window对象的属性之一</li>
<li>window.innerHeight:浏览器窗口的内部高度</li>
<li>window.innerWidth:浏览器窗口的内部宽度</li>
<li>window.open(&ldquo;url"，“windowname”，“style”):打开新的网页</li>
</ul>
</li>
<li>计时器

<ol>
<li>方法

<ol>
<li>setInterval();间隔指定的好描述不同的执行指定的代码</li>
<li>clearInterval();停止setInterval()方法执行的函数代码</li>
<li>setTimeout();暂停指定的毫秒数后执行指定的代码</li>
<li>clearTimeout();停止之慈宁宫setTimeout()方法的函数代码</li>
</ol>
</li>
</ol>
</li>
<li>History对象

<ol>
<li>history.back()与在浏览器中点击后退按钮相同</li>
<li>history.forward()与在浏览器中点击向前按钮相同</li>
<li>history.go()进入历史中的某个页面</li>
</ol>
</li>
<li>Location对象

<ol>
<li>location对象用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面</li>
<li>属性与方法

<ol>
<li>location.hostname返回web主机的域名</li>
<li>location.pathname返回当前页面的路径和文件名</li>
<li>location.port返回web主机的端口</li>
<li>location.protocol返回所使用的web协议(<a href="http://%E6%88%96https://">http://%E6%88%96https://</a>)</li>
<li>location.href返回当前页面的URL</li>
<li>location.assign()加载新的文档</li>
</ol>
</li>
</ol>
</li>
<li>Screen对象

<ol>
<li>属性

<ol>
<li>screen.availWidth可用的屏幕宽度</li>
<li>screen.availHeight可用的屏幕高度</li>
<li>screen.Height屏幕高度</li>
<li>screen.Width屏幕宽度</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>面向对象</h2>

<figure class='code'><figcaption><span>使用闭包以及function来模拟类</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">People</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">_age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">People</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;People:Hello &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span> <span class="o">+</span> <span class="s2">&quot; years old&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">window</span><span class="p">.</span><span class="nx">People</span> <span class="o">=</span> <span class="nx">People</span><span class="p">;</span>
</span><span class='line'><span class="p">}());</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">Student</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">grade</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">_grade</span> <span class="o">=</span> <span class="nx">grade</span><span class="p">;</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">_age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">Student</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">People</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">,</span><span class="k">this</span><span class="p">.</span><span class="nx">_age</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">superSay</span> <span class="o">=</span> <span class="nx">Student</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Student</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">superSay</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Student:Hello &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span> <span class="o">+</span> <span class="s2">&quot; years old&quot;</span> <span class="o">+</span> <span class="s2">&quot;,Grade: &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_grade</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">window</span><span class="p">.</span><span class="nx">Student</span> <span class="o">=</span> <span class="nx">Student</span><span class="p">;</span>
</span><span class='line'><span class="p">}());</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">stu</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Student</span><span class="p">(</span><span class="s2">&quot;morris&quot;</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="s2">&quot;one&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nx">stu</span><span class="p">.</span><span class="nx">say</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>AJAX</h2>

<ol>
<li>AJAX(Asynchronous Javascript And XML)</li>
<li>编程模板

<ol>
<li>创建XMLHttpRequest对象</li>
<li>open操作初始化请求信息</li>
<li>监听事件处理响应结果</li>
<li>send操作发出请求</li>
</ol>
</li>
<li>创建各浏览器兼容的XMLHttpRequest对象</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='JS'><span class='line'><span class="kd">function</span> <span class="nx">creatXHR</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">XMLHttpRequest</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">ActiveXObject</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ActiveXObject</span><span class="p">(</span><span class="s1">&#39;Msxml2.XMLHTTP&#39;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ActiveXObject</span><span class="p">(</span><span class="s1">&#39;Microsoft.XMLHTTP&#39;</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">xhr</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>发送请求信息

<ol>
<li>get方法

<ul>
<li><code>xhr.open("GET","http://test/keyword/hit?keyword=c",true);</code></li>
<li><code>xhr.send();</code></li>
</ul>
</li>
<li>post方法

<ul>
<li><code>xhr.open("POST","http://test/keyword/hit",true);</code></li>
<li><code>xhr.send("keyword=c")</code>;</li>
</ul>
</li>
</ol>
</li>
<li>设置请求头信息

<ol>
<li><code>xhr.setRequestHeader("Content-Type","application/json");</code></li>
<li><code>xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");</code></li>
</ol>
</li>
<li>响应的接收与请求</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='JS'><span class='line'><span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span><span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">responseXML</span><span class="p">);</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">getAllResponseHeaders</span><span class="p">());</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">getResponseHeader</span><span class="p">(</span><span class="s2">&quot;Content-Type&quot;</span><span class="p">));</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">statusText</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>将Json字符串转换成Json对象：

<ol>
<li>JSON.parse(xhr.responseText);</li>
<li>eval(xhr.responseText);</li>
</ol>
</li>
</ol>


<h2>设计模式</h2>

<ol>
<li>设计原则

<ol>
<li>开闭原则：对扩展开放，对修改关闭</li>
<li>里氏转换原则：子类继承父类，单独调用完全可以运行</li>
<li>依赖倒转原则：引用一个对象，如果这个对象有底层类型，直接饮用底层</li>
<li>接口隔离原则：每一个接口应该是一种角色</li>
<li>合成/聚合复用原则：新的对象应使用一些已有的对象，使之成为新对象的一部分</li>
<li>迪米特原则：一个对象应对其他对象有尽可能少的了解</li>
</ol>
</li>
<li>单例模式</li>
</ol>


<h2>jQuery</h2>

<ol>
<li>jQuery库可以通过一行简单的标记被添加到网页中</li>
<li>jQuery是一个JavaScript函数库</li>
<li>jQuery库包含的功能:

<ol>
<li>HTML元素选取</li>
<li>HTML元素操作</li>
<li>CSS操作</li>
<li>HTML事件函数</li>
<li>JavaScript特效和动画</li>
<li>HTML DOM遍历和修改</li>
<li>AJAX</li>
<li>Utilities</li>
</ol>
</li>
<li>从CDN中载入jQuery，例如：<a href="http://libs.baidu.com/jquery/1.10.1/jquery.min.js">http://libs.baidu.com/jquery/1.10.1/jquery.min.js</a></li>
<li>基础语法：

<ol>
<li>$(selector).action()

<ul>
<li>美元符号定义jQuery</li>
<li>选择符selector“查询”和“查找”HTML元素</li>
<li>jQuery的action()执行对元素的操作</li>
<li>例如：

<ul>
<li>$(this).hide()隐藏当前元素</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS样式知识清单]]></title>
    <link href="http://suda-morris.github.io/blog/2015/09/27/css/"/>
    <updated>2015-09-27T10:51:10+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/09/27/css</id>
    <content type="html"><![CDATA[<h2>基础语法</h2>

<blockquote><p>selector{
property:value
}
其中selector有派生选择器，id选择器，类选择器，属性选择器</p></blockquote>

<h2>头部声明</h2>

<p><code>&lt;link href="MyCSS.css" type="text/css" rel="stylesheet"&gt;</code></p>

<h2>id选择器</h2>

<ol>
<li>id选择器可以为标有id的HTML元素指定特定的样式</li>
<li>id选择器以“#”来定义</li>
</ol>


<h1>类选择器</h1>

<ol>
<li>类选择器以一个点来定义</li>
</ol>


<h2>属性选择器</h2>

<ol>
<li><code>&lt;style type="text/css"&gt; [title=te]{color:blue}&lt;/style&gt;</code></li>
<li><code>&lt;p title="te"&gt;属性选择器&lt;/p&gt;</code></li>
</ol>


<h2>CSS背景</h2>

<ul>
<li>background-attachment:背景图像是否固定或者随着页面的其余部分滚动</li>
<li>background-color:设置元素的背景颜色</li>
<li>background-image:把图片设置为背景，url(&ldquo;bg.jpg&rdquo;)</li>
<li>background-position:设置背景图片的起始位置</li>
<li>background-repeat:设置背景图片是否及如何重复</li>
<li>background-size:规定背景图片的尺寸</li>
<li>background-origin:规定背景图片的定位区域</li>
<li>background-clip:规定背景的绘制区域</li>
</ul>


<h2>CSS文本</h2>

<ul>
<li>color：文本颜色</li>
<li>direction：文本方向</li>
<li>line-height：行高</li>
<li>letter-spacing：字符间距</li>
<li>text-align：对齐元素中的文本</li>
<li>text-decoration：向文本中添加修饰</li>
<li>text-indent：缩进元素中文本的首行</li>
<li>text-transform：元素中的字母</li>
<li>unicode-bidi：设置文本方向</li>
<li>white-space：元素中空白的处理方式</li>
<li>word-spacing：字间距</li>
<li>text-shadow:文本阴影</li>
<li>word-wrap:规定文本的换行规则</li>
</ul>


<h2>CSS字体</h2>

<ul>
<li>font-family:设置字体系列</li>
<li>font-size:设置字体的尺寸</li>
<li>font-style:设置字体风格</li>
<li>font-variant:以小型大写字体或正常字体显示文本</li>
<li>font-weight:设置字体的粗细</li>
</ul>


<h2>CSS链接</h2>

<ol>
<li>CSS链接的四种状态：

<ul>
<li>a:link 普通的、未被访问的链接</li>
<li>a:visited 用户已经访问的链接</li>
<li>a:hover 鼠标指针位于链接的上方</li>
<li>a:active 链接被点击的时刻</li>
</ul>
</li>
<li>常见的链接样式：

<ul>
<li>text-decoration属于大多用于去掉链接中的下划线</li>
</ul>
</li>
</ol>


<h2>CSS列表</h2>

<ul>
<li>list-style简写列表项</li>
<li>list-style-image列表项图像</li>
<li>list-style-position列表标志位置</li>
<li>list-style-type列表类型</li>
</ul>


<h2>CSS表格</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nf">#tb</span><span class="p">{</span>
</span><span class='line'>  <span class="k">border-collapse</span><span class="o">:</span><span class="k">collapse</span><span class="p">;</span>
</span><span class='line'>  <span class="k">width</span><span class="o">:</span><span class="m">500px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#tb</span> <span class="nt">td</span><span class="o">,</span><span class="nf">#tb</span> <span class="nt">th</span><span class="p">{</span>
</span><span class='line'>  <span class="k">border</span><span class="o">:</span><span class="m">1px</span> <span class="k">solid</span> <span class="nb">bisque</span><span class="p">;</span>
</span><span class='line'>  <span class="k">padding</span><span class="o">:</span><span class="m">5px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#tb</span> <span class="nt">th</span><span class="p">{</span>
</span><span class='line'>  <span class="k">text-align</span><span class="o">:</span><span class="k">right</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-color</span><span class="o">:</span><span class="nb">aqua</span><span class="p">;</span>
</span><span class='line'>  <span class="k">color</span><span class="o">:</span><span class="m">#FFFFFF</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nf">#tb</span> <span class="nt">tr</span><span class="nc">.alt</span> <span class="nt">td</span><span class="p">{</span>
</span><span class='line'>  <span class="k">color</span><span class="o">:</span><span class="nb">black</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-color</span><span class="o">:</span><span class="nb">aquamarine</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>CSS轮廓</h2>

<ul>
<li>outline设置轮廓属性</li>
<li>outline-color设置轮廓的颜色</li>
<li>outline-style设置轮廓的样式</li>
<li>outline-width设置轮廓的宽度</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML5知识点清单]]></title>
    <link href="http://suda-morris.github.io/blog/2015/09/25/html5-introduce/"/>
    <updated>2015-09-25T22:26:10+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/09/25/html5-introduce</id>
    <content type="html"><![CDATA[<h2>基础</h2>

<ol>
<li>声明：&lt;!DOCTYPE>

<ul>
<li>HTML有多个不同版本，只有完全明白页面中使用的确切的HTML版本，浏览器才能完全正确地显示出HTML页面</li>
<li>HTML5：

<ul>
<li>&lt;!DOCTYPE html></li>
</ul>
</li>
</ul>
</li>
<li>元素：指的是从开始标签到结束标签的所有代码

<ul>
<li><code>&lt;p&gt; this is my web page &lt;/p&gt;</code>中的<code>this is my web page</code>就是元素内容</li>
<li><code>&lt;br/&gt;</code>表示不含任何元素的空标签，即换行</li>
<li>空元素在开始标签中进行关闭</li>
<li>大多数的HTML元素可拥有属性</li>
</ul>
</li>
<li>属性

<ul>
<li>属性以键值对的形式出现</li>
<li>常用标签属性

<ul>
<li><code>&lt;h1&gt;:align对齐方式</code></li>
<li><code>&lt;body&gt;:bgcolor背景颜色</code></li>
<li><code>&lt;a&gt;:target规定在何处打开连接</code></li>
</ul>
</li>
<li>通用属性

<ul>
<li><code>class：规定元素的类名</code></li>
<li><code>id：规定元素唯一ID</code></li>
<li><code>style：规定元素的样式</code></li>
<li><code>title：规定元素的额外信息</code></li>
</ul>
</li>
</ul>
</li>
<li>格式化

<ul>
<li><code>&lt;b&gt;定义粗体文字</code></li>
<li><code>&lt;big&gt;定义大号文字</code></li>
<li><code>&lt;em&gt;定义着重文字</code></li>
<li><code>&lt;i&gt;定义斜体文字</code></li>
<li><code>&lt;small&gt;定义小号文字</code></li>
<li><code>&lt;strong&gt;定义加重语气</code></li>
<li><code>&lt;sub&gt;定义下标文字</code></li>
<li><code>&lt;sup&gt;定义上标文字</code></li>
<li><code>&lt;ins&gt;定义插入字</code></li>
<li><code>&lt;del&gt;定义删除字</code></li>
</ul>
</li>
<li>样式

<ol>
<li>标签

<ul>
<li><code>&lt;style&gt;:样式定义</code></li>
<li><code>&lt;link&gt;:资源引用</code></li>
</ul>
</li>
<li>属性

<ul>
<li><code>rel="stylesheet"：外部样式表</code></li>
<li><code>type="text/css":引入文档的类型</code></li>
<li><code>margin-left:边距</code></li>
</ul>
</li>
<li>三种样式表插入方法：

<ol>
<li>外部样式表：<code>&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;</code></li>
<li>内部样式表：<code>&lt;style type="text/css"&gt;body{background-color:red} p{margin-left:20px}&lt;/style&gt;</code></li>
<li>内联样式表：<code>&lt;p style="color:red"&gt;</code></li>
</ol>
</li>
</ol>
</li>
<li>链接

<ol>
<li>标签：<a></a></li>
<li>连接数据：文本链接，图片链接</li>
<li>属性：

<ol>
<li>href属性：指向另一个文档的链接</li>
<li>name属性：创建文档内的链接

<ul>
<li><code>&lt;a name="tips"&gt;hello&lt;/a&gt;</code></li>
<li><code>&lt;a href="#tips"&gt;跳转&lt;/a&gt;</code></li>
</ul>
</li>
</ol>
</li>
<li>img标签属性

<ol>
<li>alt：替换文本属性</li>
<li>width：宽</li>
<li>height：高</li>
</ol>
</li>
</ol>
</li>
<li>表格

<ol>
<li>标签

<ul>
<li><code>&lt;table&gt;：定义表格</code>,属性border定义边框大小，属性cellpadding定义单元格边距，属性cellspacing定义单元格间距，属性bgcolor定义表格背景色，属性background定义表格图片</li>
<li><code>&lt;caption&gt;：定义表格标题</code></li>
<li><code>&lt;th&gt;：定义表格表头</code></li>
<li><code>&lt;tr&gt;：定义表格的行</code></li>
<li><code>&lt;td&gt;：定义表格的单元</code>,属性colspan的值定义了要合并的单元格数目</li>
<li><code>&lt;thead&gt;：定义表格的页眉</code></li>
<li><code>&lt;tbody&gt;：定义表格的主题</code></li>
<li><code>&lt;tfoot&gt;：定义表格的页脚</code></li>
<li><code>&lt;col&gt;：定义表格的列属性</code></li>
</ul>
</li>
</ol>
</li>
<li>列表

<ol>
<li>标签

<ul>
<li><code>&lt;ol&gt;：有序列表</code>，type属性值A,a,I ,i,start</li>
<li><code>&lt;ul&gt;：无序列表</code>，type属性值disc,circle,square</li>
<li><code>&lt;li&gt;：列表项</code></li>
<li><code>&lt;dl&gt;：自定义列表</code></li>
<li><code>&lt;dt&gt;：自定义列表项</code></li>
<li><code>&lt;dd&gt;：自定义列表描述</code></li>
</ul>
</li>
</ol>
</li>
<li>块

<ol>
<li>HTML块元素

<ul>
<li>块元素在显示时，通常会以新行开始，比如<code>&lt;h1&gt;,&lt;p&gt;,&lt;ul&gt;</code></li>
</ul>
</li>
<li>HTML内联元素

<ul>
<li>内联元素通常不会以新行开始，比如<code>&lt;b&gt;,&lt;a&gt;,&lt;img&gt;</code></li>
</ul>
</li>
<li><code>HTML&lt;div&gt;</code>元素

<ul>
<li><code>&lt;div&gt;</code>元素也被称称为块元素，其主要是组合HTML元素的容器</li>
</ul>
</li>
<li><code>HTML&lt;span&gt;</code>元素

<ul>
<li><code>&lt;span&gt;</code>元素是内联元素，可作为文本的容器</li>
</ul>
</li>
</ol>
</li>
<li>使用div元素布局</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span><span class='line'><span class="nt">&lt;html&gt;</span>
</span><span class='line'><span class="nt">&lt;head</span> <span class="na">lang=</span><span class="s">&quot;en&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">&quot;UTF-8&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;title&gt;</span>html布局测试<span class="nt">&lt;/title&gt;</span>
</span><span class='line'>    <span class="nt">&lt;style </span><span class="na">type=</span><span class="s">&quot;text/css&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">body</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">margin</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">div</span><span class="nf">#page</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">background-color</span><span class="o">:</span> <span class="nb">gray</span><span class="p">;</span>
</span><span class='line'>            <span class="k">width</span><span class="o">:</span> <span class="m">100%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">height</span><span class="o">:</span> <span class="m">950px</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">div</span><span class="nf">#head</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">background-color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
</span><span class='line'>            <span class="k">width</span><span class="o">:</span> <span class="m">100%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">height</span><span class="o">:</span> <span class="m">10%</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">div</span><span class="nf">#left</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">background-color</span><span class="o">:</span> <span class="nb">greenyellow</span><span class="p">;</span>
</span><span class='line'>            <span class="k">width</span><span class="o">:</span> <span class="m">20%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">height</span><span class="o">:</span> <span class="m">80%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">float</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">div</span><span class="nf">#middle</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">background-color</span><span class="o">:</span> <span class="nb">gray</span><span class="p">;</span>
</span><span class='line'>            <span class="k">width</span><span class="o">:</span> <span class="m">60%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">height</span><span class="o">:</span> <span class="m">80%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">float</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">div</span><span class="nf">#right</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">background-color</span><span class="o">:</span> <span class="nb">cornflowerblue</span><span class="p">;</span>
</span><span class='line'>            <span class="k">width</span><span class="o">:</span> <span class="m">20%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">height</span><span class="o">:</span> <span class="m">80%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">float</span><span class="o">:</span> <span class="k">left</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">div</span><span class="nf">#foot</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">background-color</span><span class="o">:</span> <span class="nb">blue</span><span class="p">;</span>
</span><span class='line'>            <span class="k">width</span><span class="o">:</span> <span class="m">100%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">height</span><span class="o">:</span> <span class="m">10%</span><span class="p">;</span>
</span><span class='line'>            <span class="k">clear</span><span class="o">:</span> <span class="k">both</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="nt">&lt;/style&gt;</span>
</span><span class='line'><span class="nt">&lt;/head&gt;</span>
</span><span class='line'><span class="nt">&lt;body&gt;</span>
</span><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;page&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;head&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        head
</span><span class='line'>    <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;left&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        main_L
</span><span class='line'>    <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;middle&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        main_M
</span><span class='line'>    <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;right&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        main_R
</span><span class='line'>    <span class="nt">&lt;/div&gt;</span>
</span><span class='line'>    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;foot&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        foot
</span><span class='line'>    <span class="nt">&lt;/div&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span><span class='line'><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>表单</p>

<ol>
<li>标签

<ul>
<li><code>&lt;form&gt;表单</code>，属性值有action，method</li>
<li><code>&lt;input&gt;输入域</code>，属性type的值有：text，password，checkbox，radio(需要和name属性搭配使用),button(需要和value属性搭配使用),submit(需要和value属性搭配使用)</li>
<li><code>&lt;textarea&gt;文本域</code>，属性有cols,rows</li>
<li><code>&lt;label&gt;控制标签</code></li>
<li><code>&lt;fieldset&gt;定义域</code></li>
<li><code>&lt;legend&gt;域的标题</code></li>
<li><code>&lt;select&gt;选择列表</code></li>
<li><code>&lt;optgroup&gt;选项组</code></li>
<li><code>&lt;option&gt;下拉列表中的选项</code>,需要被<code>&lt;select&gt;</code>包围</li>
<li><code>&lt;button&gt;按钮</code></li>
</ul>
</li>
</ol>
</li>
<li><p>框架</p>

<ol>
<li>框架标签<code>&lt;frame?</code></li>
<li>框架集标签<code>&lt;frameset&gt;</code></li>
<li>常用标签

<ul>
<li>noresize:固定框架大小</li>
<li>cols:列</li>
<li>rows:行</li>
</ul>
</li>
<li>内联框架<code>&lt;iframe&gt;</code>,属性src指名引用的框架路径，属性frameborder指名是否需要边框</li>
</ol>
</li>
<li><p>实体</p>

<ul>
<li>HTML中预留字符串必须被替换成字符实体，如&lt;（小于号），>（大于号）</li>
<li>常用的字符实体

<ul>
<li>空格：&amp;nbsp</li>
<li>小于号：&amp;lt</li>
<li>大于号：&amp;gt</li>
<li>和号：&amp;amp</li>
<li>引号：&amp;quot</li>
<li>撇号：&amp;apos</li>
<li>分：&amp;cent</li>
<li>镑：&amp;pound</li>
<li>元：&amp;yen</li>
<li>欧元：&amp;euro</li>
<li>小节：&amp;sect</li>
<li>版权：&amp;copy</li>
<li>注册商标：&amp;reg</li>
<li>商标：&amp;trade</li>
<li>乘号：&amp;times</li>
<li>除号：&amp;divide</li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>HTML5 Web Storage</h2>

<ol>
<li>Web Storage功能就是在Web上存储数据的功能，这里的储存是针对客户端本地而言的，具体分为两种：

<ul>
<li>sessionStorage：将数据保存在session对象中，session是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据</li>
<li>localStorage：将数据保存在客户端本地的硬件设备中，即使浏览器被关闭了，该数据任然存在，下一次打开浏览器访问网站时仍然可以继续使用</li>
</ul>
</li>
</ol>


<figure class='code'><figcaption><span>sessionStorage</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">saveStorage</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">sessionStorage</span><span class="p">.</span><span class="nx">setItem</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">,</span><span class="nx">str</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">loadStorage</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="nx">sessionStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">target</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>localStorage</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">saveStorage</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">localStorage</span><span class="p">.</span><span class="nx">setItem</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">,</span><span class="nx">str</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">loadStorage</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">target</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">target</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>HTML5 本地数据库</h2>

<ol>
<li>HTML5中内置了两种本地数据库，一种为SQLite，一种为indexedDB</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统集成项目管理]]></title>
    <link href="http://suda-morris.github.io/blog/2015/09/23/project-manager/"/>
    <updated>2015-09-23T13:23:26+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/09/23/project-manager</id>
    <content type="html"><![CDATA[<h2>信息系统集成基础知识</h2>

<ol>
<li>信息系统集成是指将计算机软件、硬件、网络通信等技术和产品集成成为能够满足用户特定需求的信息系统，包括总体策划、设计、开发、实施、服务及保障</li>
<li>信息系统集成的<strong>本质</strong>是实现优化的综合统筹设计</li>
<li>信息系统集成要以满足用户需求为<strong>根本出发点</strong></li>
<li>信息系统集成的核心是<strong>软件</strong></li>
<li>信息系统集成是一项综合性的系统工程，<strong>技术</strong>是系统集成工作的的核心，<strong>管理和商务</strong>活动是系统集成项目成功实施的保障</li>
<li>信息系统集成实现的<strong>关键</strong>在于解决各子系统之间的互联和互操作问题</li>
<li>信息系统集成主要分为<strong>设备系统集成</strong>（即硬件系统集成，或弱电系统集成）和<strong>应用系统集成</strong>（也称行业信息化解决方案集成）两大类。设备系统集成又可分为智能建筑系统集成、计算机网络系统集成和安防系统集成</li>
</ol>


<h2>信息系统集成资质管理</h2>

<ol>
<li>信息系统集成的资质是指从事计算机信息系统集成的综合能力，包括技术水平、管理水平、服务水平、质量保证能力、技术装备、系统建设质量、人员构成与素质、经营业绩、资产状况等要素</li>
<li>凡是从事计算机信息系统集成业务的单位，必须经过资质认证并取得《计算机信息系统集成资质证书》</li>
<li>凡是要建设计算机信息系统的单位，应选择具有相应等级《资质证书》的计算机信息系统集成单位来承建计算机信息系统</li>
<li><strong>工业和信息化</strong>部负责计算机信息系统集成资质认证管理工作</li>
<li>计算机信息系统集成资质等级分一、二、三、四级</li>
<li>资质监督管理是指对获证单位资质保持的<strong>监督检查</strong>和<strong>资质变更</strong>的管理</li>
<li>《资质证书》有效期<strong>3年</strong>，获证单位应每年进行一次<strong>自查</strong>（自查时间是每年2月1日至4月30日），并将自查结果报资质认证工作办公室备案；资质认证工作办公室对获证单位每四年进行一次换证检查。</li>
<li>计算机信息系统集成资质认证工作根据<strong>认证和审批分离</strong>的原则，按照先由认证机构认证，再由信息产业主管部门审批的工作程序进行</li>
<li>获证单位应提前做好换证工作准备，最迟应在《资质证书》有效期满<strong>前3个月</strong>，向相应的资质认证工作办公室提出更换证书申请</li>
<li>获证单位原则上在获证<strong>一年以后</strong>如果达到更高级别的资质评定条件，可以像相应的认证机构提出比原资质更高级的升级认证申请</li>
<li>系统集成一、二级资质证书由<strong>工业和信息化部</strong>审批，三、四级由<strong>地方信息产业主管部门</strong>审批，报工业和信息化部备案</li>
<li>计算机信息系统集成企业资质等级评定条件主要从综合条件、财务状况、信誉、业绩、管理能力、技术实力和人才实力7个方面进行考核</li>
<li>企业资质等级评定条件：

<ol>
<li>特一级资质

<ul>
<li>取得一级资质不少于三年</li>
<li>注册资本和实收资本均不少于2亿元</li>
<li>固定资产中电子设备的净值不少于1000万元，无形资产中软件的账面净值不少于1000万元</li>
<li>近三年系统集成年收入均不少于5亿元</li>
</ul>
</li>
<li>一级资质

<ul>
<li>取得二级资质不少于两年</li>
<li>主业是计算机信息系统集成，近三年的系统集成收入总额占营收入总额的比例不低于70%，且近三年系统集成收入总额不少于5亿元</li>
<li>注册资本和实收资本均不少于5000万元</li>
<li>近三年至少完成4个合同额不少于1500万元的系统集成项目</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于5年</li>
<li>从事软件开发与系统集成相关工作的人员不少于220人，其中大学本科以及以上学历人员所占比例不低于80%；具有计算机信息系统集成项目管理人员资质的人数不少于30名，其中高级项目经理人数不少于10名</li>
</ul>
</li>
<li>二级资质

<ul>
<li>取得三级资质不少于一年</li>
<li>主业是计算机信息系统集成，近三年的系统集成收入总额占营收入总额的比例不低于60%，且近三年系统集成收入总额不少于2.5亿元</li>
<li>注册资本和实收资本均不少于2000万元</li>
<li>近三年至少完成3个合同额不少于1000万元的系统集成项目</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于4年</li>
<li>从事软件开发与系统集成相关工作的人员不少于150人，其中大学本科以及以上学历人员所占比例不低于80%；具有计算机信息系统集成项目管理人员资质的人数不少于18名，其中高级项目经理人数不少于4名</li>
</ul>
</li>
<li>三级资质

<ul>
<li>取得四级资质不少于一年</li>
<li>主业是计算机信息系统集成，近三年的系统集成收入总额占营收入总额的比例不低于50%，且近三年系统集成收入总额不少于5000万元</li>
<li>注册资本和实收资本均不少于200万元</li>
<li>近三年至少完成1个合同额不少于300万元的系统集成项目</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于3年</li>
<li>从事软件开发与系统集成相关工作的人员不少于50人，其中大学本科以及以上学历人员所占比例不低于60%；具有计算机信息系统集成项目管理人员资质的人数不少于6名，其中高级项目经理人数不少于1名</li>
</ul>
</li>
<li>四级资质

<ul>
<li>注册资本和实收资本均不少于30万元</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于2年</li>
<li>从事软件开发与系统集成相关工作的人员不少于15人，其中大学本科以及以上学历人员所占比例不低于60%；具有计算机信息系统集成项目管理人员资质的人数不少于2名</li>
</ul>
</li>
</ol>
</li>
<li><strong>中国软件测评中心</strong>和<strong>广州赛宝认证中心服务有限公司</strong>两家评审机构承担<strong>特一级资质</strong>认定的第三方评审工作</li>
<li>一级资质企业获得特一级资质后其拥有的一级资质任然有效，企业必须按照相关规定参与一级资质的年度监督检查和到期换证等工作</li>
<li>项目经理资质管理

<ol>
<li>系统集成项目经理分为项目经理、高级项目经理和资深项目经理3个级别</li>
<li>项目经理

<ol>
<li>需要获得软考证书（系统集成项目管理工程师或者信息系统项目管理师）</li>
<li>至少有两项合同额在200万元以上的系统集成项目</li>
<li>完成系统集成项目总额500万以上</li>
</ol>
</li>
<li>高级项目经理

<ol>
<li>获得项目经理资质不少于3年</li>
<li>至少有一项合同额在1200万元以上的系统集成项目</li>
<li>完成系统集成项目总额3000万以上</li>
</ol>
</li>
<li>资深项目经理

<ol>
<li>获得高级项目经理资质不少于5年</li>
<li>具有硕士以上学位</li>
<li>至少有两项合同额在3000万元以上的系统集成项目或者至少有四项合同额在1500万元以上的系统集成项目</li>
</ol>
</li>
</ol>
</li>
<li><strong>项目经理</strong>可承担合同额在5000万元以下的系统集成项目，<strong>高级项目经理</strong>可承担合同额在5000万以下的系统集成项目，<strong>资深项目经理</strong>可承担各种规模的系统集成项目</li>
<li>系统集成项目经理资质证书有工业和信息化部统一印制</li>
<li>每<strong>两年</strong>对系统集成项目经理资质进行一次<strong>年审</strong>，年审结论分为<strong>合格</strong>、<strong>不合格</strong>、<strong>不在岗</strong>3种</li>
<li>计算机信息系统集成企业资质的三、四级证书应有工业和信息化部印制，由各省市系统集成企业资质主管部门颁发</li>
<li>企业拥有1个信息技术发明专利可等同于3个软件产品登记</li>
</ol>


<h2>信息化概论</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信公众号开发]]></title>
    <link href="http://suda-morris.github.io/blog/2015/09/13/wechat-develop/"/>
    <updated>2015-09-13T21:31:02+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/09/13/wechat-develop</id>
    <content type="html"><![CDATA[<h2>微信接口请求返回格式介绍</h2>

<blockquote><p>微信接口是通过GET方式请求的，返回的数据格式是JSON</p></blockquote>

<h2>常用接口功能</h2>

<ol>
<li>access_token获取接口

<ul>
<li>access_token是公众号的全局唯一票据，龚总好调用各接口时都需要使用access_token</li>
<li>存储至少要保留512个字符空间，有效期目前为2个小时，重复获取将导致上次获取的access_token失效</li>
</ul>
</li>
<li>获取微信服务器IP接口</li>
<li>长链接转短链接接口</li>
<li>获取用户列表</li>
<li>获取用户基本信息(UnionID机制)</li>
<li>网页授权接口

<ul>
<li>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息</li>
<li>两种scope模式：

<ol>
<li>snsapi_base时只能获取到openid</li>
<li>snsapi_userinfo时可获取到其他信息</li>
</ol>
</li>
</ul>
</li>
<li>素材管理接口</li>
<li>高级群发接口

<ul>
<li>两个优点

<ol>
<li>可根据openid群发</li>
<li>群发图文内容支持html</li>
</ol>
</li>
</ul>
</li>
<li>JSSDK接口</li>
<li>模板消息接口</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basic-Analog-Knowledge]]></title>
    <link href="http://suda-morris.github.io/blog/2015/08/20/basic-analog-knowledge/"/>
    <updated>2015-08-20T12:22:41+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/08/20/basic-analog-knowledge</id>
    <content type="html"><![CDATA[<h2>磁珠</h2>

<ol>
<li>全称：铁氧体磁珠滤波器。是一种抗干扰元件，滤除高频噪声效果显著</li>
<li>磁珠有很高的电阻率和磁导率，等效于电阻和电感串联，但电阻值和电感值都随频率变化</li>
<li>磁珠的单位是欧姆，不是亨特，120R~600R之间都很常用</li>
<li>主要特性参数：

<ol>
<li>直流电阻(DCR):直流电流通过此磁珠时，此磁珠所呈现的电阻值</li>
<li>额定电流(mA)</li>
<li>阻抗[z]@100MHz(ohm):这里指的是交流阻抗</li>
<li>阻抗频率特性</li>
<li>电阻频率特性</li>
<li>感抗频率特性</li>
</ol>
</li>
<li>用途：

<ol>
<li>抑制信号线、电源线上的高频干扰和尖峰脉冲。它也具有吸收景点放点脉冲干扰的能力</li>
<li>电感是储能元件，而磁珠时能量转换器件。电感多用于电源滤波回路，侧重于抑制传导性干扰；磁珠多用于信号回路，主要用于EMI(电磁兼容)方面。磁珠用来吸收超高频信号，例如在一些RF电路、PLL、振荡电路、含超高频存储器电路等，都需要在电源输入部分加磁珠</li>
</ol>
</li>
</ol>


<h2>TVS二极管</h2>

<ol>
<li>TVS二极管和常见的文雅二极管工作原理相似，如果高于标志上的击穿电压，TVS二极管就会导通，与稳压二极管相比，TVS二极管具有更高的电流导通能力。TVS二极管的两极收到反向瞬态高能冲击时，以10e-12秒的量级的速度，将其两极间的高阻抗变为低阻抗，同时吸收高达数千瓦的浪涌功率，使得两极之间的电压钳位于一个安全值，有效地保护电子线路中的精密元器件免受浪涌脉冲的破坏</li>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[W5500-Introduce]]></title>
    <link href="http://suda-morris.github.io/blog/2015/08/17/w5500-introduce/"/>
    <updated>2015-08-17T09:50:48+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/08/17/w5500-introduce</id>
    <content type="html"><![CDATA[<h2>W5500网络模块简介</h2>

<ol>
<li>公司：Wiznet</li>
<li>使用硬件逻辑门电路实现TCP/IP协议栈的传输层及网络层（如：TCP，UDP，ICMP，IPv4，ARP，IGMP，PPPoE等协议），并集成了数据链路层，物理层(10BaseT/100BaseTX)，以及32K字节片上RAM作为数据收发缓存，使得上位机主控芯片只需承担TCP/IP应用层控制信息的处理任务，大大节省了上位机对于数据复制、协议处理和中断处理等方面的工作量，提升了系统利用率及可靠性</li>
<li>操作过程中，用户可以近似将W5500作为MCU的一个外设RAM来使用，非常简易。W5500对外接口通常为通用的80MHz高速SPI</li>
<li>W5500支持同时的8个socket，方便和不同的IP和设备进行通讯；为了减小系统能耗，W5500提供了网络环形模式(WOL)以及掉电模式供客户选择使用；W5500是非可攻击性的硬件网络引擎，可以防止类似于洪流，诈骗式以及注入式网络攻击，提高了网络安全</li>
<li>支自动协商(10/100-Based全双工/半双工)</li>
<li>3.3V工作电压，I/O信号口5V耐压</li>
<li>W5500 不支持Auto-MDI-X，也就是不支持交叉直连自动切换，对于某些比较老的设备，可能需要特定的交叉线或者直连线。比如模块连模块，需要使用交叉线，模块连路由器或者交换机需要使用直连线。</li>
<li>W5500不支持自动极性变换功能，因此用户需要使用直连线与交换机或者路由器连接，使用交叉线与终端设备(如服务器，工作站或者其他W5500)相连接。然而用户可以使用任何一种类型的网线与具有自动极性变换的其他设备相连。</li>
<li>W5500以太网芯片的内核由传输层的TCP、UDP、ICMP、IGMP等协议、网络层的IP、ARP、PPPoE等协议以及链路层的MAC构成，再加上物理层的PHY和外围的寄存器、内存、SPI接口组成了这一整套硬件化的以太网解决方案</li>
<li>SPI时钟设定值速率为80MHz，但是高速信号在受电磁串扰和长信号线的影响下可能会失真，实测具有稳定波形的始终速率为33.3MHz</li>
</ol>


<h2>W5500初始化主要使用的几个文件：</h2>

<ol>
<li>W5500_conf.c->主要配置W5500的MAC、IP地址，W5500基本的数据读写过程，复位设置函数等</li>
<li>Socket.c->主要介绍了W5500的SOCKET相关配置函数，比如SOCKET的打开、关闭以及接收数据、发送数据等等</li>
<li>Utility.c->主要介绍了基本的延时函数，还有数据格式转化函数</li>
<li>w5500.c->主要介绍W5500的寄存器读写过程</li>
</ol>


<h2>W5500的Socket初始化</h2>

<ol>
<li>W5500的操作需要设置一下寄存器的参数：

<ol>
<li>模式寄存器(MR)</li>
<li>中断屏蔽寄存器(IMR)</li>
<li>重发时间寄存器(RTR)</li>
<li>重发计数寄存器(RCR)</li>
</ol>
</li>
<li>设置网络信息，下面的寄存器是关于网络的基本设置，需要根据网络环境来进行设置

<ol>
<li>网关地址寄存器(GAR)</li>
<li>本机物理地址寄存器(SHAR)</li>
<li>子网掩码寄存器(SUBR)</li>
<li>本机IP地址寄存器(SIPR)</li>
</ol>
</li>
<li>设置端口存储信息，这一步设置端口TX/RX存储信息，每个端口的基地址和屏蔽地址在这里确定并保存。

<ol>
<li>W5500有一个通用寄存器，8个Socket寄存器区，以及对应每个Socket的收发缓存区。每一个Socket的发送缓存区都在一个16KB的物理接收内存中，初始化分配为2KB。无论给每个Socket分配多达的收发缓存，都必须在16为的偏移地址范围内(0x0000~0xFFFF).16KB的发送内存初始化被分配为每个SOcket 2KB发送缓存区(2KB*8=16KB)。</li>
<li>初始化分配的2KB Socket发送缓存，可以通过使用Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)重新分配，一旦所有的Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)配置完成，16KB的发送内存就会按照配置分配给每个Socket的发送缓存，并按照从Socket0到7顺序分配。16KB物理内存的地址是可以自增的，但是为了避免数据传输错误，需要避免发送缓存大小寄存器(Sn_TXBUF_SIZE)的和超过16</li>
<li>16KB的发送内存中分配了对应Socket n的发送缓存区，用于为来自主机传输的数据做缓存。Socket n发送缓存区的16位偏移地址支持64KB的寻址范围(从0x0000到0xFFFF)</li>
</ol>
</li>
</ol>


<h2>SPI工作协议</h2>

<ol>
<li>SPI协议定义了四种工作模式(模式0，1，2，3)。每种模式的区别是根据SCLK的极性及相位不同定义的。SPI的模式0和模式3唯一不同的就是在非活动状态下，SCLK信号的极性，SPI模式0在时钟空闲状态时钟极性为低电平。SPI的模式0和3，数据都是在SCLK的上升沿锁存，在下降沿输出。W5500支持SPI模式0以及模式3，MISO和MOSI信号无论是接收或者发送，均遵从从最高标志位(MSB)到最低标志位(LSB)的传输序列。</li>
<li>W5500与外设主机的通讯受SPI数据帧控制，W5500的帧分为3段：地址段，控制段，数据段</li>
<li>地址段为W5500寄存器或者TX/RX内存指定的16位的偏移地址。</li>
<li>控制段指定了地址段设定的偏移区域的归属，读写访问模式以及SPI工作模式(可变长度模式/固定长度模式)</li>
<li>数据段可以设定为任意长度(N字节)或者是固定长度：1字节，2字节或4字节；如果SPI工作模式设置为可变数据长度模式(VDM),SPI的SCSn信号需要由外部主机通过SPI帧控制。</li>
<li>在可变长度模式下，SCSn控制SPI帧的开始和停止：

<ol>
<li>SCSn信号拉低，即代表W5500的SPI帧开始(地址段)</li>
<li>SCSn信号拉低，即代表W5500的SPI帧结束(数据段的随机N字节数据结尾)</li>
</ol>
</li>
<li>W5500的SPI数据帧包括了16为地址段的偏移地址，8为控制段和N字节数据段。8为控制段可以通过修改区域选择位(BSB[4:0]),读写访问模式位(RWB)以及SPI工作模式位(OM[1:0])来重新定义。区域选择位选择了归属于偏移地址的区域</li>
<li>W5500支持数据的连续读写。其流程为数据从(2/4/N字节连续数据的)偏移地址的基址开始传输，偏移地址会自增寻址(加1)传输接下来的数据</li>
<li>SPI数据帧控制段对应位的说明：

<ol>
<li>区域选择位BSB[4:0]-> 【00000】= 通用寄存器；【00001】= Socket0寄存器；【00010】=Socket0发送缓存；【00011】=Socket0接收缓存；【00101】=Socket1寄存器；【00110】=Socket1发送缓存；【00111】=Socket1接收缓存；【01001】= Socket2寄存器；【01010】=Socket2发送缓存；【01011】=Socket2接收缓存；【10101】=Socket3寄存器；【01110】=Socket3发送缓存；【01111】=Socket3接收缓存；【10001】= Socket4寄存器；【10010】=Socket4发送缓存；【10011】=Socket4接收缓存；【10101】=Socket5寄存器；【10110】=Socket5发送缓存；【10111】=Socket5接收缓存；【11001】= Socket6寄存器；【11010】=Socket6发送缓存；【11011】=Socket6接收缓存；【11101】=Socket7寄存器；【11110】=Socket7发送缓存；【11111】=Socket7接收缓存；</li>
<li>读写访问模式位RWB-> 【0】=读；【1】=写</li>
<li>工作模式位OM[1:0]-> 【00】=可变数据长度模式，N字节数据段(1≤N)；【01】=固定数据长度模式，1字节数据长度(N=1)；【10】=固定数据长度模式，2字节数据长度(N=2)；【11】=固定数据长度模式，4字节数据长度(N=4)；</li>
</ol>
</li>
<li>W5500有一个通用寄存器，8个Socket寄存器，以及对应每个Socket的收发缓存区。每个区域均通过SPI数据帧的区域选择位BSB[4:0]来选取。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212635.png" alt="SPI模式0/3" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212850.png" alt="SPI数据帧" /></li>
</ol>


<h2>物理层</h2>

<blockquote><p>由计算机和网络介质之间的实际界面组成，可定义电器信号、符号、线的状态和时钟要求、数据编码和数据传输用的连接器。如最常用的RS-232规范、10BASE-T的曼彻斯特编码以及RJ-45就属于这一层。</p></blockquote>

<h2>数据链路层</h2>

<blockquote><ol>
<li>数据链路层通过物理网络链路提供可靠的数据传输。不同的数据链路层定义了不同的网络和协议特征，其中包括物理编址、网络拓扑结构、错误校验、帧序列以及流控</li>
<li>以太网协议规定，一组电信号构成一个数据包，叫做“帧”，每一帧分成三个部分：以太网首部、数据及以太网尾部。</li>
<li>以太网首部包含数据帧的一些说明，比如发送者、接收者、数据类型等等；数据部分则是数据的具体内容；以太网尾部则是CRC校验码</li>
<li>以太网首部的长度固定为14字节。数据的长度最短为46字节，最长为1500字节。以太网尾部的长度固定为4字节。因此，整个数据帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送</li>
<li>数据链路层实际上由两个独立的部分组成：介质存取控制(MAC)和逻辑链路控制(LLC)。MAC描述在共享介质环境中如何进行站的调度、发生和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据流向。一般来讲，MAC只在共享介质环境中才是重要的，只有在共享介质环境中多个节点才能连接到同一传输介质上。</li>
<li>一块网卡如何知道另一块网卡的MAC地址?ARP协议(网络层)可以解决这个问题。以太网数据帧必须知道接收方的MAC地址然后才能发送。有了数据帧的定义，网卡的MAC地址，广播的发送方式，数据链路层就可以在多台计算机之间传送数据了</li>
</ol>
</blockquote>

<h2>网络层</h2>

<blockquote><ol>
<li>网络层负责在源和终点之间建立连接。它一般包括网络寻址，还可能包括流量控制、错误检查等。相同MAC标准的不同网段之间的数据传输一般只涉及到数据链路层，而不同的MAC标准之间的数据传输都涉及到网络层。IP路由器工作在网络层，因为可以实现多种网络间的互联。</li>
<li>IP数据包分为“标头”和“数据”两个部分。标头部分主要包括版本、长度、IP地址等细心，数据部分则是IP数据报的具体内容。IP数据报的标头部分长度为20到60字节，整个数据报的总长度最大为65535字节，因此理论上，一个数据报的数据部分最长为65515字节。以太网数据帧的数据部分最长只有1500字节，因此如果IP数据报超过了1500字节，它就要分割成几个以太网数据帧分开发送了。</li>
</ol>
</blockquote>

<h2>传输层</h2>

<blockquote><ol>
<li>传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能一般包括流控、多路传输、虚电路管路以及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接受设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到物理链路上；虚电路由传输层建立、维护和终止；差错校验包括为检测传输错误而建立的各种不同结构；而差错回复包括所采取的行动，以便解决发生的任何错误。</li>
<li>必须要在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，UDP数据段也是有“标头”和“数据”两部分组成</li>
<li>标头部分主要定义了发出端口和接收端口，“数据”部分就是具体的内容，然后把整个UDP数据段放入IP数据报的“数据”部分，而IP数据报又是放在以太网数据帧之中的。</li>
<li>UDP数据段非常简单，标头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据报</li>
<li>为了提高网络可靠性，诞生了TCP协议，这个协议非常复杂，但可以近似认为，他就是有确认机制的UDP协议，没发出一个数据都要求确认。如果有一个数据缺失，就收不到确认，发送方就知道有必要重发这个数据了</li>
<li>TCP数据段没有长度限制，理论上可以无限长，但是为了保证网络的效率。通常TCP数据段的长度不会超过IP数据报的长度，以确保单个TCP数据段不必再分割。</li>
</ol>
</blockquote>

<h2>应用层</h2>

<blockquote><p>应用层是最接近终端用户的第一层，这就意味着应用层与用户之间是通过应用软件直接相互作用。应用层并非由计算机上云sing的实际应用软件组成，而是由向应用程序提供访问网络资源的API组成。</p></blockquote>

<h2>寄存器</h2>

<h3>W5500通用寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823140450.png" alt="W5500通用寄存器" /></p>

<h3>Socket寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823141841.png" alt="Socket寄存器" /></p>

<ol>
<li>通用寄存器区配置了W5500的基本信息，如IP以及MAC地址</li>
<li>W5500支持8个Socket作为通讯信道，每一个Socket通过Socket n寄存器控制。Socket n寄存器可以通过SPI数据帧中的区域选择寄存器BSB[4:0]来选定对应的寄存器n。</li>
</ol>


<h2>TCP/IP协议族</h2>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgW5500%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95%E6%9D%BF%E6%95%99%E7%A8%8B.png" alt="TCP/IP协议族" /></p>

<h2>TCP协议</h2>

<ol>
<li>TCP协议通过三个报文段完成连接的建立，这个过程称为三次握手。TCP连接建立过程：

<ol>
<li>第一次握手：建立连接时，客户端发送SYN包(seq=j)到服务器，并进入SYN_SEND状态，等待服务器确认</li>
<li>第二次握手：服务器收到SYN包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(seq=k),即SYN+ACK包，此时服务器进入SYN_RECV状态</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISH状态，完成三次握手</li>
</ol>
</li>
<li>终止一个TCP连接需要四次挥手，这是由TCP的半关闭(half-close)造成的

<ol>
<li>第一次挥手：主动方发出设置了FIN位的报文，表示主动终止从本地到远端的单向链接；此时主动方进入FIN_WAIT1状态，意思是它在等待远端的FIN报文</li>
<li>第二次挥手：远端收到FIN后，会立即发送ACK；主动方收到ACK后，进入FIN_WAIT2状态，所以FIN_WAIT1状态持续的时间非常短；此时远端进入CLOSE-WAIT状态，一条单向链接终止了，但另一条还没有，处于HALF-CLOSE连接状态</li>
<li>第三次挥手：当远端进行了必要的数据发送后，它发送FIN，表示它出发的单向连接也要关闭，同时它进入LAST_ACK状态</li>
<li>第四次挥手：主动方收到FIN后，回应一个ACK；远端就此进入CLOSED状态，连接关闭；主动方进入TIME WAIT状态，确保最后一个ACK没有丢失，防止新连接占用刚刚关闭的主动方的地址端口，使得网络中流浪的老连接的返祖被误认为新连接的分组</li>
</ol>
</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手/四次挥手" /></li>
<li>当W5500初始化完成后，程序进入主循环，此时读取Socket的状态值，并选择进入哪种模式。当Socket处于关闭状态时，在进行通信之前，我们先将该Socket初始化，这个Socket作为服务器端，端口号要固定为侦听的端口。当socket将处于初始化完成状态，即SOCK_INIT状态，此时，作为TCP服务器就要执行listen()函数来侦听端口。由于W5500内嵌了TCP/IP协议，连接过程是不需要单片机干预的。如果连接过程中出错造成超时，该Socket将会被关闭，重新进入SOCK_CLOSE状态。待TCP连接的3次握手完成后，socket的状态将会转变为连接建立状态，即代码中定义的SOCK_ESTABLISHED状态。在进入SOCK_ESTABLISHED状态后，便可进行数据收发。数据通信完毕之后执行disconnect()函数，在收到对方FIN数据包之前，该socket将进入SOCK_CLOSE_WAIT状态。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPServer%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPServer流程图" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPClient%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPClient流程图" /></li>
</ol>


<h2>UDP协议</h2>

<ol>
<li><img src="http://i.imgur.com/ceIUeSz.png" alt="UDP通信流程图" /></li>
<li>当socket处于关闭状态时，在进行通信之前我们先将该UDP模式的socket端口初始化。当socket将处于初始化完成状态即SOCK_UDP状态，此时就可以通过广播方式发送数据了。</li>
<li><img src="http://i.imgur.com/FxqWkWp.png" alt="UDP报文" /></li>
</ol>


<h2>DHCP协议</h2>

<ol>
<li>W5500作为DHCP客户端，路由器作为DHCP服务器端，在DHCP请求的过程中，包括4个主要阶段：发现阶段、提供阶段、选择阶段以及确认阶段</li>
<li>首次W5500客户端发送DHCPDISCOVER消息(IP地址租用申请)，这个消息通过广播方式发出，所有网络中的DHCP服务器都将接收到这个消息。随后，网络中的DHCP服务器会回应一个DHCPOFFER消息(IP地址租用提供)，由于这个时候客户端还没有网络地址，所以DHCPOFFER也是通过广播的方式发送出去的。然后，向该服务器发送DHCPREQUEST消息。在DHCPREQUEST消息中将包含客户端申请的IP地址。最后，DHCP服务器将会送DHCPACK的相应消息来通知客户端可以使用该IP地址，该确认里面包含了分配的IP地址和该地址的一个稳定期限的租约(默认是8天)，并同时更新DHCP数据库</li>
<li>DHCP初始化完成以后，通过获取DHCP_SOCKET的状态来获取动态IP地址。第一个状态DHCP_RET_NONE就是获取不成功，第二个状态DHCP_RET_TIMEOUT是获取IP地址超时，都不符合条件。第三个状态DHCP_RET_UPDATE就是获取动态IP地址成功，此时将得到的IP地址通过SPI写入W5500的寄存器。如果是DHCP_RET_CONFLICT冲突状态，就要返回DHCP服务重新获取</li>
<li><img src="http://i.imgur.com/sqc1tce.jpg" alt="DHCP报文格式" /></li>
<li>报文格式解析：

<ol>
<li>OP：若是client送给server的封包，设为1，反之为2</li>
<li>HTYPE：硬件类别，10MB以太网为1，100MB以太网为2</li>
<li>HLEN：硬件地址长度，Ethernet为6</li>
<li>HOPS：若封包需要经过router传送，每站加1，若在同一网段内，为0</li>
<li>TRANSACTION ID：DHCP REQUEST时产生的数值，以作为DHCPREPLY时的依据</li>
<li>SECONDS：Client端启动时间(秒)</li>
<li>FLAGS：从0到15共16bits，最左1bit为1时表示server将以广播方式传送封包给client，其余尚未使用</li>
<li>ciaddr：yhaoshiclient端想继续使用之前取得的IP地址，则列于这里</li>
<li>yiaddr：从server送回client的DHCP OFFER与DHCPACK封包中，此栏填写分配给client的IP地址</li>
<li>siaddr：若client需要透过网络开机，从server送出的DHCP OFFER、DHCPACK、DHCPNACK封包中，此栏填写开机程序代码所在server的地址</li>
<li>giaddr：若需跨网域进行DHCP发放，此栏为relay agent的地址，否则为0</li>
<li>chaddr：client的硬件地址</li>
<li>sname：sever的名称字符串，以0x00结尾</li>
<li>file：若client需要透过网络开机，此栏将指出开机程序名称，稍后以TFTP传送</li>
<li>options：允许厂商定义选项，提供更多的设定信息，其长度可变，同时可携带多个选项，每一个选项的第一个字节为信息代码，其后一个自己为该项数据长度，最后为项目内容</li>
</ol>
</li>
</ol>


<h2>DNS协议</h2>

<ol>
<li>客户端初始化完毕之后，如果DNS运行标志位是1或者DNS发送次数超过3次就直接返回。如果不是上面的情况，并且DNS Server的IP不是0.0.0.0时，进入switch函数。当处于DNS域名解析成功状态时，DNS_OK置1，发送请求报文次数置0。当DNS解析域名失败时，标志位置0，请求报文次数加1，然后跳出循环。</li>
<li>DNS报文格式：<img src="http://i.imgur.com/C48NfJR.jpg" alt="DNS报文格式" />

<ul>
<li>标识：DNS报文的ID，对于相关联的请求报文和应答报文，这个字段是相同的</li>
<li>标志：<img src="http://i.imgur.com/ZaPageY.jpg" alt="标志字段" />

<ul>
<li>QR：查询/响应的标志位，1为响应，0为查询</li>
<li>opcode：定义查询或响应的类型(若为0则表示是标准的，若为1则是反向的，若为2则是服务器状态请求)</li>
<li>AA：授权回答的标志位，该位在相应报文中有效，1表示名字服务器是权限服务器</li>
<li>TC：截断标志位，1表示响应以超过512字节并已经被截断</li>
<li>RD：只能在响应报文中置1，表示可以得到递归响应</li>
<li>zero：0，保留字段</li>
<li>rcode：返回码，表示响应的差错状态，0表示无差错，1表示格式差错，2表示问题在域名服务器上，3表示域参照问题，4表示查询类型不支持，5表示在管理上被禁止</li>
</ul>
</li>
<li>问题数、资源记录数、授权资源记录数和额外资源记录数，这四个字段都是两字节，分别对应下面的查询问题、回答、授权和额外信息部分的数量。一般问题数都为1，DNS查询报文中，资源记录数、授权资源记录数和额外资源记录数都为0.</li>
<li>查询问题部分的格式：<img src="http://i.imgur.com/qkVuppN.gif" alt="查询问题格式" />

<ul>
<li>查询名部分长度不定，一般为要查询的域名，有时候也有IP的时候，即反向查询。此部分由一个或者多个标识符序列组成，每个标识符以首字节数的计数值来说明该标识符长度，每个名字以0结束。技术字节数必须在0~63之间</li>
<li>查询类型：

<ul>
<li>1：IPv4地址</li>
<li>2：名字服务器</li>
<li>5：规范名称</li>
<li>6：开始授权，标记一个区的开始</li>
<li>11：熟知服务，定义主机提供的网络服务</li>
<li>12：指针，把IP地址转化为域名</li>
<li>13：主机信息，给出主机使用的硬件和操作系统的表述</li>
<li>15：邮件交换，把邮件改变路由送到邮件服务器</li>
<li>28：IPv6地址</li>
<li>252：传送整个区的请求</li>
<li>255：对所有记录的请求</li>
</ul>
</li>
<li>查询类：通常为1，指Internet数据</li>
</ul>
</li>
<li>回答字段，授权字段和附加信息字段均采用资源记录的相同格式：<img src="http://i.imgur.com/WuZQrVt.gif" alt="资源记录格式" />

<ul>
<li>域名字段(不定长或者2字节)：记录资源数据对应的名字，它的格式和查询名字段格式相同。当报文中域名重复出现时，就需要使用2字节的偏移指针来替换。</li>
<li>类型、类：含义与查询问题部分的类型和类相同</li>
<li>生存时间：该字段表示资源记录的生命周期，一般用于当地址解析程序取出资源记录后决定保存以及使用缓存数据的时间</li>
<li>资源数据长度：表示资源数据的长度，以字节为单位，如果资源数据为IP则为0004</li>
<li>资源数据：该字段是可变长字段，表示按查询段要求返回的相关资源记录的数据</li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>SMTP协议</h2>

<ol>
<li><img src="http://i.imgur.com/9TsOlUJ.png" alt="邮件发送过程示意图" /></li>
<li>SMTP在TCP协议25号端口监听连续请求。SMTP连接和发送过程：

<ol>
<li>建立TCP连接</li>
<li>客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端正希望以OK作为相应，表明准备接收</li>
<li>客户端发送RCPT命令，以表示该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件</li>
<li>协商结束，发送邮件，用命令DATA发送</li>
<li>以“.”号表示结束并将内容一起发出去，结束此次发送，用QUIT命令退出</li>
</ol>
</li>
</ol>


<h2>ICMP协议</h2>

<ol>
<li>ICMP是Internet控制报文协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令，这个ping的过程实际上就是ICMP协议工作的过程。Ping命令利用ICMP回射请求报文和回射应答报文来测试目标系统是否可达。</li>
<li>执行ping后，首先向目标服务器发出回送请求报文。计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求。这个ICMP回送回答报文在IP层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP地址字段被交换了，类型字段里填入了表示回送回答的0，这两点，也就是，从送信方式来看，自己送出的ICMP报文从目标服务器哪里像鹦鹉学舌那样原样返回了</li>
</ol>


<h2>Http协议</h2>

<ol>
<li>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。</li>
<li>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</li>
<li>请求报文格式如下：请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体</li>
<li>应答报文格式如下：状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</li>
<li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF</li>
<li>请求方法有多种：

<ol>
<li>GET 请求获取Request-URI所标识的资源</li>
<li>POST 在Request-URI所标识的资源后附加新的数据</li>
</ol>
</li>
<li>状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF 其中Status-Code标识服务器发回的响应状态代码；Reason-Phrase标识状态代码的文本描述</li>
<li>状态码有三位数字组成，第一个数字定义了响应的类别，且有5种可能取值：

<ol>
<li>1xx：指示信息，标识请求已接收，继续处理</li>
<li>2xx：成功，标识请求已被成功接收、理解、接受</li>
<li>3xx：重定向，要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误，请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误，服务器位能实现合法的请求</li>
</ol>
</li>
<li>常见状态码、状态描述、说明

<ol>
<li>200 OK 客户端请求成功</li>
<li>400 Bad Request 客户端请求有语法错误，不能被服务器理解</li>
<li>401 Unauthorized 请求未经授权，这个状态码必须和WW-Authenticate报文域一起使用</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found 请求资源不存在</li>
<li>500 Internal Server Error 服务器发生不可预期的错误</li>
<li>503 Server Unavaliable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ol>
</li>
<li>普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。

<ol>
<li>Cache-Control用于指定缓存指令，缓存指令是单向的，而且是独立的。

<ul>
<li>请求时的缓存指令包括：no-cache(用于指示请求或响应消息不能缓存)、no-store、max-age、max-stale、min-fresh、only-if-cached</li>
<li>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage</li>
</ul>
</li>
<li>Date普通报头域表示消息产生的日期和时间</li>
<li>Connection普通报头域允许发送指定连接的选项，例如指定连接是连续或者指定“close”选项，通知服务器，在响应完成后，关闭连接。在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</li>
</ol>
</li>
<li>请求报头允许客户端向服务器传递请求的附加信息以及客户端自身的信息，常用的请求报头：

<ol>
<li>Accept：用于指定客户端接收哪些类型的信息，Accept:image/gif表明客户端希望接收GIF图像格式的资源；Accept:text/html表明客户端希望接收html文本</li>
<li>Accept-Charset：用于指定客户端接受的字符集，如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受</li>
<li>Accept-Encoding：指定可接受的内容编码</li>
<li>Accept-Language：指定一种自然语言</li>
<li>Authorization：用于证明客户端有权查看某个资源，当浏览器访问一个页面时，如果收到服务器的响应代码为401，可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证</li>
<li>Host:发送请求是，该报头域是必须的，主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回</li>
<li>User-Agent：该请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器，不过，这个报头域不是必须的，如果我们自己编写一个浏览器，不适用User-Agent请求报头域，那么服务器端就无法得知我们的信息了</li>
</ol>
</li>
<li>请求报头举例：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>GET /form.html HTTP/1.1 (CRLF)
</span><span class='line'>Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)
</span><span class='line'>Accept-Language:zh-cn (CRLF)
</span><span class='line'>Accept-Encoding:gzip,deflate (CRLF)
</span><span class='line'>If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)
</span><span class='line'>If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)
</span><span class='line'>User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)
</span><span class='line'>Host:www.guet.edu.cn (CRLF)
</span><span class='line'>Connection:Keep-Alive (CRLF)
</span><span class='line'>(CRLF)
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>响应报头允许服务器传递不能放在状态行中的附件响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息；常用的响应报头：

<ol>
<li>Location用于重定向接收者到一个新的位置，Location响应报头域常用在更换域名的时候</li>
<li>Server包含了服务器用来处理请求的软件信息，与User-Agent请求报头域是相对应的</li>
<li>WWW-Authenticate响应报头域西粗被包含在401响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时候，服务端响应报头就包含该报头域</li>
</ol>
</li>
<li>实体报头。请求和响应消息都可以传送一个实体，一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。常用的实体报头：

<ol>
<li>Content-Encoding：被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip</li>
<li>Content-Language：实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:da</li>
<li>Content-Length：实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示</li>
<li>Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型</li>
<li>Last-Modified：实体报头域用于指示资源的最后修改日期和时间</li>
<li>Expires：实体报头域给出响应过期的日期和时间。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0</li>
</ol>
</li>
<li>HTTP协议通常是承载于TCP洗衣之上的，有时也承载于TLS或SSL协议层之上，这时称之为HTTPS协议。默认HTTP的端口号为80，HTTPS的端口号为443</li>
<li><img src="http://i.imgur.com/PiBPPM0.png" alt="HTTP请求报文" /></li>
<li><img src="http://i.imgur.com/EZ63EEL.png" alt="HTTP响应报文" /></li>
<li>GET与POST方法有以下区别：

<ol>
<li>Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</li>
<li>在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交</li>
<li>GET方式提交的数据最多只能有1024字节，而POST则没有此限制</li>
</ol>
</li>
<li></li>
</ol>


<h2>NetBIOS</h2>

<p><img src="http://i.imgur.com/OAHwfCG.png" alt="NetBIOS实现过程" /></p>

<ol>
<li>NetBIOS协议是一种在局域网上的程序可以使用的应用程序编程接口，为v横须提供了请求低级服务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能，几乎所有的局域网都是在NetBIOS协议的基础上工作的。NetBIOS协议，简单来说就是通过访问设备名称就可以实现对IP地址的访问。</li>
<li>在Windows操作系统中，默认情况下在安装TCP/IP协议后会自动安装NetBIOS协议。</li>
<li>ping主机名的第一个数据包就是NBNS(NetBIOS Name Server)协议包，它是TCP/IP上的NetBIOS协议族的一部分，它在基于NetBIOS名称访问的网络上提供主机名和地址映射方法。NBNS是动态DNS的一种。Microsoft的NBNS实现称为WINS。NetBIOS的报文类型较多，结构复杂，在不同的网络化境和不同的用途中会使用不同的报文，可用端口进行区分。如图所示NetBIOS协议架构
<img src="http://i.imgur.com/MxZkqby.jpg" alt="NetBIOS协议架构" /></li>
<li>NetBIOS数据报有很多不同格式，主要取决于服务和信息类型，以及用以传送NetBIOS数据报的传输协议。NetBIOS协议架构包含三种基本服务：NAME、SESSION和DATAGRAM，其中NAME所用协议就是NBNS协议</li>
<li>WINS协议使用的报文即为NetBIOS的名字报文，其总体格式如下图所示
<img src="http://i.imgur.com/i2pWvfO.png" alt="NetBIOS名字报文格式" />其中2字节通用标志中更详细的字段划分为：操作代码(5bits)操作标志(7bits)结果代码(4bits)

<ol>
<li>事物ID：请求方为每次名字服务请求所设定的ID值，响应方在相应的响应报文中要填入这个事物ID值</li>
<li>操作代码：指示报文的类型,最高位为0表示数据包为Reauest请求，最高位为1表示数据包为Response应答，其余4个比特均为0</li>
<li>操作标志：操作标志位，最低位为1表示广播或者多播，最低位为0表示单播，其他位均为0</li>
<li>结果代码：在相应报文中指示请求的结果，一般为0</li>
<li>问题记录个数：请求查询问题的个数，对于Request数据包，该值为1，对于Response数据包，该值为0</li>
<li>回答记录个数：对于Response数据包有用，Response数据包中响应问题的个数，一般为1</li>
<li>权威记录个数：在权威记录部分的记录数量，用不到的时候为0</li>
<li>附加记录个数：在附加记录部分数量，用不到的时候为0</li>
</ol>
</li>
<li>报文的前12字节总称NetBIOS名字报文的首部，通过首部可以判断是否为名字查询的报文。NetBIOS名字报文中最常见的是携带问题记录的报文，问题记录的格式是：问题名称(若干字节) 问题类型(2字节) 问题类别(2字节)。通过携带问题记录的报文，我们可以得到要查询的名字字符，如果和本机名相符，就发送报文响应，相应中带有IP地址，发送广播的主机就会得到该IP地址</li>
<li>NETBIOS会话报文具有通用的4字节首部和与类型相关的报文内容：类型(1字节) 标志(1字节) 长度(2字节) 内容(若干字节)

<ol>
<li>类型：指名NetBIOS会话报文的类型，可用的值有：

<ul>
<li>0x00:会话消息</li>
<li>0x81:会话请求</li>
<li>0x82:正面会话响应</li>
<li>0x83:负面会话响应</li>
<li>0x84:重定向会话响应</li>
<li>0x85:会话保活</li>
</ul>
</li>
<li>标志：0~6位保留未用，第7位作为扩展的长度位，使NetBIOS会话报文的内容部分最多可以达到128K字节</li>
<li>长度：NetBIOS会话报文的内容部分的长度，不包括首部的4字节</li>
</ol>
</li>
<li><img src="http://i.imgur.com/O24egoi.png" alt="NBNS" />计算机1向计算机2的137端口发送一个NODE STATUS REQUEST请求数据包，计算机2收到该数据包后，向计算机1返回一个NODE STATUS RESPONSE响应数据包，该数据包中包含计算机2的MAC地址、机器地址、所属的工作组等信息</li>
<li>NODE STATUS REQUEST数据包由12字节的HEADER域和38字节的QUESTION ENTRIES域两个部分组成，HEADER域分为8个字段：
<img src="http://i.imgur.com/VKpTVaA.png" alt="NetBIOS HEADER" /></li>
<li>QUESTION ENTRIES域组成
<img src="http://i.imgur.com/93RGC0D.png" alt="QUESTION ENTRIES" />其中：

<ul>
<li>QUESTION_NAME为要查询的远程计算机的名称，长度为34字节。NBNS规定，计算机NetBIOS的名称不超过16字节，且最后一个字节必须为0x0；</li>
<li>QUESTION_TYPE对于REQUEST数据包取值为0x0021</li>
<li>QUESTION_CLASS取值为0x0001</li>
</ul>
</li>
<li>当某台机器的137端口收到NODE STATUS REQUEST请求数据包之后，由该机器的NETBIOS服务随即生成并返回一个NODE STATUS RESPONSE响应数据包。该响应数据包由HEADER域和RESOURCE RECORD域两部分组成。RESOURCE RECORD域组成如图所示：
<img src="http://i.imgur.com/IPEjagx.png" alt="RESOURCE RECORD" />

<ul>
<li>RP_NAME：34字节，与Request数据包的QUESTION_NAME格式定义相同</li>
<li>RP_TYPE：与Request数据包中的QUESTION_TYPE字段相同</li>
<li>RP_CLASS：与前面Request数据包的QUESTION_CLASS字段取值相同</li>
<li>TTL：4字节，取值为0x00000000</li>
<li>RDLENGTH:表示从NUM_NAMES字段开始到整个RESOURCE RECORD结束共有多少个字节</li>
<li>NUM_NAMES：表示紧随其后的NODE_NAME ARRAY数组的元素个数，数组的每个元素具有NODE_NAME结构，如图所示为NODE_NAME结构：
<img src="http://i.imgur.com/ArSP1Xp.png" alt="NODE_NAME" /></li>
<li>NETBIOS FORMAT NAME表示远程主机的机器名或者组名，具体依赖NAME_FLAG字段的取值；</li>
<li>NAME_FLAGs：当最高位为1时，NETBIOS FORMAT NAME字段中存储的是Group NetBIOS名称，即工作组名，当最高位为0时，NETBIOS FORMAT NAMR字段中存储的是机器名</li>
<li>STATICS：包含的字段非常多，开始6字节是远程主机的MAC地址</li>
</ul>
</li>
</ol>


<h2>SNTP协议</h2>

<ol>
<li>SNTP是简单网络时间协议，是用来使设备时间同步化的一种协议，在一些应用场合里，时间同步时十分重要的，贴别是随着设备运行时间增长，时间误差就越来越大，因为设备中晶振自身会产生误差，那么SNTP协议就可以解决这个问题。</li>
<li>报文格式：<img src="http://i.imgur.com/y9GprbA.gif" alt="SNTP报文格式" />

<ul>
<li>LI: 跳跃指示器</li>
<li>VN：版本号</li>
<li>Mode：模式

<ul>
<li>0——预留</li>
<li>1——对称行为</li>
<li>3——客户机</li>
<li>4——服务器</li>
<li>5——广播</li>
<li>6——NTP控制信息</li>
</ul>
</li>
<li>Stratum：对本地时钟级别的整体识别</li>
<li>Poll：有符号整数表示连续信息间的最大间隔</li>
<li>Precision：有符号整数表示本地时钟精确度</li>
<li>Root Delay：有符号固定点序号表示主要参考源的总延迟，很短时间内的位15到16间的分段点</li>
<li>Root Dispersion：无符号固定点序号表示相对主要参考源的正常差错，很短时间内的位15到16间的分段点</li>
<li>Reference Identifier：识别特殊参考源</li>
<li>Originate Timestamp：这是向服务器请求分离客户机的时间，采用64位时标格式</li>
<li>Receive Timestamp：这是向服务器请求到达客户机的时间，采用64位时标格式</li>
<li>Transmit Timestamp：这是客户机答复分离服务器的时间，采用64位时标格式</li>
<li>Authenticator：当实现了NTP认证模式主要标识符和信息数字域就包括已定义的信息认证代码信息</li>
</ul>
</li>
<li>原理图：<img src="http://i.imgur.com/kKI2sUY.png" alt="SNTP原理示意图" /></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cadence-Allegro]]></title>
    <link href="http://suda-morris.github.io/blog/2015/07/27/cadence-allegro/"/>
    <updated>2015-07-27T21:55:59+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/07/27/cadence-allegro</id>
    <content type="html"><![CDATA[<h2>Cadence简介</h2>

<ol>
<li>Cadence公司著名的软件有Cadence Allegro（布局布线设计工具），Cadence LDV，Cadence IC，Cadence OrCAD等</li>
<li>整个软件系统主要功能模块：

<ol>
<li>Design Entry HDL：提供了一个原理图输入和分析环境</li>
<li>Design Entry CIS：是Cadence收钩原OrCAD公司的产品，是国际上通用的标准的原理图输入工具，与Allegro实现了无缝连接</li>
<li>Design Entry HDL Rules Checker：Design Entry HDL的规则检查工具</li>
<li>Library Explorer：进行数字设计库管理的软件，可以调用Design Entry HDL、PCB Librarian、PCB Designer、Allegro System Architect等工具建立的元件符号和模型</li>
<li>Package Designer：芯片和封装的设计分析软件</li>
<li>PCB Editor：高性能PCB设计软件</li>
<li>PCB Librairan：Allegro库开发</li>
<li>PCB Router：CCT布线器</li>
<li>PCB SI：提供一个集成的高速设计与分析环境</li>
<li>Physical Viewer：Allegro浏览器模块</li>
<li>Project Manager：Design Entry HDL的项目管理器</li>
<li>AMS Simulator：工业标准的模拟、数字及模拟/数字混合信号仿真系统</li>
<li>PCB Editor Utilities：包含Pad Designer、DB Doctor和Bach DRC等工具</li>
</ol>
</li>
</ol>


<h2>快捷键</h2>

<ol>
<li>原理图编辑：

<ol>
<li>原理图放大：I，或者Ctrl+滚轮向上滚</li>
<li>原理图缩小：O，或者Ctrl+滚动向下</li>
<li>原理图向上走：PGUP</li>
<li>原理图向下走：PGDN</li>
<li>原理图向左走：Ctrl+PGUP</li>
<li>原理图向右走：Ctrl+PGDN</li>
<li>元器件旋转，变换方向：R</li>
<li>元器件复制拖动：Ctrl+拖动</li>
<li>元器件更新：

<ol>
<li>replace：元起价信息包括封装全部更新</li>
<li>update：只会更新元器件基本细心，封装信息不会更新</li>
</ol>
</li>
</ol>
</li>
<li>SCH库编辑：

<ol>
<li>进入下一个分片元件的编辑：Ctrl+N</li>
<li>返回上一个分片元件的编辑：Ctrl+B</li>
</ol>
</li>
</ol>


<h2>补充知识</h2>

<ol>
<li>0.1inch = 2.54mm</li>
<li>总线的命名：Basename[0:len-1]表示总线名Basename，位长len</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TL-WR740N刷机救砖指南]]></title>
    <link href="http://suda-morris.github.io/blog/2015/07/22/tl-wr740n/"/>
    <updated>2015-07-22T09:51:38+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/07/22/tl-wr740n</id>
    <content type="html"><![CDATA[<h2>型号</h2>

<blockquote><p>Flash：4MB，DRAM：32MB，CPU：AR7240，Baud：115200</p></blockquote>

<h2>固件下载</h2>

<p><a href="http://www.dd-wrt.com/site/support/router-database">下载地址</a></p>

<h2>TTL刷机命令</h2>

<ol>
<li>上电连续输入TPL三个字母知道进入uboot界面停住</li>
<li>tftpdboot 0x80000000 [固件名称]</li>
<li>erase 0x9f020000 +0x3c0000</li>
<li>cp.b 0x80000 0x9f020000 0x3c0000</li>
<li>bootm 0x9f020000</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux_Kernel]]></title>
    <link href="http://suda-morris.github.io/blog/2015/07/20/linux-kernel/"/>
    <updated>2015-07-20T23:30:54+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/07/20/linux-kernel</id>
    <content type="html"><![CDATA[<h2>内核make流程</h2>

<ol>
<li>make %config和make menuconfig的目的是为了生成.config文件，而Kconfig作为生成make menuconfig等图形配置界面工具而存在</li>
<li>.config 文件中决定了内核中的哪些代码被编译进内核，哪些代码被当做模块编译</li>
<li>make根据.config中的描述，通过解析Makefile文件来进行编译，最终生成zImage文件</li>
<li>流程中设计的文件与命令，再加上Linux内核的scripts目录构成了内核的Kbuild机制，内核通过这种方式，最终编译得到内核镜像文件zImage</li>
</ol>


<h2>KBuild机制实现原理</h2>

<ol>
<li>从编译过程来看，每一个被编译的目录下都会生成一个build-in.o文件，他们都由自己目录下的源代码编译生成，所有目录下的build-in.o文件最终链接生成vmlinux文件，最后由内核压缩程序加工vmlinux生成内核压缩镜像文件zImage</li>
<li>总原理来看，Kbuild机制只会把obj-y的值编译进内核。每个Makefile文件中都有这个变量，只不过obj-后面一半都跟着一个变量，这个变量的值来自于.config。</li>
<li>待编译目录下的Makefile，如有Kbuild，则Kbuild优先，唯一使用Kbuild而不是Makefile的就是顶层目录</li>
</ol>


<h2>Kconfig语法</h2>

<ol>
<li>config

<ul>
<li>为menu或者choice中的一个选项条目</li>
<li>config后面常跟一个变量名，比如ARM，那么在.config中将以CONFIG_ARM=y或n的形式出现</li>
<li>下一行写该变量的取值类型,可以是bool,tristate,string,hex,int</li>
<li>default为变量缺省值，可以被用户设置值覆盖</li>
<li>prompt后边是出现在配置菜单中的对应于一个配置选项的文字，没有prompt条目，将使得用户不能在配置界面中显示并配置该配置选项</li>
<li>depends on var表示该变量必须在var被设置的情况下才能进行设置，否则取值为n，即使default为y</li>
<li>select var表示它将影响到变量var，使得var至少应该配置为y或者m</li>
<li>help中的文字将作为配置界面中的帮助信息</li>
</ul>
</li>
<li>menu

<ul>
<li>在menu和endmenu中间可配置若干config条目</li>
</ul>
</li>
<li>choice

<ul>
<li>在choice和endchoice之间可定义若干config条目。choice中的config条目只能有2种类型：bool或者tristate，且不能同时有这两种变量。对于bool型变量只能在多个选择中选择1个为y；对于tristate型变量，要么将多个设置为m，要么仅将1个设为y，其余为n。</li>
</ul>
</li>
<li>comment

<ul>
<li>用于定于帮助信息，将出现在配置界面的第一行，并且还会出现在配置文件.config中作为注释</li>
</ul>
</li>
<li>source

<ul>
<li>由于内核源代码中大多数目录下都有各自的Kconfig文件，因此需要一种手段将所有的Kconfig文件组织为一个整体。这就是source的功能，它用于引入另一个Kconfig文件，有点类似于C语言中的#include</li>
</ul>
</li>
</ol>


<h2>Makefile文件精解</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#如果CONFIG_ATL1=y，将递归进入本目录的子目录atl1，并根据该子目录下的Makefile文件的内容决定该子目录如何继续拧编译，否则将不进入本目录的子目录atl1进行编译</span>
</span><span class='line'><span class="n">obj</span><span class="o">-</span><span class="err">$</span><span class="p">(</span><span class="n">CONFIG_ATL1</span><span class="p">)</span> <span class="o">+=</span> <span class="n">atl1</span><span class="o">/</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#如果.config中变量CONFIG_GIANFAR=y，那么将变异本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar)sysfa.c文件并将其功能集成进zImage；如果.config文件中变量CONFIG_GIANFAR=m，那么将编译本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar_sysfs.c文件生成模块gianfar.ko；否则将编译gianfar.c,gianfar_ethtool.c</span>
</span><span class='line'><span class="n">gianfar_mii</span><span class="p">.</span><span class="n">c</span><span class="p">,</span><span class="n">gianfar_sysfa</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="n">obj</span><span class="o">-</span><span class="err">$</span><span class="p">(</span><span class="n">CONFIG_GIANFAR</span><span class="p">)</span> <span class="o">+=</span> <span class="n">gianfar_driver</span><span class="p">.</span><span class="n">o</span>
</span><span class='line'><span class="n">gianfar_driver</span><span class="o">-</span><span class="nl">objs</span> <span class="p">:</span><span class="o">=</span> <span class="n">gianfar</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_ethtool</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_mii</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_sysfs</span><span class="p">.</span><span class="n">o</span>
</span></code></pre></td></tr></table></div></figure>


<h2>zImage文件生成过程</h2>

<ol>
<li>内核代码首先被编译生成vmlinux，放在Linux源码的顶层目录下</li>
<li>这个vmlinux可执行文件又通过arm-linux-objcopy命令转化为二进制代码文件Image（放在arch/arm/boot目录下），其实这个Image文件才是真是的内核代码文件，因为这个文件会比较大，所以内核会对它做压缩处理</li>
<li>为了最大化减小Image的体积，内核调用gzip工具吧Image压缩成piggy.gz文件</li>
<li>为了让内核具有自引导功能，在arch/arm/boot/compressed目录下有head.o,misc.o两个文件构成解压和自引导代码，而让真实的piggy.gz文件也参与编译，最终生成了梁歪一个vmlinux文件，放在arch/arm/boot/compressed目录下，并最终调用arm-linux-objcopy生成二进制文件zImage。</li>
<li>综上，zImage文件由arch/arm/boot/compressed目录下的head.S和misc.c文件（自解压程序）+内核真实代码文件组成</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CPP-Knowledges]]></title>
    <link href="http://suda-morris.github.io/blog/2015/07/20/cpp-knowledges/"/>
    <updated>2015-07-20T09:42:10+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/07/20/cpp-knowledges</id>
    <content type="html"><![CDATA[<h2>流</h2>

<ol>
<li>标准C++中，iostream中常见的操作算子(manipulator):flush,endl,oct(后面跟的数据解析成八进制)，hex(后面跟的数解析成十六进制)，dec(后面跟的数解析成十进制)，boolalpha(后面跟的数据解析成布尔类型，并用true和false来显示)，showpos(后面跟的数据显示正负号)，fixed(后面跟的数不要四舍五入),noshowpos(后面跟的数如果是正数就显示+号),showpoint(后面跟的数据显示小数点)，scientific(后面跟的数据以科学计数法的形式表示);在Qt中附加的一些操作算子：forcesign(后面的数据显示正负号),forcepoint(后面的数据显示小数点),noforcesign(后面的数据如果是正数就不显示+号)</li>
<li>标准C++的iostream中，getline(cin,your_string)语句能够从标准输入流中提取一行字符串</li>
<li>在Qt中很容易用与iostream对应的同一个名称定义QTextStream，由于控制台输入和输出主要用在调试过程，所以Qt提供了一个全局函数qDebug(),用它可以方便地将消息发送到控制台，且具有灵活的接口</li>
<li>流被用来读取/写入文件、连接网络和处理字符串，它有一个有用的特性是易于从混合数据类型中得到字符串。</li>
<li>STL中的字符串流：std::ostringstream,常用来定义一个string_buffer;</li>
<li>STL中的文件流std::ofstream,用来定义一个文件流管道如ofstream outf后绑定一个文件：outf.open(&ldquo;file path&rdquo;)</li>
<li>STL中的输入文件流std::ifstream,打开文件instream inf;inf.open(&ldquo;file path&rdquo;),判断是否读到了文件末尾inf.eof(),读取一行数据getline(inf,newstr)</li>
<li>STL中的stringstream对应于Qt里面的QString，STL中的fstream对应于Qt里面的QFile，STL中的iostream对应于Qt中的QTextStream</li>
</ol>


<h2>运算符new和delete</h2>

<ul>
<li>new运算符从堆(heap)中分配内存空间，并且返回指向新分配的对象的指针，如果由于某种原因无法完成内存分配，就会抛出一个异常</li>
<li>delete运算符的作用是释放动态分配的内存并将其返回给堆。delete操作只能用于由new运算符返回的指针或者空指针。</li>
</ul>


<h2>智能指针</h2>

<ul>
<li>智能指针是一个对象，它用来保存和管理指向堆对象的指针，其行为与常规的指针非常类似，只是它会在合适的时刻自动删除堆对象。这个类在Qt中对应的是QPointer，在标准库中是std::auto_ptr,在Boost中是shared_ptr</li>
</ul>


<h2>引用</h2>

<ul>
<li>在C++中，引用提供了一种给左值赋予一个别名的机制，对于避免费事或者不必要的复制引用是非常有用的，例如向函数传送一个非常大的对象作为参数。<strong>引用必须在声明时进行初始化且其初始化器也必须是一个左值</strong>,例如：<code>int n;int&amp; rn=n;</code>引用变量rn是实际变量n的别名</li>
<li>一种好的编程实践是：对于不需要通过函数来进行变化的指针和引用参数，应使用const来保护它们。只读引用参数的能力在于：对按引用传递参数提供了高效性，而对按值传递参数提供了安全性</li>
</ul>


<h2>类的友元</h2>

<ul>
<li>友元机制允许非成员函数访问一个类的私有数据，关键字friend可以放在类的生命或者函数声明之前，友元声明位于类定义之内</li>
<li>通常而言，为了达到下面两个目的才会使用友元函数：

<ol>
<li>为了使用工厂方法，此时需要对某个类强制实施某些创建规则</li>
<li>为了使用全局运算符函数，比如operator&lt;&lt;()和operator>>()，此时不希望将运算符作为某个类的成员函数，或者没有写入类定义的权利</li>
</ol>
</li>
</ul>


<h2>运算符重载</h2>

<ol>
<li>C++使用关键字operator为运算符赋予新的含义</li>
<li>例如重载&lt;&lt;运算符：friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const Complex&amp; c);</li>
</ol>


<h2>define与inline的区别</h2>

<blockquote><ol>
<li>对#define宏的替换过程是由预处理器处理的，预处理器本质上是一个文本编辑器。对inline函数的替换过程是由编译器处理的，它会执行更智能的操作，进行正确的类型检查</li>
<li>inline函数必须在调用之前<strong>定义</strong></li>
<li>在一个源代码模块中只能有一次inline定义</li>
</ol>
</blockquote>

<h2>带变长实参表的函数</h2>

<blockquote><ol>
<li>在C和C++中，可以定义其参数表以省略号结尾的函数。省略号使调用者能够制定参数的数量以及类型。</li>
<li>为了定义使用省略号的函数，需要包含cstdarg库</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">double</span> <span class="nf">mean</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...){</span>
</span><span class='line'>  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>               <span class="cm">/*ap执行第一个未命名实参*/</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>      <span class="n">sum</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="kt">double</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>                 <span class="cm">/*返回之前清除栈*/</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sum</span><span class="o">/</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>预处理宏主要应用场合</h2>

<blockquote><ol>
<li>使用#ifndef/#define/#endif将头文件包裹起来，以避免多次包含某个头文件</li>
<li>使用#ifdef/#else/#endif对某些代码部分进行条件编译</li>
<li><strong>FILE</strong>宏和<strong>LINE</strong>宏用于调试并给出框架信息</li>
</ol>
</blockquote>

<h2>C++中的多态性</h2>

<blockquote><ol>
<li>C++源于C语言，它的编译器也试图在编译时绑定函数调用，这主要是基于性能方面的考虑。编译器无法仅凭集成关系和基类指针就确定它正在操作何种对象。如果没有运行时检查，就无法保证运行时调用正确的函数。C++要求使用一个特殊的关键字来允许运行时通过指针和引用进行函数调用的绑定，这个关键字就是virtual，它能够使得程序具有多态性。</li>
<li>由于this是在执行它的构造函数时被初始化的，在执行它的析构函数的时候被销毁，因此不要指望在这两种条件下能够执行正确的运行时绑定。当在构造函数或者析构函数里面调用任何this方法时，将由编译时绑定决定应该调用哪一个方法，就好像不存在virtual关键字一样。</li>
<li>一般而言，如果类中包含一个或者多个virtual函数，则也应包含一个虚析构函数。这是因为，当对对台对象集合进行操作时，通常是通过基类指针删除这些对象，这会导致对析构函数的间接调用，如果析构函数不为virtual类型，在编译时绑定将决定应该调用哪一个析构函数，从而可能导致派生对象的不完整析构</li>
<li>静态成员函数不能使虚函数；内敛函数不能是虚函数；构造函数不能是虚函数</li>
</ol>
</blockquote>

<h2>虚函数实现原理</h2>

<blockquote><ol>
<li>父类中如果有虚函数存在，编译器就会为该对象创建一个虚函数表，里面存放自己的虚函数的指针。</li>
<li>子类继承父类，编译器也会为子类创建一个不同的虚函数表，存放子类自己的虚函数指针</li>
<li>拥有虚函数表的类都会另外创建一个指向该表的指针</li>
<li>所以当父类指针指向子类对象，调用虚函数的时候就会根据子类对象的虚函数表调用得到子类的虚函数，而不是父类的虚函数</li>
<li>如果没有在子类中定义与父类同名的虚函数，那么就会在子类的虚函数表中就会写上父类的相应的虚函数的函数入口地址；如果在子类中也定义了同名的虚函数，那么在虚函数表中用子类的虚函数的函数地址覆盖掉父类的相应的虚函数的函数地址</li>
<li>每个类只有一份虚函数表，所有该类的对象共用同一张虚函数表</li>
<li>只有函数声明没有函数定义的虚函数也是纯虚函数</li>
</ol>
</blockquote>

<h2>纯virtual函数的声明</h2>

<blockquote><ol>
<li>virtual returnType functionName(parameterList)=0;</li>
<li>抽象基类中至少要有一个virtual函数</li>
<li>抽象基类中不能有public的构造函数</li>
<li>抽象基类的任何具体派生类都必须重写并定义全部的纯virtual基类函数，话句话说，任何没有重写并定义全部纯virtual基类函数的派生类都是抽象类</li>
</ol>
</blockquote>

<h2>重载，隐藏与重写</h2>

<blockquote><ol>
<li>当函数foo在同一个作用域内存在两个或者多个版本(具有不同的签名)时，就称foo函数被<strong>重载</strong>了</li>
<li>当基类中的一个virtual函数在培生累中也存在，并且他们具有相同的签名和返回类型时，就称派生类中的版本“重写”了基类中的版本</li>
<li>派生类中的成员函数，会隐藏基类中与之同名的全部函数，如果出现这种情况，则：

<ul>
<li>只有派生类函数可以被直接调用</li>
<li>类作用域解析运算符::西部用来显式地调用基类函数</li>
</ul>
</li>
</ol>
</blockquote>

<h2>有三种特殊的成员函数从来不会被继承，编译器会为没有定义它们的类自动生成这三种函数</h2>

<ol>
<li>拷贝构造函数：类名（const 类名&amp; 变量名）</li>
<li>复制赋值运算符</li>
<li>析构函数</li>
</ol>


<h2>构造函数</h2>

<blockquote><p>如果一个类没有构造函数，那么编译器就会自动产生一个默认的public构造函数，而这个构造函数会调用它的每一个基类的默认构造函数。如果某个类有一些构造函数但是没有默认构造函数，那么它就不会进行默认的初始化工作，这种情况下，任何派生类构造函数都必须在其初始化列表中明确地指名应该调用哪一个基类构造函数</p></blockquote>

<h2>类的前置声明</h2>

<blockquote><ol>
<li>类的前置声明将它的名称声明成一个有效的类名称，但不给出类的定义。这会使得类名称能够被用作<strong>指针</strong>和<strong>引用</strong>的类型，在遇到类的定义之前，不会将这些指针和引用进行解引操作。</li>
<li><strong>如果可以使用前置声明，就不要使用#include指令</strong></li>
</ol>
</blockquote>

<h2>范型与模板</h2>

<blockquote><p>1.模板为C++编译器提供了一个途径，能够为带有参数化类型和相同行为的类和函数生成多个版本。模板使用关键字template以及用尖括号&lt;>包围的模板参数进行区分。与函数参数不同，模板参数不仅可以传递变量和值，还可以传递类型表达式。例如：template <class T,int max> Buffer{T v[max];}
2. 每当编译器看到一个特定参数类型的组合首次用于一个模板函数时，就称此模板进行了实例化。
3. 类模板主要用来生成数据的通用容器，其参数能够指名容器中的内容。所有的Qt容器类以及标准模板库(STL)中的所有容器类都是参数化的。
4. 所有模板的定义(类和函数)都必须出现在头文件中，这是因为编译器需要用这些定义来根据模板声明生成代码</p></blockquote>

<h2>其他</h2>

<ul>
<li>C++中使用struct的大多数情形是需要将数据项分组在一起，但是不需要成员函数</li>
<li>const成员函数中不允许对数据成员进行修改，如果修改，编译器将报错，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误。注意可以在const成员函数里面更改可变成员(mutable member)的值，而常规的数据成员的值不能改变</li>
<li>类内定义的成员函数编译器会优先编译成内联(inline)函数</li>
<li>初始化列表优先于构造函数执行.初始化列表只能用于构造函数,初始化列表可以同时初始化多个数据成员</li>
<li>const数据成员的初始化必须写在初始化列表中</li>
<li>M_PI来自于&lt;math.h>,它位于cstdlib库中</li>
<li>foreach()宏需要赋值它所遍历的容器，这就要求使用foreach必须要有拷贝构造函数</li>
<li>C++类型可以分成两类：值类型和对象类型，值类型的有Anything*，int，char，QString，QDate和QVariant。带有共有默认构造函数、拷贝构造函数和复制赋值运算符的任何类型都是值类型</li>
<li>C++对于没有数据成员的类在实例化的时候会分配1个内存单元(1Byte)，用于标记该对象的存在</li>
<li>含有纯虚函数的类叫做抽象类,抽象类无法实例化对象</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QT4知识点]]></title>
    <link href="http://suda-morris.github.io/blog/2015/07/19/qt4-knowldegs/"/>
    <updated>2015-07-19T20:52:44+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/07/19/qt4-knowldegs</id>
    <content type="html"><![CDATA[<h2>Qt核心模块</h2>

<p>Qt是一个大库，由数个较小的库或者模块组成，其中最为常见的有如下这些，除了core和gui，其余模块都需要在qmake的工程文件中启用：</p>

<ol>
<li>core：包括QObject，QThread，QFile，Qvariant等等</li>
<li>gui：所有从QWidget派生的类外加一些相关的类</li>
<li>xml：用于解析和序列化XML</li>
<li>sql：用于与SQL数据库通信</li>
<li>phonon：用于播放多媒体文件</li>
<li>webkit：用于使用一种嵌入式web浏览器，QtWebkit</li>
</ol>


<h2>工程文件.pro</h2>

<ol>
<li>对于Qt程序，程序不必编写Makefile文件，Qt提供了一个qmake工具，它会根据工程文件来产生对应的Makefile文件。亦可以用qmake -project命令产生一个简单的工程文件，当执行这个命令的时候，qmake会将当前工作目录下的全部源文件(<em>.cpp)作为SOURCES列出来，而将该目录下的全部头文件(</em>.h)作为HEADERS列出来。最终生成的可执行文件的名称由TARGET变量指定，其默认为工程的名称</li>
<li>TEMPLATE=app，表明qmake应该以一个适合建立这个应用的模板化的Makefile开始，如果这个工程文件用于建立库，则应当使用语句TEMPLATE=lib，以表明应使用Makefile库模板。第三种可能是源代码文件分布在多个子目录下，而每一个子目录下的文件都具有自己的工程文件，这种情况下，位于父目录的工程文件中应该包含语句TMPLATE=subdirs，这会导致在父目录和每一个子目录下都生成Malefile</li>
<li>添加库：LIBS += -Lpathtolibs</li>
<li>CONFIG += console表示是控制台程序</li>
<li>当编写并测试完库之后，在编译链接过程结束后它将被安装到由qmake变量DESTDIR指定的目录下。例如，dataobjects库的工程文件包含如下相关的行：

<ul>
<li>TEMPLATE = lib</li>
<li>DESTDIR = pathto_install_libs</li>
</ul>
</li>
<li>对于库模板，qmake将产生一个包含install目标的Makefile，这样，在成功编译链接之后执行命令make install将会把这个库复制到某个特定的位置</li>
</ol>


<h2>Qt中获取命令行参数</h2>

<ul>
<li>QCoreApplication app(argc,argv);</li>
<li>QStringList arglist = app.arguments();</li>
<li>arglist.size等于命令行参数的个数</li>
</ul>


<h2>Qt中的字符串</h2>

<ol>
<li>const char*，主要用于与C语言库的接口</li>
<li>来自C++标准库的string，任何地方都可以使用这种类型</li>
<li>QString，优于STL中的字符串类型，有着更加丰富的API而且更加容易使用。</li>
<li>在Qt中使用类似于iostream中的cin，cout：

<ul>
<li><h1>include &lt;QString></h1></li>
<li><h1>include &lt;QTextStream></h1></li>
<li>QTextStream cout(stdout)</li>
<li>QTextStream cin(stdin)</li>
<li>cin.readLine()</li>
</ul>
</li>
<li>sizeof(QString)=4,sizeof(QChar)=2,sizeof(QDate)=4,sizeof(qint32)=4,sizeof(qint64)=8;QString是一个使用动态内存的复杂类，因此必须调用length()来获得字符串中QChar的数量。由于QChar的大小为char的两倍，所以在计算内存中QString中实际大小时需要将长度乘以2，在运行时，QString能够与具有同一个值的另一个字符串共享内存</li>
</ol>


<h2>去掉最大、最小、关闭按钮</h2>

<blockquote><p>setWindowFlags(windowFlags()|Qt::FramelessWindowHint|Qt::WindowTitleHint);</p></blockquote>

<h2>使用中文</h2>

<blockquote><ol>
<li>下载qpf格式的font_wenquanyi字体，将下载的字库文件复制到qt安装目录的lib/fonts子目录下</li>
</ol>
</blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\#include &lt;QTextCodec&gt;
</span><span class='line'>  QApplication a(argc, argv);
</span><span class='line'>    QTextCodec::setCodecForLocale(QTextCodec::codecForName("UTF-8"));     //中文支持
</span><span class='line'>    QTextCodec::setCodecForTr(QTextCodec::codecForName("UTF-8"));       //支持Tr中文
</span><span class='line'>    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8")); //支持中文文件名显示
</span><span class='line'>    QFont font;
</span><span class='line'>    font.setPointSize(160);                                           //实际上是16的字号，但设成16却不行
</span><span class='line'>    font.setFamily(("wenquanyi"));
</span><span class='line'>    font.setBold(false);
</span><span class='line'>    a.setFont(font);</span></code></pre></td></tr></table></div></figure>


<h2>隐藏鼠标箭头</h2>

<blockquote><ol>
<li>对于整个程序: QApplication::setOverrideCursor(Qt::BlankCursor);</li>
<li>对单个控件：lable->setCursor(Qt::BlankCursor);//隐藏鼠标  label->setCursor(Qt::ArrowCursor);//显示正常鼠标</li>
</ol>
</blockquote>

<h2>QStringList与迭代</h2>

<blockquote><ol>
<li>QStringList实际上就是一个QList<QString>,此外，QStringList还具有一些特别针对字符串的方便函数，例如indexOf(),join()和replaceInStrings()。利用split()函数和join()函数，在列表与字符串之间进行转换相当简单</li>
<li>QStringList对象可以调用方法takeFirst()来依次获得列表中的字符串对象</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QString</span> <span class="n">winter</span> <span class="o">=</span> <span class="s">&quot;December,January,February&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">QString</span> <span class="n">spring</span> <span class="o">=</span> <span class="s">&quot;March,April,May&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">QString</span> <span class="n">summer</span> <span class="o">=</span> <span class="s">&quot;June,July,August&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">QString</span> <span class="n">fall</span> <span class="o">=</span> <span class="s">&quot;September,October,November&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">QStringList</span> <span class="n">list</span><span class="p">;</span>
</span><span class='line'><span class="n">list</span> <span class="o">&lt;&lt;</span> <span class="n">winter</span><span class="p">;</span>
</span><span class='line'><span class="n">list</span> <span class="o">+=</span> <span class="n">spring</span><span class="p">;</span>
</span><span class='line'><span class="n">list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">summer</span><span class="p">);</span>
</span><span class='line'><span class="n">list</span> <span class="o">&lt;&lt;</span> <span class="n">fall</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">QString</span> <span class="n">allmonths</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">);</span>  <span class="cm">/*从列表到字符串，以逗号为分隔符*/</span>
</span><span class='line'><span class="n">QStringList</span> <span class="n">list2</span> <span class="o">=</span> <span class="n">allmonths</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">);</span> <span class="cm">/*从字符串到列表，以逗号为分隔符*/</span>
</span><span class='line'>
</span><span class='line'><span class="n">foreach</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span><span class="n">list</span><span class="p">){</span> <span class="cm">/*Qt foreach循环*/</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">QStringList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">){</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">QListIterator</span><span class="o">&lt;</span><span class="n">QString</span><span class="o">&gt;</span> <span class="n">itr</span><span class="p">(</span><span class="n">list2</span><span class="p">);</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">itr</span><span class="p">.</span><span class="n">hasNext</span><span class="p">()){</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">current</span> <span class="o">=</span> <span class="n">itr</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QDir，QFileInfo和QDirIterator</h2>

<figure class='code'><figcaption><span>利用QDir类和QFileInfo类获取目录的内容列表以及关于每一个项的信息</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">void</span> <span class="nf">recurseAddDir</span><span class="p">(</span><span class="n">QDir</span> <span class="n">d</span><span class="p">,</span><span class="kt">bool</span> <span class="n">recursive</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span><span class="kt">bool</span> <span class="n">symlinks</span><span class="o">=</span><span class="nb">false</span><span class="p">){</span>
</span><span class='line'>  <span class="n">d</span><span class="p">.</span><span class="n">setSorting</span><span class="p">(</span><span class="n">QDir</span><span class="o">::</span><span class="n">Name</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QDir</span><span class="o">::</span><span class="n">Filters</span> <span class="n">df</span> <span class="o">=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">Files</span> <span class="o">|</span> <span class="n">QDir</span><span class="o">::</span><span class="n">NoDotAndDotDot</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span> <span class="n">df</span> <span class="o">|=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">Dirs</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">not</span> <span class="n">symlinks</span><span class="p">)</span> <span class="n">df</span> <span class="o">|=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">NoSymLinks</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QStringList</span> <span class="n">qsl</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">entryList</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">QDir</span><span class="o">::</span><span class="n">Name</span><span class="o">|</span><span class="n">QDir</span><span class="o">::</span><span class="n">DirsFirst</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">foreach</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span><span class="n">qsl</span><span class="p">){</span>
</span><span class='line'>      <span class="n">QFileInfo</span> <span class="n">finfo</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">isDir</span><span class="p">()){</span>
</span><span class='line'>          <span class="n">QDir</span> <span class="n">sd</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">absoluteFilePath</span><span class="p">());</span>
</span><span class='line'>          <span class="n">recurseAddDir</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>          <span class="k">if</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">completeSuffix</span><span class="p">()</span><span class="o">==</span><span class="s">&quot;mp3&quot;</span><span class="p">){</span>
</span><span class='line'>              <span class="n">addMp3File</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">absoluteFilePath</span><span class="p">());</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>使用QDirIterator实现相同功能</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QDir</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">current</span><span class="p">();</span>
</span><span class='line'><span class="n">QDirIterator</span> <span class="nf">qdi</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="n">absolutePath</span><span class="p">(),</span> <span class="n">QStringList</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*.mp3&quot;</span><span class="p">,</span> <span class="n">QDir</span><span class="o">::</span><span class="n">NoSymLinks</span> <span class="o">|</span> <span class="n">QDir</span><span class="o">::</span><span class="n">Files</span><span class="p">,</span> <span class="n">QDirIterator</span><span class="o">::</span><span class="n">Subdirectories</span><span class="p">);</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">qdi</span><span class="p">.</span><span class="n">hasNext</span><span class="p">){</span>
</span><span class='line'>  <span class="n">addMp3File</span><span class="p">(</span><span class="n">qdi</span><span class="p">.</span><span class="n">next</span><span class="p">());</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QDate</h2>

<blockquote><ol>
<li>static QDate currentDate = QDate::currentDate();</li>
</ol>
</blockquote>

<h2>Qt中字符串的数据流操作</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QString</span> <span class="n">Student</span><span class="o">::</span><span class="n">toString</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">retval</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QTextStream</span> <span class="nf">os</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
</span><span class='line'>  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;name:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_Name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;;ID:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_StudentID</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>`</p>

<h2>qDeleteAll(container)只对包含指针的容器有意义，该函数将释放所有对象，但并不删除容器中的指针；删除容器中的指针需要调用容器的clear()函数</h2>

<h2>容器（Qt容器被定义成模板类）</h2>

<blockquote><ol>
<li>QList<T>是用数组实现的，数组的两端都有预分配的空间。它针对按索引的随机访问以及少于1000项的列表进行了优化。对于prepend()和append()这样的操作，它有很好的性能表现</li>
<li>QStringList是派生自QList<QString>的一个便利类</li>
<li>QLinkedList<T>针对迭代器的顺序访问以及快速、常量时间的列表插入操作进行了优化，但排序和搜索比较缓慢。它提供多个便利函数来处理那些经常用到的操作
QVector<T>以连续的内存位置保存数据，并针对按索引的随机访问进行了优化。通常而言，QVector对象都是用其初始大小进行构造的，在其两端都不存在预先自动分配的内存空间，所以中间掺入、末端插入以及前端插入都是耗时的</li>
<li>QStack<T>是派生自QVector<T>的public类，所以QVector类的public接口可以用于QStack对象。不过，push(),pop()以及top()函数采用的是后入先出(LIFO)的语法</li>
<li>QMap&lt;Key,T>是一个有序的关联容器，它保存的是键/值对，其作用是根据键来快速找到对应的值。它也被设计成支持适量的快速插入操作和删除操作。它将键有序排列，以便能够快速搜索和快速缩小搜索范围，采用的是一个跳跃列表字典，这个字典在概率上是平衡的并且高效的利用了内存。键的类型必须是operator&lt;()和operator==()</li>
<li>QHash&lt;Key,T>也是一个关联容器，它使用哈希表来进行键的查找。它提供快速的查找(键精确匹配)和插入操作，但其搜索速度较慢，且没有排序功能。键的类型必须是operator==()</li>
<li>QMultiMap&lt;Key,T>是QMap的一个子类，而QMultiHash&lt;Key,T>是QHash的一个子类。这两个类是的一个键可以与多个值关联</li>
<li>QCache&lt;Key,T>是一个关联容器，它对最近使用过的项提供最快速的访问，并会根据几个开销函数的结果自动移除哪些不常用的项</li>
<li>QSet<T>用QHash保存T类型的值，QHash中的键位于T中，而其中的哑值与每一个键相关联。这种安排可优化查找和插入操作。QSet中的几个函数用于常规的集合操作。它的默认构造函数会创建一个空集合</li>
</ol>


<p><strong>用于模板容器类的类型参数T，或者用于关联容器的键类型都必须为可赋值数据类型，即值类型。这意味着T必须具有public类型的默认构造函数、拷贝构造函数和赋值运算符。基本类例如int，double，char和指针都是可赋值的，有些Qt类型是可赋值的，例如QString，QDate，QTime。QObject以及派生自QObject的类型都是不可赋值的，如果需要使用某种不可赋值类型的对象，则可以定义一个指针容器，例如QList&lt;QFile*></strong></p></blockquote>

<h2>QFile</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QFile</span> <span class="nf">outf</span><span class="p">((</span><span class="s">&quot;filename&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">outf</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>
</span><span class='line'><span class="n">QTextStream</span> <span class="nf">outstr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outf</span><span class="p">);</span>
</span><span class='line'><span class="n">outstr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;content&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">outf</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>序列化器模式：QTextStream和QDataStream</h2>

<blockquote><ol>
<li>序列化器是一种只负责读取或者写入对象的对象，Qt的QTextStream序列化器用于读写人可读的文件，而QDataStream序列化器用于读写结构化的二进制数据。这些类都是用序列化器模式实现的</li>
<li>利用QDataStream就可以序列化和解序列化QVariant支持的全部类型，包括QList，QMap，QVector以及其他类型。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QFile</span> <span class="nf">textFile</span><span class="p">(</span><span class="s">&quot;playlist1.tsv&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QFile</span> <span class="nf">binaryFile</span><span class="p">(</span><span class="s">&quot;playlist1.bin&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QTextStream</span> <span class="n">textStream</span><span class="err">；</span>
</span><span class='line'><span class="n">QDataStream</span> <span class="n">dataStream</span><span class="err">；</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">textFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">)){</span>
</span><span class='line'>  <span class="n">textStream</span><span class="p">.</span><span class="n">setDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">textFile</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">binaryFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">)){</span>
</span><span class='line'>  <span class="n">dataStream</span><span class="p">.</span><span class="n">setDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binaryFile</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">QList</span><span class="o">&lt;</span><span class="n">MetaDataValue</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">textStream</span><span class="p">.</span><span class="n">atEnd</span><span class="p">()){</span>
</span><span class='line'>  <span class="n">MetaDataValue</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'>  <span class="n">textStream</span> <span class="o">&gt;&gt;</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'>  <span class="n">values</span> <span class="o">&lt;&lt;</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dataStream</span> <span class="o">&lt;&lt;</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QObject</h2>

<blockquote><ol>
<li>QObject是Qt库中许多重要的类的基类，如QEvent，QApplication，QLayout和QWidget。</li>
<li>QObject使基于事件的编程成为了可能，其中用到了QApplication和Qt的事件循环</li>
<li>QObject没有公有的拷贝构造函数或复制赋值运算符。QObject类定义的结尾处有一个宏Q_DISABLE_COPY(QObject)，它显示地确保任何QObject都不能被复制。QObject不是设计用于复制的，QObject会用来代表具有唯一身份的对象。这种不带拷贝构造函数策略的一个直接后果就是永远无法通过值传递方式向函数传递OBject。</li>
<li>QObject及其派生类的单参数构造函数应当予以显式声明explicit，以免意外的隐式转换的发生。</li>
<li>每个QObject都可以有（至多）一个父QObject，且可以拥有任意数量的子QObject。</li>
<li>每个QObject都将指向各个子对象的指针存放在一个QObjectList中，在调用QObject的析构函数时会自动销毁该对象的子对象</li>
<li>通常而言，没有父对象的QObject应当在程序栈区(stack)中进行定义，而那些有父对象的QObject则应当在堆区(heap)动态创建出来，这样可有助于确保发生正确的析构操作。</li>
<li>QObject有一个成员函数，可以返回一个指向主对象中全部子对象的指针列表：const QObjeectList&amp; QObject::children() const</li>
<li>QObject还提供了两个名称为findChildren()的重载(递归)每个都会返回一个满足特定条件的子对象列表：QList<T> parentObj.findChildren<T>(const QString&amp; name=QString()) const 该函数返回一个类型为T的子对象列表，其对象名与name相等。如果name是空字符串，那么将会起到一个类过滤器的作用，返回结果是一个QList，其中包含指向全部子对象的指针，而这些子对象都可以通过类型转换变成类型T的对象</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QList</span><span class="o">&lt;</span><span class="n">Customer</span><span class="o">*&gt;</span> <span class="n">custlist</span> <span class="o">=</span> <span class="n">parent</span><span class="p">.</span><span class="n">findChildren</span><span class="o">&lt;</span><span class="n">Customer</span><span class="o">*&gt;</span><span class="p">();</span>
</span><span class='line'><span class="n">foreach</span> <span class="p">(</span><span class="k">const</span> <span class="n">Customer</span><span class="o">*</span> <span class="n">current</span><span class="p">,</span><span class="n">custlist</span><span class="p">){</span>
</span><span class='line'>  <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QEvent</h2>

<blockquote><ol>
<li>QEvent类封装了底层事件的概念。QEvent类是若干特定事件类的基类，例如QActionEvent,QFileOpenEvent,QHoverEvent,QInputEvent,QMouseEvent等。QEvent对象可以由窗口系统创建以响应用户的动作(例如，QMouseEvent)或按照指定的时间间隔(QTimerEvent)完成创建，也可以由应用程序显式地创建。成员type()会返回一个美剧，其中含有近百个特定的值，以区分不同种类的各式事件(例如,关闭、DragEnter、DragMove、放下、输入、GrabMouse、HoverEnter、KeyPress、MouseButtonDblClick、MouseMove、Resize)</li>
<li>一个典型的Qt程序会创建对象，连接各个对象，然后再告诉应用程序开始发送exec()，在运行时，应用程序就进入了事件循环，各个对象之间可以通过各种方式相互发送消息。</li>
<li>只有在事件循环，特别是QApplication::exec()进入的事件循环中，信号才能发送到槽上。这是因为信号和槽在其外表之下是使用事件循环来传递消息的。</li>
<li>QObject支持一些普通C++对象通常没有的特性：信号和槽，元对象、元属性、元方法，qobject_cast</li>
<li>元对象编辑器，即moc，会针对每个使用Q_OBJECT宏的QObject派生类生成额外的函数，生成的代码可以在名称为moc_filename.cpp的文件中找到。</li>
</ol>
</blockquote>

<h2>信号和槽</h2>

<blockquote><ol>
<li>信号是在类定义中给出的类似于void函数声明的一种消息。它有参数列表却没有函数体。信号时一个类的接口的一部分，它看起来想函数，但不用同样的方式进行调用&mdash;它被此类的对象发射</li>
<li>槽通常是一个void成员函数，它可以像普通的成员函数一样进行调用，或者可以由QMetaObject系统进行间接调用</li>
<li>连接语句的语法：bool QObject::connect(senderQObjectPtr,SIGNAL(signalName(argumentList)),receiverQObjectPtr,SLOT(slotName(argumentList))optionalConnectionType);optionalConnectionType让你可以明确说明，你是否希望从发射点处同步(阻塞)或者非同步(排队)地调用目标槽</li>
<li>如果有多个信号连接到同一个槽上且需要知道是那哟个QPbject发射的信号，则可以在该槽中调用sender(),它会返回一个指向那个对象的指针</li>
</ol>
</blockquote>

<h2>堆还是栈</h2>

<blockquote><p>一般情况下，没有父对象的QObject应当在栈上创建，或者定义成另一个类的子对象。有父对象的QObject不应该在栈上创建，因为那样的话，它有可能会被删除两次。
不推荐直接删除QObject，在带有事件循环的程序中，最好利用QObject::deleteLater()来删除QObject。这样做，可以在应用程序处理事件并在当前槽返回之后就安排该对象的销毁。希望能够在槽内删除信号的sender(),这么做实际上是必须的</p></blockquote>

<h2>QWidget和其余GUI开发中常用的类</h2>

<blockquote><ol>
<li>QWidget是一个采用了多重继承的类，首先，QWidget是一个QObject，因此它可以有父对象、信号、槽以及可受管理的子对象。同时QWidget也是一个QPaintDevice，这个类是所有可在屏幕上进行绘制的对象的基类</li>
<li>Qt数据类型——QPoint,QSize,QColor,QImage和QPixmap是在处理图形对象时常用到的类型</li>
<li>布局——这些类能够动态地管理Widget的布局，其中有些事常用的特殊布局，包括QHBoxLayout，QVBoxLayout，QGridLayout，QFormLayout等</li>
<li>模型——QAbstractItemModel及其各个派生类，如QAbstractListModel和QAbstractTableModel，外加一些已有的可继承实体类，如QSqlQueryModel和QFileSystemModel，都是Qt模型/视图框架中的一部分，该框架内置将一个模型和其他不同视图相连接的机制，以便对一个组件的修改可以自动变换到其他组件上</li>
<li>控制类——QApplication和QAction两者都是管理GUI应用程序控制流的对象。QItemDelegate用作模型和视图之间的控制器</li>
</ol>
</blockquote>

<h2>对话框</h2>

<blockquote><ol>
<li>QDialog是Qt所有对话框的基类。对话框窗口可以是模态(modal)对话框也可以是非模态(nonmodal)对话框。</li>
<li>当程序调用静态的便利函数"QMessageBox::&ldquo;或者"QFileDialog::"时，弹出的对话框就是模态对话框。当模态对话框显示在屏幕上时，它会冻结同一应用程序中的其他所有可见窗口的输入功能。用户解除模态对话框后，与应用程序的常规交互才可以继续下去。QDialog::exec()是将模态对话框放到屏幕上的另一种方式。当用户完成了所需的响应后，对话框就可以返回数据，也可以返回对话框代码(QDialog::Accepted或者QDialog::Rejected);</li>
<li>可以像QWidget一样通过show()显示一个QDialog，在此情况下，对话框是非模态的，用户也就可以与应用程序的其他窗口继续交互。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QApplication</span> <span class="nf">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">);</span>
</span><span class='line'><span class="n">QProgressDialog</span> <span class="n">nonModal</span><span class="p">;</span>
</span><span class='line'><span class="n">nonModal</span><span class="p">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s">&quot;Non Modal Parent Dialog&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">nonModal</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
</span><span class='line'><span class="n">nonModal</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonModal</span><span class="p">,</span><span class="n">SIGNAL</span><span class="p">(</span><span class="n">finished</span><span class="p">()),</span><span class="o">&amp;</span><span class="n">app</span><span class="p">,</span><span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>图标、图像与资源</h2>

<blockquote><ol>
<li>Qt提供了至少两种方式来获得标准的图标。一种方式来自于桌面样式的QStyle::standardIcon()，另一种则来自插件型图标主题:QIcon::fromTheme()</li>
<li>把所需的二进制数据文件作为资源附加到工程中会让工程更为健壮。源代码无须为资源文件使用一些不可移植的路径名。要引用一个存储成资源的文件，可以使用在.rcc文件中指定的别名并在前面带一个前缀":/&ldquo;。于是，每个资源好像位于一个私有虚文件系统中，其根为&rdquo;:/&ldquo;。然而，得到这些好处是需要付出代价的，可执行文件会更大，程序也会需要更多的内存</li>
<li>有3个Qt类可以简化处理图片：

<ul>
<li>QImage——用于离屏操作，输入输出操作，并可直接访问像素</li>
<li>QPixmap——用于在屏幕上进行绘制并优化，仅用在主线程中</li>
<li>QIcon——用于视频内存的缓冲且经常用到，但仅用在主线程中</li>
<li>QPicture——存储绘制的操作而不是实际的位图图片</li>
</ul>
</li>
</ol>
</blockquote>

<h2>布局</h2>

<blockquote><ol>
<li>布局可以将它们的Widgets排列成如下几种形式：

<ul>
<li>垂直型(QVBoxLayout)</li>
<li>水平型(QHBoxLayout)</li>
<li>网格型(QGridLayout)</li>
<li>窗体型(QFormLayout)</li>
<li>栈型，任何时候都只有一个窗件可见(QStackedLayout)</li>
</ul>
</li>
<li>可以使用addWidget()函数向QLayout添加窗件，当窗件添加到布局中时，它会称为拥有该布局的窗件的子对象。窗件永远不会称为布局的子对象</li>
<li>为了能够顺利地管理其几何形状，每个QLayout对象都必须有一个父对象，这可以是一个QWidget，也可以是一个QLayout。可以在创建布局时通过向构造函数传递一个指向父窗件或者布局的指针来指定其父对象。当然，也可以先创建一个QLayout而不指定QLayout的父对象，这种情况下，可以稍后通过调用QWidget::addLayout()来指定其父对象</li>
<li>布局可以拥有子布局，通过调用addLayout()函数，可以将一个布局添加为另外一个布局的子布局。如果布局的父对象是一个窗件，那么该窗件将再也无法称为另外一个布局的父对象</li>
<li>不使用Qt设计师时，可以使用QLayout类的API来直接指定各个窗件之间的分割、伸展和支撑

<ul>
<li>addSpacing(int size)会向布局的末尾添加固定数量的像素</li>
<li>addStretch(int stretch = 0)会添加数目不定的像素。此函数由一个最小的数目开始，然后逐渐扩展到使用所有的可用空间。如果在同一个布局中进行多次扩展，可以用此作为一个增长因子</li>
<li>addStrut(int size)讲给处置方向施加一个最小的数值(也就是，QVBoxLayout的宽度或者QHBoxLayout的高度)</li>
</ul>
</li>
</ol>
</blockquote>

<h2>QTimer</h2>

<blockquote><ol>
<li>QTimer对象是一个倒数计时器，以毫秒级时间间隔启动，当其到达零时会发出一个timeout()信号.QTimer可用来以规则的间隔来发射信号，或者如果singleShot属性已设置成true，则在给定的时间间隔后仅发射一次信号。QTimer有一个静态函数singleShot()，可以在给定的时间间隔后调用一次槽。如果倒数间隔设置成0，QTimer会在事件队列中的全部事件处理完后就立刻发出timeout()信号</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QTimer</span><span class="o">::</span><span class="n">singleShot</span><span class="p">(</span><span class="n">m_expInterval</span><span class="p">,</span><span class="n">this</span><span class="p">,</span><span class="n">SLOT</span><span class="p">(</span><span class="n">timerDisplayRandStr</span><span class="p">()));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>绘制事件和画图</h2>

<blockquote><ol>
<li>一个Widget应当在其paintEvent()方法中执行适当的绘制操作。这是QWidget中唯一可以创建QPainter painter(this)的地方。有下面几个原因使得QPaintEvent可以被发送到QWidget上。

<ol>
<li>窗件是隐藏的，然后又显露了出来</li>
<li>窗件改变了大小或者进行了重新排布</li>
<li>调用了update()或者repaint()。repaint()在paintEvent()得到调用后才会返回。update()在QPaintEvent被放进事件队列后会立即返回</li>
</ol>
</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">void</span> <span class="n">LifeWidget</span><span class="o">::</span><span class="n">paintEvent</span><span class="p">(</span><span class="n">QPaintEvent</span><span class="o">*</span> <span class="n">evt</span><span class="p">){</span>
</span><span class='line'>  <span class="n">QPainter</span> <span class="n">painter</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m_image</span><span class="p">.</span><span class="n">isNull</span><span class="p">()){</span>
</span><span class='line'>      <span class="n">painter</span><span class="p">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">QPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">m_image</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QMainWindow</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">class</span> <span class="nl">MyMainWindow</span><span class="p">:</span><span class="n">public</span> <span class="n">QMainWindow</span><span class="p">{</span>
</span><span class='line'>  <span class="n">Q_OBJECT</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>  <span class="n">explicit</span> <span class="n">MyMainWindow</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">parent</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">closeEvent</span><span class="p">(</span><span class="n">QCloseEvent</span><span class="o">*</span> <span class="n">event</span><span class="p">);</span>
</span><span class='line'><span class="n">protected</span> <span class="nl">slots</span><span class="p">:</span>
</span><span class='line'>  <span class="n">virtual</span> <span class="kt">void</span> <span class="n">newFile</span><span class="p">();</span>
</span><span class='line'>  <span class="n">virtual</span> <span class="kt">void</span> <span class="nf">open</span><span class="p">();</span>
</span><span class='line'>  <span class="n">virtual</span> <span class="kt">bool</span> <span class="nf">save</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QAction</h2>

<blockquote><ol>
<li>QAction从QObject派生而来，是用于用户选定动作的一个基类。它提供了丰富的接口，它还可以用于许多种动作中。QWidget接口使得每个窗件都可以维护一个QList&lt;QAction*>。所有QWidget都可以拥有QAction，一些窗件借助上下文提供了QAction的清单，其他借助菜单栏。</li>
<li>QMenu是一个能够给QAction集合提供特殊视图的QWidget。QMenuBar是菜单的一个集合，常见于QMainWindow中。</li>
<li>每次调用QMenu::addAction(text,target,slot,shortcut)函数，都会窗件一个未命名的QAction，并且会将其添加到这个QMenu上。然后会调用它的积累函数，QWidget::addAction(QAction*),这样把新建的QAction添加到用于上下文菜单的QMenu的QAction清单中。</li>
</ol>
</blockquote>

<h2>QSettings</h2>

<blockquote><ol>
<li>QSettings会管理键/值对的永久映射关系，它是一个QObject，并且会使用一些与QObject相似的属性接口——setValue()和value()——来设置和获取它的值。这个类可以用来存储任何需要在多次执行之间进行记忆的数据</li>
<li>QSettings需要一个组织名和一个应用程序名，但当使用默认的构造函数时，QSettings会从QApplication中获得这些值。每个名称组合都会定义一个唯一的永久映射，这使得不会与其他命名的Qt应用程序产生冲突</li>
<li>允许多个实例共享相同状态的类，可以看成是Monodtate模式的一种实现。拥有相同组织/应用程序名称的两个QSettings实例，可以访问同一个永久映射数据。这简化了应用程序从不同源文件访问公共设置值的过程。QSettings是Monostate模式的一种实现</li>
</ol>
</blockquote>

<h2>剪切板</h2>

<blockquote><ol>
<li>每个Qt应用程序都可以使用qApp->clipboard()访问系统的剪贴板。剪贴板会保存带类型的数据(文本，图片，URL或者自定义数据)。要往剪贴板中放置数据，可以创建一个QMimeData，以一定的方式对数据进行编码，并且调用QClipBoard->setMimeData()。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">qApp</span><span class="o">-&gt;</span><span class="n">clipboard</span><span class="p">(),</span><span class="n">SIGNAL</span><span class="p">(</span><span class="n">changed</span><span class="p">(</span><span class="n">QClipboard</span><span class="o">::</span><span class="n">Mode</span><span class="p">)),</span><span class="n">this</span><span class="p">,</span><span class="n">SLOT</span><span class="p">(</span><span class="n">clipboardChanged</span><span class="p">(</span><span class="n">QClipboard</span><span class="o">::</span><span class="n">Mode</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QImage</h2>

<blockquote><ol>
<li>QImage在像素处理上得到了优化，QPixmap使用了视频存储器，它也是需要在屏幕上显示图片的多种窗件要用到的类。可以吧QImage转换成QPixmap并将其在QLabel进行显示</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="nf">h</span><span class="p">(</span><span class="n">m_Image</span><span class="p">.</span><span class="n">height</span><span class="p">()),</span><span class="n">w</span><span class="p">(</span><span class="n">m_Image</span><span class="p">.</span><span class="n">width</span><span class="p">());</span>
</span><span class='line'><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="n">QRgb</span> <span class="n">oldpix</span><span class="p">,</span><span class="n">newpix</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">y</span><span class="o">&lt;</span><span class="n">h</span><span class="p">;</span><span class="n">y</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">x</span><span class="o">&lt;</span><span class="n">w</span><span class="p">;</span><span class="n">x</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>      <span class="n">oldpix</span><span class="o">=</span><span class="n">m_Image</span><span class="p">.</span><span class="n">pixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>      <span class="n">r</span><span class="o">=</span><span class="n">qRed</span><span class="p">(</span><span class="n">oldpix</span><span class="p">)</span><span class="o">*</span><span class="n">radj</span><span class="p">;</span>
</span><span class='line'>      <span class="n">g</span><span class="o">=</span><span class="n">qGreen</span><span class="p">(</span><span class="n">oldpix</span><span class="p">)</span><span class="o">*</span><span class="n">gadj</span><span class="p">;</span>
</span><span class='line'>      <span class="n">b</span><span class="o">=</span><span class="n">qBlue</span><span class="p">(</span><span class="n">oldpix</span><span class="p">)</span><span class="o">*</span><span class="n">badj</span><span class="p">;</span>
</span><span class='line'>      <span class="n">newpix</span><span class="o">=</span><span class="n">qRgb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>      <span class="n">m_Image</span><span class="p">.</span><span class="n">setPix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">newpix</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>模板类</h2>

<blockquote><p>因为每个Q_OBJECT都需要通过moc为其生成代码，而且moc并未智能到知道如何生成模板类的特化，孤儿不允许使一个已经标记为Q_OBJECT的类再次成为模板类</p></blockquote>

<h2>qSort</h2>

<blockquote><ol>
<li>qSort()函数是一个使用堆分类算法进行实现的范型方法。qSort()可以应用到任何Qt容器，只要容器内的对象拥有公共接口operator&lt;()和operator==()。基本数据类型的容器也可以使用此函数进行排序</li>
</ol>
</blockquote>

<h2>反射与元对象</h2>

<blockquote><ol>
<li>所谓反射，就是指对象成员的自我检查，使用反射编程，就可以编写出通用的操作，可对具有各种不同结构的类进行操作。使用通用的值存储器QVariant，就可以按照一种统一的方式来对基本类型和其他普通类型进行操作</li>
<li>所谓元对象就是描述另一个对象结构的对象。QMetaObject是元对象模式的一个Qt实现，它提供了一个QObject对象所拥有的属性和方法的信息。元对象模式有时也称为反射模式</li>
<li>一个拥有元对象的类就可以支持反射。这是一个许多面向对象语言都具有的性质。虽然C++中不存在反射，但Qt的元对象编译器(moc)可以为QObject生成支持这种机制的代码</li>
<li>只要满足一定条件(每个类都必须在头文件中定义，并且列举在工程文件的HEADERS中，同时此类的定义中还必须包括Q_OBJECT宏)，每个派生自QObject的类都会拥有一个有moc为其生成的QMetaObject。QObject拥有有个成员函数，它能够返回指向对象的QMetaObject的指针，这个函数原型是：QMetaObject* QObject：：metaObject() const[virtual]</li>
<li>可以使用QMetaObject的下面这些方法来获取一个QObject的信息：

<ul>
<li>className(),它会将类的名称以const char*格式返回</li>
<li>superClass(),如果存在基类的QMetaObject，则返回其指针，如果不存在返回0</li>
<li>mathodCount(),返回类的成员函数的个数</li>
</ul>
</li>
<li>信号和槽机制同样需要依赖与QMetaObject</li>
<li>通过使用QMetaObject和QMetaProperty就可以编写足够通用的代码来处理所有具有自我描述能力的类</li>
<li>除了C++的RTTI运算符dynamic_cast和typeid之外，Qt还提供了两种运行时的类型识别机制：

<ul>
<li>qobject_cast</li>
<li>QObject::inherits()</li>
</ul>
</li>
<li>qobject_cast是一个ANSI风格的类型转换运算符：DestType<em> qobject_cast&lt;DestType</em>> (QObject* qoptr),如果转换失败返回NULL。qobject_cast实际是一个向下转换运算符，类似于dynamic_cast。拥有指向派生类的基类指针时，向下转换允许调用在基类接口中不存在的派生类方法。</li>
<li>访问数据成员的方式：

<ul>
<li>直接访问，通过经典的gettet/settet，速度快，更为有效</li>
<li>间接访问，通过QObject/QMetaObject接口，可让代码复用性更好</li>
</ul>
</li>
<li>使用Q_PROPERTY宏来描述QObject的属性：Q_PROPERTY(type name READ getFunction [WRITE setFunction] [RESET resetFunction] [NOTIFY notifySignal] [DESIGNABLE bool] [SCRIPTABLE bool] [STORED bool]),例如：</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span>customer-props.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">class</span> <span class="nl">Customer</span><span class="p">:</span><span class="n">public</span> <span class="n">QObject</span><span class="p">{</span>
</span><span class='line'>  <span class="n">Q_OBJECT</span>         <span class="c1">//moc预处理类需要的宏</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">id</span> <span class="n">READ</span> <span class="n">getId</span> <span class="n">WRITE</span> <span class="n">setId</span> <span class="n">NOTIFY</span> <span class="n">valueChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">name</span> <span class="n">READ</span> <span class="n">getName</span> <span class="n">WRITE</span> <span class="n">setName</span> <span class="n">NOTIFY</span> <span class="n">valueChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">address</span> <span class="n">READ</span> <span class="n">getAddress</span> <span class="n">WRITE</span> <span class="n">setAddress</span> <span class="n">NOTIFY</span> <span class="n">addressChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">phone</span> <span class="n">READ</span> <span class="n">getPhone</span> <span class="n">WRITE</span> <span class="n">setPhone</span> <span class="n">NOTIFY</span> <span class="n">phoneChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QDate</span> <span class="n">dateEstablished</span> <span class="n">READ</span> <span class="n">getDateEstablished</span><span class="p">);</span>     <span class="c1">//只读属性</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">type</span> <span class="n">READ</span> <span class="n">getType</span> <span class="n">WRITE</span> <span class="n">setType</span> <span class="n">NOTIFY</span> <span class="n">valueChanged</span><span class="p">);</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">CustomerType</span><span class="p">{</span>
</span><span class='line'>              <span class="n">Corporate</span><span class="p">,</span><span class="n">Individual</span><span class="p">,</span><span class="n">Educational</span><span class="p">,</span><span class="n">Government</span>
</span><span class='line'>                  <span class="p">};</span>                                               <span class="c1">//枚举类型定义必须与Q_ENUMS宏的定义出现在同一类定义中</span>
</span><span class='line'>  <span class="n">Q_ENUMS</span><span class="p">(</span><span class="n">CustomerType</span><span class="p">);</span>                                          <span class="c1">//特殊的宏可以实现生成字符串到枚举之间的转换功能；必须在同一个类中</span>
</span><span class='line'>  <span class="n">explicit</span> <span class="nf">Customer</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="n">name</span> <span class="o">=</span> <span class="n">QString</span><span class="p">(),</span><span class="n">QObject</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//之所以声明为explicit，是因为不希望从QString转换到Customer时出现意外</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">getId</span> <span class="k">const</span><span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">m_id</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">setType</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">newType</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">setType</span><span class="p">(</span><span class="n">QString</span> <span class="n">newType</span><span class="p">);</span>
</span><span class='line'><span class="nl">signals</span><span class="p">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">addressChanged</span><span class="p">(</span><span class="n">QString</span> <span class="n">newAddress</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="n">QString</span> <span class="n">propertyName</span><span class="p">,</span><span class="n">QVariant</span> <span class="n">newValue</span><span class="p">,</span><span class="n">QVariant</span> <span class="n">oldValue</span><span class="o">=</span><span class="n">QVariant</span><span class="p">());</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">phoneChanged</span><span class="p">(</span><span class="n">QString</span> <span class="n">newPhone</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">typeChanged</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">type</span><span class="p">);</span>
</span><span class='line'><span class="nl">private</span><span class="p">:</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">m_id</span><span class="p">,</span><span class="n">m_name</span><span class="p">,</span><span class="n">m_address</span><span class="p">,</span><span class="n">m_phone</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QDate</span> <span class="n">m_date</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CustomerType</span> <span class="n">m_type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>customer-props.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">Customer</span><span class="o">::</span><span class="n">Customer</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="n">name</span><span class="p">,</span><span class="n">QObject</span><span class="o">*</span> <span class="n">parent</span><span class="p">)</span><span class="o">:</span><span class="n">QObject</span><span class="p">(</span><span class="n">parent</span><span class="p">){</span>
</span><span class='line'>  <span class="n">setObjectName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Customer</span><span class="o">::</span><span class="n">setId</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">newId</span><span class="p">){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">newId</span> <span class="o">!=</span> <span class="n">m_id</span><span class="p">){</span>
</span><span class='line'>      <span class="n">QString</span> <span class="n">oldId</span> <span class="o">=</span> <span class="n">m_id</span><span class="p">;</span>
</span><span class='line'>      <span class="n">m_id</span> <span class="o">=</span> <span class="n">newId</span><span class="p">;</span>
</span><span class='line'>      <span class="n">emit</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span><span class="n">newId</span><span class="p">,</span><span class="n">oldId</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Customer</span><span class="o">::</span><span class="n">setType</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">theType</span><span class="p">){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">m_type</span> <span class="o">!=</span> <span class="n">theType</span><span class="p">){</span>
</span><span class='line'>      <span class="n">CustomerType</span> <span class="n">oldType</span> <span class="o">=</span> <span class="n">m_type</span><span class="p">;</span>
</span><span class='line'>      <span class="n">m_type</span> <span class="o">=</span> <span class="n">theType</span><span class="p">;</span>
</span><span class='line'>      <span class="n">emit</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">,</span><span class="n">theType</span><span class="p">,</span><span class="n">oldType</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Customer</span><span class="o">::</span><span class="n">setType</span><span class="p">(</span><span class="n">QString</span> <span class="n">newType</span><span class="p">){</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="n">QMetaObject</span><span class="o">*</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">metaObject</span><span class="p">();</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">propindex</span> <span class="o">=</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">indexOfProperty</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="n">QMetaProperty</span> <span class="n">mp</span> <span class="o">=</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="n">propindex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">QMetaEnum</span> <span class="n">menum</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">enumerator</span><span class="p">();</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ntyp</span> <span class="o">=</span> <span class="n">newType</span><span class="p">.</span><span class="n">toAscii</span><span class="p">().</span><span class="n">data</span><span class="p">();</span>
</span><span class='line'>  <span class="n">CustomerType</span> <span class="n">theType</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">CustomerType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">menum</span><span class="p">.</span><span class="n">keyToValue</span><span class="p">(</span><span class="n">ntyp</span><span class="p">));</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">theType</span> <span class="o">!=</span> <span class="n">m_type</span><span class="p">){</span>
</span><span class='line'>      <span class="n">CustomerType</span> <span class="n">oldType</span> <span class="o">=</span> <span class="n">m_type</span><span class="p">;</span>
</span><span class='line'>      <span class="n">m_type</span> <span class="o">=</span> <span class="n">theType</span><span class="p">;</span>
</span><span class='line'>      <span class="n">emit</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">,</span><span class="n">theType</span><span class="p">,</span><span class="n">oldType</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">QString</span> <span class="n">Customer</span><span class="o">::</span><span class="n">getTypeString</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">property</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">).</span><span class="n">toString</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>可以通多下面的函数来获得任意属性的值：QVariant QObject::property(QString propertyName);
QVariant是一个联合体的封装，其中包含了所有基本类型和所允许的全部Q_PROPERTY类型。QVariant有一个toString()函数能够为它支持的许多类型返回其QString表示。
QVariant对象可以通过QMetaProperty::read()或者QObject::property()获得
同一类的所有对象会共享同一个metaObject，因而会有相同元属性组</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QString</span> <span class="nf">objTOString</span><span class="p">(</span><span class="k">const</span> <span class="n">QObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="n">QStringList</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">QMetaObject</span><span class="o">*</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">metaObject</span><span class="p">();</span>
</span><span class='line'>  <span class="n">result</span> <span class="o">+=</span> <span class="n">QString</span><span class="p">(</span><span class="s">&quot;class %1:public %2 {&quot;</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">className</span><span class="p">()).</span><span class="n">arg</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">superClass</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">className</span><span class="p">());</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">propertyCount</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">QMetaProperty</span> <span class="n">qmp</span><span class="o">=</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>      <span class="n">QVariant</span> <span class="n">value</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="n">qmp</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">canConvert</span><span class="p">(</span><span class="n">QVariant</span><span class="o">::</span><span class="n">String</span><span class="p">)){</span>
</span><span class='line'>          <span class="n">result</span> <span class="o">+=</span> <span class="n">QString</span><span class="p">(</span><span class="s">&quot;%1 %2=%3;&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">qmp</span><span class="p">.</span><span class="n">typeName</span><span class="p">())</span>
</span><span class='line'>          <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">qmp</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
</span><span class='line'>          <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;};&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QMetaType</h2>

<blockquote><ol>
<li>QMetaType是一个用于值类型的辅助类，对于60多种内置类型，QMetaType为每个类型ID关联了一个类型名，从而使构造和析构可以在运行时动态发生。有一个名称为QMetaType::Type的公共枚举，它有所有QVariant兼容类型的值。在QMetaType::Type中的枚举值与QVariant::Type中的枚举值一样
通过使用Q_ENUMS宏可以在QVariant系统中加入一些自定义的枚举类型。
使用Q_DECLARE_METATYPE(MyType)宏也有可能把自己的值类型加到QMetaType列表中。如果MyType有公共的默认复制构造函数和公共的复制构造函数以及一个公共的析构函数，Q_DECLARE_METATYPE宏使得它可用作QVariant中的自定义类型
要注册的元类型必须已经用Q_DECLARE_METATYPE声明过。模板函数qRegisterMetaType<T>()会注册类型T并返回由QMetaType使用的内部ID。这个函数有一个重载版本，qRegisterMetaType<T>(const char* name),它可以让你注册一个名称作为类型T的名称。对于这个函数的调用必须早早地出现在主程序中。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span>fraction.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">class</span> <span class="nl">Fraction</span><span class="p">:</span><span class="n">public</span> <span class="n">QPair</span><span class="o">&lt;</span><span class="n">qint32</span><span class="p">,</span><span class="n">qint32</span><span class="o">&gt;</span><span class="p">{</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>  <span class="n">Fraction</span><span class="p">(</span><span class="n">qint32</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">qint32</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="n">QPair</span><span class="o">&lt;</span><span class="n">qint32</span><span class="p">,</span><span class="n">qint32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">d</span><span class="p">){}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">Q_DECLARE_METATYPE</span><span class="p">(</span><span class="n">Fraction</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>metatype.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
</span><span class='line'>  <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">);</span>
</span><span class='line'>  <span class="n">qRegissterMetaType</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Fraction&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Fraction</span> <span class="n">twoThirds</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QVariant</span> <span class="n">var</span><span class="p">;</span>
</span><span class='line'>  <span class="n">var</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">twoThirds</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">value</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="n">twoThirds</span><span class="p">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">Fraction</span> <span class="n">oneHalf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Fraction</span> <span class="n">threeQuarters</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QList</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span> <span class="n">fractions</span><span class="p">;</span>
</span><span class='line'>  <span class="n">fractions</span><span class="o">&lt;&lt;</span><span class="n">oneHalf</span><span class="o">&lt;&lt;</span><span class="n">twoThirds</span><span class="o">&lt;&lt;</span><span class="n">threeQuarters</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QFile</span> <span class="n">binaryTestFile</span><span class="p">(</span><span class="s">&quot;testMetaType.bin&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QDataStream</span> <span class="n">dout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binaryTestFile</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dout</span><span class="o">&lt;&lt;</span><span class="n">fractions</span><span class="p">;</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QDataStream</span> <span class="n">din</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binaryTestFile</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QList</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span> <span class="n">frac2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">din</span> <span class="o">&gt;&gt;</span> <span class="n">frac2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span><span class='line'>  <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">fractions</span> <span class="o">==</span> <span class="n">frac2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">creatTest</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">creatTest</span><span class="p">(){</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">fracType</span> <span class="o">=</span> <span class="n">QMetaType</span><span class="o">::</span><span class="n">type</span><span class="p">(</span><span class="s">&quot;Fraction&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span><span class="o">*</span> <span class="n">vp</span> <span class="o">=</span> <span class="n">QMetaType</span><span class="o">::</span><span class="n">construct</span><span class="p">(</span><span class="n">fracType</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Fraction</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">vp</span><span class="p">);</span>
</span><span class='line'>  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">first</span>  <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Q_ASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span> <span class="o">==</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>invokeMethod()</h2>

<blockquote><ol>
<li>Qt把信号连接到槽需要一种机制：通过名称以类型安全的方式来间接调用这些槽，当调用槽时，实际是由invokeMethod()完成的。</li>
<li>与QObject::connect()类似，invokeMethod()接受一个可选参数Qt::ConnectionType,该参数可让你来决定是要用同步调用还是要用异步调用。默认情况下是Qt::AutoConnection，表示发射者和接收者处于同一线程中时会同步执行一个槽</li>
<li>要通过invokeMethod()向函数传递类型参数，可以用Q_ARG宏创建一些值，这样会返回一个QGenericArgument，它封装了单个参数的类型和值信息</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">void</span> <span class="n">AutoSaver</span><span class="o">::</span><span class="n">saveIfNecessary</span><span class="p">(){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">QMetaObject</span><span class="o">::</span><span class="n">invokeMethod</span><span class="p">(</span><span class="n">parent</span><span class="p">(),</span><span class="s">&quot;save&quot;</span><span class="p">)){</span>
</span><span class='line'>      <span class="n">qWarning</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&quot;AutoSaver:error invoking save() on parent&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QByteArray</span> <span class="n">buffer</span><span class="o">=</span><span class="p">...;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="n">QMetaObject</span><span class="o">::</span><span class="n">invokeMethod</span><span class="p">(</span><span class="n">m_thread</span><span class="p">,</span><span class="s">&quot;caculateSpectrum&quot;</span><span class="p">,</span><span class="n">Qt</span><span class="o">::</span><span class="n">AutoConnection</span><span class="p">,</span><span class="n">Q_ARG</span><span class="p">(</span><span class="n">QByteArray</span><span class="p">,</span><span class="n">buffer</span><span class="p">),</span><span class="n">Q_ARG</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">format</span><span class="p">.</span><span class="n">frequency</span><span class="p">()),</span><span class="n">Q_ARG</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">bytesPerSample</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>MVC设计模式</h2>

<blockquote><ol>
<li>MVC由三类对象组成。模型是应用程序对象，视图是它的屏幕展示，控制器定义了用户界面对用户输入的反应行为。</li>
<li>在Qt中，不同的控制器类的基类是QAbstractItemDelegate。那些连接信号与槽的connect语句也可以认为是控制器代码</li>
<li>Qt中包含有一个模型/视图框架，用于维护数据的组织管理和向用户的呈现方式之间的分离。三个最常用的视图类(列表、树和表格)都是默认提供的。另外，它还提供了抽象的和具体的数据模型，这些数据模型可被扩展和自定义以保存不同类型的数据。</li>
<li>视图是获取、修改和呈现数据的对象。QAbstractItemModel定义了视图(还有委托)访问数据的一个标准接口。模型中存储供显示和操作的具体数据。通过信号和槽，他们将数据的变化通知给所有相关联的视图。每个视图对象都有一个指向模型对象的指针，视图对象会频繁访问模型的方法以获取或设置数据，或者做各种其他操作。</li>
<li>模型中每个数据项都用一个模型索引来表示。模型索引为视图和委托提供了在不知道其底层数据结构的情况下间接访问模型中数据项的方法。QModeIndex对象由模型创建，可以被模型、视图或委托代码用于定位数据模型中特定项。QModeIndex对象具有很短的生命周期，可能在刚刚创建后就变成无效的状态，因此它们应该被立即使用而后丢弃</li>
<li>如果使用一个在若干指令操作前已经存在的QModeIndex，那么应该先调用QModelIndex::isValid（）。QPersistentModelIndex对象具有更长的生命周期，但是在使用前任然应该先调用isValid()来进行检查</li>
</ol>
</blockquote>

<h2>智能指针</h2>

<blockquote><ol>
<li>一个重写了指针解引用操作operator*()和operator->()的类被称为智能指针。</li>
<li>QScopedPointer是一个在指针作用域结束后自动删除所引用对象的智能指针。它类似于std::auto_ptr。复制QScopedPointer是毫无意义的，因为它会导致所引用的对象重复删除</li>
<li>QSharedPointer是一个自动删除它所引用的对象的智能指针，但是它允许被复制，而且QSharedPointer会保持一个引用计数。共享的堆对象只有在最后一个指向它的只能指针销毁时才会被删除。</li>
</ol>
</blockquote>

<h2>输入掩码</h2>

<blockquote><p>1.所谓的输入掩码，是一种控制用户在输入窗件中可键入的内容的主动模式。它有助于防止输入某些类型的不正确的数据。每个QLineEdit都有一个QString属性用来存储掩码字符。输入掩码可以指定在键入QLineEdit的字符串中那个位置处的何种字符是允许的。该字符串由一些特殊的、预定义的掩码字符和一些占据输入字符串相应位置的普通字符构成
掩码字符：
    * A:ASCII字母型字符——大写或者小写
    * N:ASCII字母数字型字符——大写或者小写
    * X:任意的ASCII字符
    * D:ASCII非零数字
    * 9:ASCII数字
    * H:十六进制数字
    * B:二进制数字
    * >:随后的字母字符是大写
    * &lt;:随后的字母字符是小写
    * ！:结束大小写转换
    * :转义字符</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QLineEdit</span><span class="o">*</span> <span class="n">m_StringEntry</span><span class="p">;</span>
</span><span class='line'><span class="n">m_StringEntry</span><span class="o">-&gt;</span><span class="n">setInputMask</span><span class="p">(</span><span class="n">m_InputMask</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QRegExp</h2>

<blockquote><ol>
<li>正则表达式是验证输入、从输入中提取数据以及对输入进行搜索和替换的强大工具。Qt提供了QRegExp类，它实现了Perl风格的扩展正则表达式语言的大部分功能</li>
<li>特殊字符：

<ul>
<li>&lsquo;.'可以与任意字符相匹配，称之为元字符</li>
<li>&lsquo;\n'匹配换行符</li>
<li>&lsquo;\f'匹配换页符</li>
<li>&lsquo;\t'匹配制表符</li>
<li>&lsquo;\xhhhh'匹配一个Unicode字符，其对应的码值是范围为0x0000到0xFFFF之间的一个十六进制数hhhh</li>
</ul>
</li>
<li>量词——说明前面的字符(或字符组)在匹配的表达式中可出现次数的修饰符

<ul>
<li>&lsquo;+&rsquo; 出现1次或者更多次</li>
<li>&lsquo;?&rsquo; 出现0次或者1次</li>
<li>&lsquo;*&rsquo; 出现0次或者更多次</li>
<li>{i,j} 出现至少i次但不超过j次</li>
</ul>
</li>
<li>字符集——在匹配表达式指定位置允许出现的字符集合

<ul>
<li>&lsquo;\s&rsquo; 匹配任何空白符</li>
<li>&lsquo;\S&rsquo; 匹配任何非空白符</li>
<li>&lsquo;\d&rsquo; 匹配任何数字字符：从'0'到'9'</li>
<li>&lsquo;\D&rsquo; 匹配任何非数字字符</li>
<li>&lsquo;\w&rsquo; 匹配任何“单词”字符，也就是任意的字母、数字或者下划线</li>
<li>&lsquo;\W&rsquo; 匹配任意的非单词字符</li>
</ul>
</li>
<li>字符集也可以使用方括号指定:

<ul>
<li>[AEIOU]匹配这五个字符中的任意一个</li>
<li>[a-g]短线使此集合可匹配从'a'到'g'的字符</li>
<li>[^xyz]匹配任何除这三字符以外的字符</li>
</ul>
</li>
<li>分组和捕获字符——(圆括号)是可以用来把字符划分成组的特殊字符。字符组可以是后向引用的。也就是说，如果存在一个匹配，那么分组了的值将可以通过各种方法来捕获和访问。为了简便起见，一般规定在一个正则表达式中最多可以引用9个分组，即使用\1到\9这样的修饰符。此外还有一个QRegExp成员函数cap(int nth),它返回第那个分组(基于QString的形式返回)</li>
<li>锚点字符——去顶尝试进行匹配操作的边界

<ul>
<li>脱字符(^),如果它是正则表达式中的第一个字符，则说明匹配过程从字符串的开头处开始</li>
<li>美元符($),如果它是正则表达式的最后一个字符，则表明匹配过程指导字符串的结尾才结束</li>
<li>此外，还有单词边界(\b)断言或者非单词边界(\B),有助于我们关注正则表达式本身</li>
</ul>
</li>
</ol>
</blockquote>

<h2>Qt环境变量的获取与设置</h2>

<blockquote><p>QProcess::environment()函数和setEnvironment()函数</p></blockquote>

<h2>QProcess和进程控制</h2>

<blockquote><ol>
<li>QProcess是一个能够非常方便而且跨平台的用于启动和控制其他进程的类。它从QPbject派生而来，可充分利用信号和槽来简化和其他Qt类的交互</li>
<li>一个QProcess可以使用start()函数来启动另外一个进程，新进程将会成为一个子进程并且在父进程终止时而随之终止</li>
<li>Qt的线程模型允许线程的优先次序和控制。QThread是一个低级类，适合用于显式的构建长期运行的线程</li>
<li>QtConcurrent是一个命名空间，提供了用于编写并发软件的更高层次的类和算法。该命名空间有一个重要的类，QThreadPool，这是一个管理线程池的类。每个Qt应用程序都有一个QThreadPool::globalInstance()函数，它带有一个推荐的最大线程数，在大多数系统上，处理核的数量就是该值的默认值</li>
<li>借助QtConcurrent中函数式的map/filter/reduce算法，通过将进程分布在由线程池管理的多个线程上，可编写一个能够自动利用系统多核的程序。另外，在命令模式和利用QtConcurrent::run()工作时可把QRunnable用作基类。在这些情况下，无须显示地创建线程或者直接管理他们，只需简单把工作片段描述为具有正确接口的对象即可</li>
</ol>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UT4418_Introduce]]></title>
    <link href="http://suda-morris.github.io/blog/2015/07/13/ut4418-introduce/"/>
    <updated>2015-07-13T13:10:17+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/07/13/ut4418-introduce</id>
    <content type="html"><![CDATA[<h2>S5PV4418简介</h2>

<blockquote><p>S5PV4418处理器是三星2014年推出的4核处理器，使用Cortex-A9四核心，整体性能比Cortex-A8核心高出50%，提供6.4GB/s内存带宽，支持1080P的全高清视频输出，以及3D图形显示，支持LCD显示1080P高清电视输出等。完全是Exynos4412的升级版芯片，性能远远超过Exynos4412，并且基本兼容Exynos412</p></blockquote>

<h2>开发板配置</h2>

<ol>
<li>4G iNand(SDIN5C1-4G),1G DDR3(H5TQ4G63AFR-PBC),三星电源管理芯片&ndash;NXE2000</li>
<li>尺寸：120mm*90mm</li>
<li>TF卡支持热插拔，容量最大支持32G</li>
<li>设有开机键，长按3秒后开机</li>
<li>设有复位键，长按3秒后硬件复位，在系统启动后，可以通过软件去配置PMU来改变复位键长按时间的长短</li>
<li>通过SDA7123转换出VGA信号，VGA支持LCD同步显示，支持1080P视频输出</li>
<li>HDMI信号通过MCU直接引出，减少了转换芯片的链接，支持与LCD同步播放视频，支持的视频输出格式为480P，720P,1080P</li>
<li>以太网接口采用RTL8211E-VB-CG芯片，支持10M，100M，1000M网自适应</li>
<li>配置了USB接口的wifi模块&ndash;RTL8188</li>
<li>配置了FT-009红外接收头，支持红外遥控接收</li>
</ol>


<h2>开发环境搭建</h2>

<ol>
<li>使用虚拟机VirtualBox安装Ubuntu14.04.2LTS系统</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POE简介]]></title>
    <link href="http://suda-morris.github.io/blog/2015/07/06/poe-introduce/"/>
    <updated>2015-07-06T20:16:12+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/07/06/poe-introduce</id>
    <content type="html"><![CDATA[<blockquote><p>以太网供电（Power over Ethernet，简称PoE）也称为PoE供电，是一种可以在以太网路中透过双绞线来传输电力与资料到装置上的技术。以太网供电技术的出发点是让IP电话、WLAN接入点、网络摄像头等小型网络设备，可以直接从以太网线（4对双绞线中空闲的2对来传输）获得电力，无需单独铺设电力线，以简化系统布线，降低网络基础设施的建设成本。</p></blockquote>

<h2>使用POE的注意事项</h2>

<blockquote><p>使用POE需要留意以下三点：</p>

<ol>
<li>如上图所示，不是所有的以太网交换机都支持PoE供电功能，供电模块内置或外置，一般价格比普通交换贵一些。</li>
<li>要求终端也支持PoE受电功能。</li>
<li>通过网线供电，功率本身是有一定限制的，留意查看不同设备的使用说明和功率要求。</li>
</ol>
</blockquote>

<h2>典型的系统</h2>

<blockquote><p>一个典型的以太网供电系统。在配线柜里保留以太网交换机设备，用一个带电源供电集线器(Midspan HUB)给局域网的双绞线提供电源。在双绞线的末端，该电源用来驱动电话、无线接入点、相机和其他设备。为避免断电，可以选用一个UPS。</p></blockquote>

<h2>原理</h2>

<blockquote><p>标准的五类网线有<strong>四对双绞线</strong>,但是在10M BASE-T和100M BASE-T中只用到其中的<strong>两对</strong>。IEEE80 2.3af允许<strong>两种</strong>用法:</p>

<ol>
<li>应用空闲脚供电时,4、5脚连接为正极,7、8脚连接为负极。</li>
<li>应用数据脚供电时,将DC电源加在传输变压器的中点,不影响数据的传输。在这种方式下线对1、2和线对3、6可以为任意极性。</li>
</ol>


<p>IEEE802.3af标准不允许同时应用以上两种情况。电源提供设备PSE只能提供一种用法,但是电源应用设备PD必须能够同时适应两种情况。该标准规定供电电源通常是48V、13W的。PD设备提供48V到低电压的转换是较容易的,但同时应有1500V的绝缘安全电压。</p></blockquote>

<p><img src="http://i.imgur.com/uRd8v4m.png" alt="POE典型组网图" /></p>

<h2>参数</h2>

<blockquote><p>一个完整的POE系统包括供电端设备(PSE, Power Sourcing Equipment)和受电端设备(PD, Powered Device)两部分。PSE设备是为以太网客户端设备供电的设备,同时也是整个POE以太网供电过程的管理者。而PD设备是接受供电的PSE负载,即POE系统的客户端设备,如IP电话、网络安全摄像机、AP及掌上电脑( PDA)或移动电话充电器等许多其他以太网设备（实际上,任何功率不超过13W的设备都可以从RJ45插座获取相应的电力）。</p>

<p>POE标准供电系统的主要供电特性参数为：</p>

<ol>
<li>电压在44～57V之间,典型值为48V。</li>
<li>允许最大电流为550mA,最大启动电流为500mA。</li>
<li>典型工作电流为10～350mA,超载检测电流为350～500mA。</li>
<li>在空载条件下,最大需要电流为5mA。</li>
<li>为PD设备提供3.84～12.95W三个等级的电功率请求,最大不超过13W。（注意PD分级0和分级4没有显示出来而且不应采用。）</li>
<li>2009年10月30日 IEEE出了一个最新的802.3at标准，其中规定了POE可以提供更高的功率，超过了13W，可以达到30W,分三个等级(7W,15.4W,30W)</li>
<li>一般设备上会标明：15.4W/802.3af,30W/802.3at</li>
</ol>
</blockquote>

<h2>工作过程</h2>

<ol>
<li>检测

<ul>
<li>一开始,PSE设备在端口输出很小的电压,直到其检测到线缆终端的连接为一个支持IEEE 802.3af标准的受电端设备。检测电源输出线对之间的阻容值来判断PD是否存在</li>
</ul>
</li>
<li>PD端设备分类

<ul>
<li>当检测到受电端设备PD之后,PSE设备可能会为PD设备进行分类,并且评估此PD设备所需的功率损耗。</li>
</ul>
</li>
<li>开始供电

<ul>
<li>在一个可配置时间(一般小于15μs)的启动期内,PSE设备开始从低电压向PD设备供电,直至提供48V的直流电源。</li>
</ul>
</li>
<li>供电

<ul>
<li>为PD设备提供稳定可靠48V的直流电,满足PD设备不越过 30W的功率消耗。</li>
</ul>
</li>
<li>断电

<ul>
<li>若PD设备从网络上断开时,PSE就会快速地(一般在300～400ms之内)停止为PD设备供电,并重复检测过程以检测线缆的终端是否连接PD设备。</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Nginx]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/29/about-nginx/"/>
    <updated>2015-06-29T10:21:37+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/29/about-nginx</id>
    <content type="html"><![CDATA[<h2>Nginx简介</h2>

<blockquote><ol>
<li>Nginx是一种服务器软件，Nginx是一种高性能的HTTP和反向代理服务器，同时是一个代理邮件服务器，也就是Ngix上可以发布网站，也可以实现负载均衡，还可以作为邮件服务器实现收发邮件的功能</li>
<li>所谓负载均衡，是指当同时有N多个用户访问我们服务器的时候，为了减小服务器压力，我们需要将用户分别引入各服务器，分担服务器压力</li>
<li>优点：高并发，部署简单，内存消耗少，成本低</li>
<li>缺点：rewrite功能不够强大，模块没有Apache多</li>
</ol>
</blockquote>

<h2>其它服务器</h2>

<ol>
<li>IIS服务器只能在Windows上运行，Windows服务器性能不如Linux服务器</li>
<li>Tomcat服务器面向的是Java语言，是一种重量级的服务器</li>
<li>Apache服务器稳定，开源，跨平台，但是不支持高并发</li>
</ol>


<h2>Nginx环境的搭建</h2>

<ol>
<li><a href="http://nginx.org">进入官网下载最新版</a></li>
<li>安装gcc:<code>yum -y install gcc gcc-c++ autoconf automake</code></li>
<li>安装PCRE库文件：<code>yum -y install pcre pcre-devel</code></li>
<li>安装zlib库文件：<code>yum -y install zlib zlib-devel</code></li>
<li>解压缩Nginx压缩包，然后进入解压后文件夹，<code>./config --prefix=/software</code>,成功后执行<code>make $$ make install</code></li>
<li>启动服务器：<code>/software/nginx/sbin/nginx -c /software/nginx/conf/nginx.conf</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言知识点]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/27/c-language-review/"/>
    <updated>2015-06-27T15:17:24+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/27/c-language-review</id>
    <content type="html"><![CDATA[<h2><code>#ifdef和#if defined的差别</code></h2>

<p>注意两者都有个define的作用，区别在于使用方式上。前者的通常用法是:</p>

<figure class='code'><figcaption><span>只能在两者中选择是否有定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#ifdef  XXX</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于后者，常用法是：</p>

<figure class='code'><figcaption><span>可以在多个中选择是否有定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#if defined xxx1</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#elif defined xxx2</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#elif defined xxx3</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP语法基础]]></title>
    <link href="http://suda-morris.github.io/blog/2015/06/24/php-knowledge/"/>
    <updated>2015-06-24T16:00:02+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/06/24/php-knowledge</id>
    <content type="html"><![CDATA[<h3>变量</h3>

<ul>
<li>变量使用<strong>$+变量名</strong>来定义与使用，比如:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='PHP'><span class='line'><span class="nv">$a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="nv">$b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'><span class="k">echo</span> <span class="nv">$a</span><span class="o">+</span><span class="nv">$b</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>常量</h3>

<ul>
<li>使用关键字<strong>const</strong>：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='PHP'><span class='line'><span class="k">const</span> <span class="no">THE_VALUE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'><span class="k">echo</span> <span class="nx">THEVALUE</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用<strong>define</strong>函数：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='PHP'><span class='line'><span class="nb">define</span><span class="p">(</span><span class="s1">&#39;THE_VALUE&#39;</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="k">echo</span> <span class="nx">THE_VALUE</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
