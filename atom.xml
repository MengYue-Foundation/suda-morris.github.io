<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[WenRis Blog]]></title>
  <link href="http://suda-morris.github.io/atom.xml" rel="self"/>
  <link href="http://suda-morris.github.io/"/>
  <updated>2015-12-24T10:37:36+08:00</updated>
  <id>http://suda-morris.github.io/</id>
  <author>
    <name><![CDATA[suda-morris]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[eclipse+cygwin]]></title>
    <link href="http://suda-morris.github.io/blog/2015/12/10/eclipse-plus-cygwin/"/>
    <updated>2015-12-10T13:21:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/12/10/eclipse-plus-cygwin</id>
    <content type="html"><![CDATA[<h2>eclipse+cdt+cygwin配置c/c++开发环境</h2>

<ol>
<li><a href="https://cygwin.com/mirrors.html">下载cygwin</a>,默认情况下Cygwin没有选择C++开发所需要的包，在安装时需要选中：

<ul>
<li>gcc,gcc-core,gcc-g++,gcc-mingw-core,gcc-mingw-g++,make,gdb,bunutils</li>
</ul>
</li>
<li>安装好后，需要把Cygwin加入到Windows环境变量</li>
<li>下载安装CDT插件，或者直接下载安装带有CDT插件的eclipse软件</li>
<li>配置路径映射，eclipse中调试时，由于GDB使用的是unix格式的路径，而eclipse使用的是windows路径，导致找不到匹配的代码，需要手工设置：

<ol>
<li>进入eclipse的preference，搜索“lookup path”</li>
<li>进入后添加新的“Path Mapping”</li>
<li>把linux的路径映射到windows的路径，比如/cygdrive/c 映射成C:/</li>
</ol>
</li>
</ol>


<h2>cygwin技巧</h2>

<ol>
<li>清屏：ctrl+l</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spansion-FM4]]></title>
    <link href="http://suda-morris.github.io/blog/2015/12/09/spansion-fm4/"/>
    <updated>2015-12-09T12:53:06+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/12/09/spansion-fm4</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ESP8266使用]]></title>
    <link href="http://suda-morris.github.io/blog/2015/12/06/esp8266/"/>
    <updated>2015-12-06T18:06:10+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/12/06/esp8266</id>
    <content type="html"><![CDATA[<h2>NodeMCU-V1.0</h2>

<ol>
<li>核心板型号：ESP-12-E,4Mbytes（32Mbits）的flash</li>
<li><a href="https://github.com/nodemcu/nodemcu-firmware">开源官网</a></li>
<li>官网烧录工具使用：

<ol>
<li>SPI模式选择：DIO</li>
<li>FLASH SIZE选择：32Mbit</li>
<li>将最新的固件烧写到0x00000处</li>
<li>在烧写之前，需要按住FLASH按键不动然后按下RST按键一次</li>
</ol>
</li>
<li>nodemcu专用烧录工具：只需连接USB串口，选择好烧录文件，单击Flash即可完成烧写</li>
<li>Pin map
<img src="http://i.imgur.com/PoUJ0sw.png" alt="Node MCU Pin Map" />

<ul>
<li>其中D0（GPIO16）只能被用作gpio read/write，不支持中断，不支持pwm、i2c、onewire</li>
</ul>
</li>
<li>Lua core based on eLua project</li>
<li>cjson based on lua-cjson</li>
<li>File system based on spiffs</li>
<li>事件驱动的编程模型</li>
<li>内建的模块：node,json,file,timer,pwm,i2c,spi,onewire,net,mqtt,coap,gpio,wifi,adc,uart,bit,u8g,ucg,ws2801,ws2812,crypto,dht,rtc,sntp,bmp085,tls2561,hx711,system</li>
<li><a href="https://github.com/nodemcu/nodemcu-firmware/wiki/nodemcu_api_cn#noderestart">Node MCU API</a></li>
</ol>


<h2>ESP8266介绍</h2>

<p><img src="http://i.imgur.com/OC5vpzm.png" alt="ESP8266结构图" />
1. 内核架构：XtensaLX106（32位），由Tensilica公司开发，是个可配置软核CPU，指令集可扩展，扩展的指令集通过硬件实现。通常扩展指令集有几种方式：
    1. fusion，就是将多条指令合并为一条指令，从而缩短程序所需要的cycle数
    2. SIMD，就是单指令多数据
2. 默认串口波特率9600。当工作在AP模式时，默认的ip地址为192.168.4.1
3. CPU主频支持80MHz和160MHz，支持RTOS。内部三条总线：iBus访问内部，外部存储器；dBus访问数据RAM；AHB访问内部寄存器
4. 支持的无线网络类型：STA/AP/STA+AP
5. 安全机制：WEP/WPA-PSK/WPA2-PSK
6. 加密类型：WEP64/WEP128/TKIP/AES
7. 固件升级：本地串口，OTA云端升级
8. 网络协议：IPv4，TCP/UDP/FTP/HTTP
9. 支持的硬件接口：UART，I2C，PWM，GPIO，ADC（10位，ADC的范围在0~1V）
10. 串口数据传输最大传输速率为460800bps
11. 系统上电会运行厂商芯片内部的Boot loader，而在bootloader中串口波特率被设置为了<strong>74880</strong>
12. ESP8266的PWM频率100~500Hz
13. GPIO输出电压为VDD_IO（比如3.3V），输出电流应该不超过20mA
14. ESP8266有两个uart，其中uart0有Tx、Rx，可做数据传输，uart1仅有Tx，可做串口调试信息打印
15. ESP8266有两套MAC，因此可以支持softAP+station共存的模式
16. ESP8266 softAP可连接4个station
17. ESP8266低功耗只针对station模式，对于softAP则没有低功耗模式
18. ESP8266的TCP连接最多可以建立5个，UDP连接最多可以建立5个，可同时建立5个TCP连接和5个UDP连接
19. ESP8266片上没有ROM，用户程序存放在外部SPI Flash中。最大支持16MByte的容量。支持的SPI模式：Standard SPI，Dual SPI，DIO SPI，QIO SPI以及Quad SPI。注意，在下载固件时需要在下载工具选择对应模式，否则下载后程序将无法得到正确的运行
20. ESP8266芯片定义了1个SDIO Slave接口，SDIO由硬件实现，支持4位25MHz SDIOv1.1和4位50MHz SDIO v2.0</p>

<h2>最小系统</h2>

<p><img src="http://i.imgur.com/6Hsgedk.png" alt="ESP8266最下系统" />
1. Pin11和Pin17两个数字电源管脚，数字电源无需在电路中增加滤波电容。数字电源工作电压范围1.8v~3.3V
2. 在模拟电源部分，要注意当ESP8266工作在TX时候，瞬间电流会加大，往往会引起电源的轨道塌陷，所以在设计时在模拟电源电路上增加一个0603或者0805封装的10uF电容，此电容可与0402封装的0.1uF电容搭配
3. 在PIN21 SD_CLK管脚上串联一个0402封装的电阻连接到Flash CLK管脚上。此电阻的作用主要为：降低驱动电流，减小串扰和外部干扰，调节时序等。串联电阻大小为200ohm
4. RES12K（Pin31）需外接12K对地电阻，该电阻作为芯片bias控制电流的电阻，对精度要求比较高，建议采用12K±1%精度的电阻
5. ESP8266模组
    1. Layout：
        1. 第一层Top层主要用于走信号线和摆件
        2. 第二层为GND层，不走信号线，保证一个完整的GND平面
        3. 第三层为POWER层，尽量走电源线
        4. 第四层为Bottom层，建议Bottom层不摆件，只走信号线
    2. 3.3V电源线线宽必须＞15mil，走线尽量走第三层（POWER层），到达芯片管脚处时打过孔到达TOP层连接芯片管脚。在过孔处理上，VIA的直径需要大于电源走线的宽度，而且drill应始终，略大于VIA的半径即可
    3. 晶振位置尽量靠近芯片的XTAL Pins，走线不要太长，同时晶振走线必须用地包起来良好屏蔽；晶振的输入输出走线不能打孔走线，即不能跨层。金正的输入输出走线不能交叉，跨层较差也不行。晶振的输入输出的bypass电容要靠近芯片左右侧摆放，尽量不要放在走线上；晶振下方4层都不能走高频数字信号，最佳情况是晶振下方不走任何信号线，晶振TOP面的铺铜区域越大越好。晶振为敏感器件，晶振周围不能有磁感应器件，比如大电感。
    4. RF走线必须控制特性阻抗为50Ω，保证第二层完整地平面，周围地孔屏蔽，走线长度尽量短。RF走线尽量保持在10mil以上；RF走线需预留一个π型匹配网络，且π性匹配电路靠近芯片RF Pin脚摆放。芯片到天线的RF走线不能有过孔，即不能跨层走线。RF走线不能走直角或者45°角，如果有需要则使用圆弧走线。RF走线附近不能有高频信号线。RF上的天线必须远离所有传输高频信号的器件，比如<strong>晶振</strong>，DDR，一些高频时钟</p>

<h2>编译</h2>

<p><img src="http://i.imgur.com/ORglsN7.png" alt="编译参数" />
1. esp_iot_sdk_v0.9.5及之后版本的软件简化了编译脚本，编译指令：./gen_misc.sh，根据提示按要求输入编译参数
    1. boot_v1.1与boot_v1.2+：boot_v1.2相对编译时将程序排列的更紧凑，省flash空间；boot_v1.3主要支持增强启动模式可用于产测
    2. 不支持云端升级：flash.bin+iromtext.bin，支持云端升级：boot.bin+user1.bin
    3. 注意编译不同大小的bin时，其烧录地址不同
2. bin目录存放需要下载到Flash的bin文件
    1. at文件夹：Espressif提供的支持AT指令的bin文件
    2. upgrade文件夹，编译生成的支持云端升级的bin文件（user1.bin或user2.bin）
    3. bin文件下根目录，编译生成的不支持云端升级的bin文件，和其他Espressif提供的bin文件
3. 编译生成user1.bin后，先运行make clean清除上次编译生成的临时文件后，再编译生成user2.bin
4. 每个bin编译成功后，会提示该bin的烧录位置,典型烧写位置：
<img src="http://i.imgur.com/pO5yrDq.png" alt="烧写" />
5. 编译esp_iot_sdk_v0.9.4及之前版本软件
    1. 指令：./gen_misc.sh
    2. 支持云端升级（FOTA）的编译步骤如下：
        1. 运行./gen_misc_plus.sh 1，在esp_iot_sdk/bin/upgrade路径下生成user1.bin
        2. 运行make clean，清除之前的编译信息
        3. 运行./gen_misc_plus.sh 2，在esp_iot_sdk/bin/upgrade路径下生成user2.bin
6. 针对编译时STEP1和STEP5的选择不同，对应的flash size和flash map不同。
    1. 系统参数区（system param）始终为flash的最后16KB
    2. 用户参数区（User param）指Espressif提供的示例软件（IOT_Demo或AT）中设定的用户参数区。如果用户自行实现应用程序，则可以将用户参数存放在flash任意空闲区域
    3. 用户数据区（UserData），可能空闲，当程序区域未占满flash空间时，剩余空间可供用户存储数据
7. none boot-不支持云端升级。编译时Step1选择2，编译生成eagle.flash.bin（简称flash.bin）和eagle.irom0text.bin（简称irom0text.bin），不支持云端升级，则STEP5时选择不同flash size对应的布局如下：
    1. 512KB flash
<img src="http://i.imgur.com/I6YK0Jx.png" alt="none-boot-512KB" />
<img src="http://i.imgur.com/n9onmx8.png" alt="none-boot-512KB-ld文件" />
    2. 1024KB flash
<img src="http://i.imgur.com/1tluP12.png" alt="none-boot-1024KB" />
        * \esp_iot_sdk\ld 路径的“eagle.app.v6.ld”文件，其中irom0_0_seg的len即设置irom0text.bin的上限值。对于1024KB flash，此len最大可修改为0xBC000，irom0text.bin 最大支持到752KB
    3. 2048KB flash
<img src="http://i.imgur.com/x7x40sM.png" alt="none-boot-2048KB" />
        * \esp_iot_sdk\ld 路径的“eagle.app.v6.ld”文件，其中irom0_0_seg的len即设置irom0text.bin的上限值。对于2048KB flash，此len最大可修改为0xC0000，irom0text.bin 最大支持到768KB（因为ESP8266目前程序区最大支持1024KB，1024-256=768）
    4. 4096KB flash
<img src="http://i.imgur.com/yRtUCDG.png" alt="none-boot-4096KB" />
        * \esp_iot_sdk\ld 路径的“eagle.app.v6.ld”文件，其中irom0_0_seg的len即设置irom0text.bin的上限值。对于2048KB flash，此len最大可修改为0xC0000，irom0text.bin 最大支持到768KB（因为ESP8266目前程序区最大支持1024KB，1024-256=768）
8. with boot-支持云端升级。编译时STEP1选择1，便一两次，分别生成user1.bin和user2.bin，支持云端升级功能。STEP5时选择不同的flash size对应的布局：
<img src="http://i.imgur.com/rlr2rLh.png" alt="with-boot-512KB" />
<img src="http://i.imgur.com/ciZmOP4.png" alt="with-boot-1024KB" />
<img src="http://i.imgur.com/7y3TiXf.png" alt="with-boot-2048KB" />
<img src="http://i.imgur.com/dyOkeMh.png" alt="with-boot-4096KB" /></p>

<h2>烧录</h2>

<ol>
<li>系统参数区固定为flash的最后四个扇区，每个扇区4KBytes，即flash最后16KB</li>
<li>master_device_key.bin是ESP8266设备享受Espressif云端服务的身份证明，如果不使用Espressif Cloud可以不少路，否则仅烧录一次。烧录地址在IOT_Demo中设置为用户参数区的第三个扇区</li>
<li>blank.bin初始化系统参数，烧录地址为flash的倒数第二个扇区</li>
<li>esp_init_data_default.bin初始化射频相关参数，烧录地址为flash的倒数第四个扇区</li>
<li>不支持云端升级
<img src="http://i.imgur.com/Bf5iLCd.png" alt="不支持云端程序的烧录地址" /></li>
<li>支持云端升级（FOTA）。支持云端升级的软件无需烧录user2.bin，可以通过网络升级下载user2.bin到Flash并重启运行。
<img src="http://i.imgur.com/AKXb5Vn.png" alt="支持云端程序的烧录地址" /></li>
<li>从esp_iot_sdk_v1.4.0版本起，开发者可以通过设置esp_init_data_default.bin（0~128byte）的114byte控制上电时的RF初始化的行为。
<img src="http://i.imgur.com/8qvF0y6.png" alt="改变RF初始化行为" /></li>
</ol>


<h2>SDK二次开发</h2>

<ol>
<li>如果函数添加了ICACHE_FLASH_ATTR,该函数会被放在irom中，CPU仅在调用到他们的时候，将他们读到cache中运行；没有条件ICACHE_FLASH_ATTR宏的函数，将在一开始上电运行时，就加载到iram中运行。由于空间有限，我们无法将所有代码都一次性加载到iram中运行，因此在大部分函数前添加ICACHE_FLASH_ATTR宏。注意，不能在GPIO或UART中断处理函数中调用带有“ICACHE_FLASH_ATTR”宏的函数，否则将引起异常。</li>
<li>wifi_set_ip_info、wifi_set_macaddr仅在user_init中调用才生效</li>
<li>system_timer_reinit建议在user_init中调用，否则调用后，需要重新arm所有timer</li>
<li>wifi_station_set_config如果在user_init中调用，底层会自动连接对应的路由，不需要再调用wifi_station_connect来进行连接，否则需要。</li>
<li>使能us级定时器

<ol>
<li>在user_config.h中#define USE_US_TIMER，并在user_init中调用system_timer_reinit(),此时可以同时使用os_timer_arm_us和os_timer_arm</li>
<li>未定义USE_US_TIMER时，os_timer_arm（）的时间参数范围0~6871947ms，os_timer_arm_us不可用</li>
<li>定义了USE_US_TIMER时，os_timer_arm（）的时间参数范围0~429496ms，os_timer_arm_us的时间参数范围是0~429496729us</li>
</ol>
</li>
<li>blank.bin，有Espressif提供，烧录到0x7E000地址。不是每次都要烧录，仅当sdk升级版本或需要擦除WIFI配置参数时进行烧录</li>
<li>eagle.app.v6.flash.bin,用户编译生成，烧录到0x0000地址</li>
<li>master_device_key.bin，向Espressif服务器申请，烧录到0x3E000地址</li>
<li>eagle.app.v6.irom0text.bin，用户编译生成，烧录到0x40000地址</li>
<li>esp_init_data_default.bin有Espressif提供，烧录到0x7c000地址</li>
<li>system_restore将wifi相关参数复位，即擦出了路由器信息以及恢复了softAP默认名称</li>
<li>固件云端升级成功后，需要调用system_upgrade_reboot，否则不切换</li>
<li>system_timer_reinit需要放在程序最开始，usr_init第一句</li>
</ol>


<h2>重要API介绍</h2>

<ol>
<li>bool wifi_station_scan (struct scan_config *config, scan_done_cb_t cb);功能：获取AP的信息。注意：不能在user_init中调用此接口，该接口必须在系统初始化完成后，并且ESP8266 station接口使能的情况下调用</li>
<li>bool wifi_station_set_config (struct station_config *config)；功能：设置WiFi station接口的配置参数，并保存到flash。注意：如果wifi_station_set_config在user_init中调用，则ESP8266 station接口在系统初始化完成后，自动连接AP（路由），无需再调用wifi_station_connect；否则，需要调用wifi_station_connect连接AP（路由）。station_config.bssid_set一般设置为0，仅当需要检查AP的MAC地址时（用于有重名AP的情况下）设置为1、本设置如果与原设置不同，会更新保存到flash系统参数区</li>
</ol>


<h2>降低功耗的方法</h2>

<ol>
<li>Modem-Sleep：CPU一直工作，在保持wifi连接，如果没有数据传输则关闭WiFi Modem电路来省电</li>
<li>Light-Sleep：CPU暂停工作，保持Wifi连接</li>
<li>Deep-Sleep：WiFi不需要一直保持连接时采用该模式</li>
</ol>


<h2>ADC应用场景</h2>

<ol>
<li>测量VDD3P3管脚3和4的电源电压

<ol>
<li>TOUT必须悬空</li>
<li>RF_init参数：esp_init_data_default.bin（0~127byte）中的低107byte为“vdd33_const”，必须设为0xFF，即255</li>
<li>RF Calibration工作过程：自测VDD3P3管脚3和管脚4上的电源电压，根据测量结果优化RF电路工作状态</li>
<li>用户软件：可使用system_get_vdd33，不可使用system_adc_read</li>
</ol>
</li>
<li>测量TOUT管脚6的输入电压

<ol>
<li>TOUT管脚接外部电路，输入电压范围限定为0-1.0V</li>
<li>RF_init参数：esp_init_data_default.bin（0~127byte）中的第107byte为“vdd33_const”，必须设为真实的VDD3P3管脚3和管脚4上的电源电压，ESP8266的工作电压范围1.8V-3.6V，“vdd33_const”单位0.1V，因此“vdd33_const”有效取值18~36.若电源电压不稳定，会动态变化，“vdd33_const”应输入为电源电压变化的最小值0x10.</li>
<li>RF Calibration工作过程：根据RF_init第107byte“vdd33_const”的值来优化RF电路工作状态，容许误差约为±0.2V</li>
<li>用户软件：不可使用system_get_vdd33；可使用system_adc_read</li>
</ol>
</li>
</ol>


<h2>电源管理</h2>

<ol>
<li>关闭（OFF）：CHIP_PD管脚处于低功耗状态。RTC失效，所有寄存器被清空</li>
<li>深度睡眠（DEEP_SLEEP）：RTC开着，芯片的其他部分都是关着的。RTC内部recovery memory可保存基本的WiFi连接信息</li>
<li>睡眠（SLEEP）：只有RTC在运行。晶体振荡器停止工作。任何部位唤醒（MAC、主机、RTC计时器、外部中断）将唤醒整个芯片</li>
<li>环形（WAKEUP）：在这种状态下，系统从睡眠状态下转为启动（PWR）状态。晶体振荡器和PLL均转化为使能状态</li>
<li>开启状态（CPU ON）：告诉时钟可以运行，并发送至各个被时钟控制寄存器使能的模块。各个模块，包括CPU在内，执行较低电平的时钟门控。系统运作时，可以通过WAITI指令关闭CPU内部时钟</li>
<li>工作状态（RF WORK）：在开启状态的基础上打开WiFi功能</li>
</ol>


<h2>2.4GHz接收器</h2>

<p>2.4GHz接收器把RF信号降频，编程正交基带信号，用2个高分辨率的高速ADC将后者转为数字信号。为了适应不同的信号频道，无线电接收器集成了RF滤波器、自动增益控制AGC、DC偏移补偿电路和基带滤波器</p>

<h2>2.4GHz发射器</h2>

<p>2.4GHz发射器将正交基带信号升频到2.4GHz，使用大功率CMOS功率放大器驱动天线。数字校准的使用进一步改善了功率放大器的线性，从而在802.11b传输中达到+17dBm的平均功率，在802.11n中达到了13dBm的平均功率。为了抵消无线电接收器的瑕疵，还另增了校准措施：
    1. 载波泄露
    2. I/Q相位匹配
    3. 基带非线性</p>

<h2>SDK_IOT_Demo使用方法</h2>

<ol>
<li>ESP8266物联网平台的所有网络功能均在库中实现，对用户不透明。用户应用的初始化功能可以在user_main.c中实现。</li>
<li>void user_init(void)是上层程序的入口函数，给用户提供一个初始化接口，用户可在该函数内增加硬件初始化、网络参数配置、定时器初始化等功能。</li>
<li>SDK中提供了对json包的处理API，用户也可以采用自定义数据包格式，自行对数据进行处理</li>
<li>user_config.h,该头文件中可以选择具体的应用示例，仅支持每次打开一个宏定义，使能一个设备，具体支持：

<ol>
<li>PLUG_DEVICE（只能插座）</li>
<li>LIGHT_DEVICE（灯）</li>
<li>SENSOR_DEVICE（传感器）

<ol>
<li>HUMITURE_SUB_DEVICE（温湿度传感器）</li>
<li>FLAMMABLE_GAS_SUB_DEVICE（可燃气体检测）</li>
</ol>
</li>
</ol>
</li>
<li>需要注意，以下头文件中的宏定义只是用户参数区，用户需要根据编译时的flash map自行调整

<ol>
<li>user_esp_platform.h中的#define ESP_PARAM_START_SEC 0x3D //or 0x7D, or 0xFD</li>
<li>user_light.h中的#define PRIV_PARAM_START_SEC   0x3C //or ox7C, or 0xFC</li>
<li>user_plug.h中的#define PRIV_PARAM_START_SEC 0x3C // or 0x7C, or 0xFC</li>
</ol>
</li>
</ol>


<h2>SDK编程指南</h2>

<ol>
<li>SDK_v1.1.0及之后版本，请在user_main.c增加void user_rf_pre_init(void)，可参考IOT_Demo的user_main.c。用户可在user_rf_pre_init中配置RF初始化，相关RF设置接口为system_phy_set_rfoption，或者在deep-sleep前调用system_deep_sleep_set_option。如果设置为RF不打开，则ESP8266 station及soft-AP均无法使用</li>
<li>非OS SDK中，由于是单线程，任何task都不能长期占用CPU

<ol>
<li>如果一个task占用CPU不退出，将导致看门狗的喂狗函数无法执行，系统重启</li>
<li>如果关闭中断，请勿占用CPU超过10微妙；如果不关闭中断，建议不超过500毫秒</li>
</ol>
</li>
<li>建议使用定时器实现周期性的查询功能，如需在定时器的执行函数中调用os_delay_us或者while、for等函数进行延时或者循环操作，占用时间请勿超过15毫秒</li>
<li>非OS SDK在终端处理函数中，请勿使用任何ICACHE_FLASH_ATTR定义的函数</li>
<li>内存必须4字节对齐进行读写，请勿直接进行指针转换。例如语句：float temp=<em>（（float</em>）data）；可能引起异常，建议使用os_memcpy</li>
<li>如需在中断处理函数中打印，请使用os_printf_plus，且不能加入太多打印信息，尤其是频繁的中断，中断占用时间过长可能引起底层异常</li>
</ol>


<h2>应用程序接口（APIs）</h2>

<ol>
<li><p>软件定时器（/esp_iot_sdk/include/osapi.h）</p>

<ol>
<li>该定时器由软件实现，定时器的函数在任务中被执行，因为任务可能被中断，或者被其他高优先级的任务延迟，因此以下os_timer系列的接口并不能保证定时器精确执行</li>
<li>如果需要精确的定时，请使用硬件中断定时器，硬件定时器的执行函数在中断里被执行</li>
<li>对于同一个timer，os_timer_arm或os_timer_arm_us不能重复调用，必须先os_timer_disarm</li>
<li>os_timer_setfn必须在timer未使能的情况下调用，在os_timer_arm或os_timer_arm_us之前或者os_timer_disarm之后
<img src="http://i.imgur.com/ut3L04J.png" alt="os_timer_arm" />
<img src="http://i.imgur.com/g4r2Hqy.png" alt="os_timer_disarm" />
<img src="http://i.imgur.com/NJSnALl.png" alt="os_timer_setfn" />
<img src="http://i.imgur.com/rjtHFxg.png" alt="system_timer_reinit" />
<img src="http://i.imgur.com/YGqHnPH.png" alt="os_timer_arm_us" /></li>
</ol>
</li>
<li><p>硬件中断定时器（esp_iot_sdk/example/driver_lib/hw_timer.c）</p>

<ol>
<li>如果使用NMI中断源，且为自动填装的定时器，调用hw_timer_arm时参数val必须大于100</li>
<li>如果使用NMI中断源，那么该定时器将为最高优先级，可打断其他ISR</li>
<li>如果使用FRC1中断源，那么该定时器无法打断其他ISR</li>
<li>hw_timer.c的接口不能跟PWM驱动函数同时使用，因为两者共用了同一个硬件定时器
<img src="http://i.imgur.com/4IYnD4u.png" alt="hw_timer_init" />
<img src="http://i.imgur.com/HJSwcP1.png" alt="hw_timer_arm" />
<img src="http://i.imgur.com/AdwUQnK.png" alt="hw_timer_set_func" /></li>
</ol>
</li>
<li><p>系统接口
<img src="http://i.imgur.com/wwOKGue.png" alt="system_get_sdk_version" />
<img src="http://i.imgur.com/FhDEzk9.png" alt="system_restore" />
<img src="http://i.imgur.com/KebuEg2.png" alt="system_restart" />
<img src="http://i.imgur.com/gd7wPOu.png" alt="system_init_done_cb" />
<img src="http://i.imgur.com/1kbe7QR.png" alt="system_get_chip_id" />
<img src="http://i.imgur.com/VYY0bm0.png" alt="system_get_vdd33" />
<img src="http://i.imgur.com/qcos9q2.png" alt="system_adc_read" />
<img src="http://i.imgur.com/BvIJ9j3.png" alt="system_deep_sleep" />
<img src="http://i.imgur.com/7GyREOv.png" alt="system_deep_sleep_set_option" />
<img src="http://i.imgur.com/iN58kRk.png" alt="system_phy_set_rfoption" />
<img src="http://i.imgur.com/q9kfPIR.png" alt="system_phy_set_powerup_option" />
<img src="http://i.imgur.com/xpDL6g5.png" alt="system_phy_set_max_tpw" />
<img src="http://i.imgur.com/WmKLDfl.png" alt="system_phy_set_tpw_via_vdd33" />
<img src="http://i.imgur.com/sBL3Dxe.png" alt="system_set_os_print" />
<img src="http://i.imgur.com/b65IXuv.png" alt="system_print_meminfo" />
<img src="http://i.imgur.com/PR7wSZc.png" alt="system_get_free_heap_size" />
<img src="http://i.imgur.com/VdxyQlN.png" alt="system_os_task" />
<img src="http://i.imgur.com/zdplehL.png" alt="system_os_post" />
<img src="http://i.imgur.com/NyzEjjf.png" alt="system_get_time" />
<img src="http://i.imgur.com/mKDWnWa.png" alt="system_get_rtc_time" />
<img src="http://i.imgur.com/LygTWoX.png" alt="system_rtc_clock_cali_proc" />
<img src="http://i.imgur.com/A72POUy.png" alt="system_rtc_mem_read" />
<img src="http://i.imgur.com/TFeTFTD.png" alt="system_uart_swap" />
<img src="http://i.imgur.com/qvrBExO.png" alt="system_uart_de_swap" />
<img src="http://i.imgur.com/Kgy6Klz.png" alt="system_get_boot_version" />
<img src="http://i.imgur.com/fTlFRgx.png" alt="system_get_userbin_addr" />
<img src="http://i.imgur.com/TsZutcF.png" alt="system_get_boot_mode" />
<img src="http://i.imgur.com/Hz979AN.png" alt="system_restart_enhance" />
<img src="http://i.imgur.com/XSo84Zh.png" alt="system_update_cpu_freq" />
<img src="http://i.imgur.com/vvaN0rO.png" alt="system_get_cpu_freq" />
<img src="http://i.imgur.com/VvcFGtr.png" alt="system_get_flash_size_map" />
<img src="http://i.imgur.com/qS1DJbK.png" alt="system_get_rst_info" />
<img src="http://i.imgur.com/L4Val81.png" alt="system_soft_wdt_stop" />
<img src="http://i.imgur.com/a84yBT6.png" alt="system_soft_wdt_restart" />
<img src="http://i.imgur.com/ae9oSIE.png" alt="system_soft_wdt_feed" />
<img src="http://i.imgur.com/a1phXi6.png" alt="system_show_malloc" />
<img src="http://i.imgur.com/ih4sEt8.png" alt="os_memcpy" />
<img src="http://i.imgur.com/Z3lIfXz.png" alt="os_strlen" />
<img src="http://i.imgur.com/TAVUB3x.png" alt="os_printf" />
<img src="http://i.imgur.com/PJJjvLk.png" alt="os_bzero" />
<img src="http://i.imgur.com/7B4XZ86.png" alt="os_delay_us" />
<img src="http://i.imgur.com/D3sMS0i.png" alt="os_install_putc1" /></p></li>
<li><p>SPI Flash接口
<img src="http://i.imgur.com/XmmnjBi.png" alt="spi_flash_get_id" />
<img src="http://i.imgur.com/2ovYNiF.png" alt="spi_flash_erase_sector" />
<img src="http://i.imgur.com/iIj5npZ.png" alt="spi_flash_write" />
<img src="http://i.imgur.com/boQJjil.png" alt="spi_flash_read" />
<img src="http://i.imgur.com/IcZDndm.png" alt="system_param_save_with_protect" />
<img src="http://i.imgur.com/O97tZqz.png" alt="system_param_load" />
<img src="http://i.imgur.com/SmENox2.png" alt="spi_flash_set_read_func" /></p></li>
<li><p>Wi-Fi接口</p>

<ol>
<li>wifi_station系列接口以及ESP8266 station相关的设置、查询接口，请在ESP8266 station使能的情况下调用</li>
<li>wifi_softap系列接口以及ESP8266 soft-AP相关的设置、查询接口，请在ESP8266 soft-AP使能的情况下调用</li>
<li>后文的“flash系统参数区”位于flash的最后16KB
<img src="http://i.imgur.com/RlFFDxJ.png" alt="wifi_get_opmode" />
<img src="http://i.imgur.com/XaW34cD.png" alt="wifi_get_opmode_default" />
<img src="http://i.imgur.com/QGHqO0N.png" alt="wifi_set_opmode" />
<img src="http://i.imgur.com/Q4lSIWk.png" alt="wifi_set_opmode_current" />
<img src="http://i.imgur.com/wqkMEDJ.png" alt="wifi_station_get_config" />
<img src="http://i.imgur.com/k9VPDzA.png" alt="wifi_station_get_config_default" />
<img src="http://i.imgur.com/61GE3Ib.png" alt="wifi_station_set_config" />
<img src="http://i.imgur.com/qdYW054.png" alt="wifi_station_set_config_current" />
<img src="http://i.imgur.com/03hCjeQ.png" alt="wifi_station_set_cert_key" />
<img src="http://i.imgur.com/QPXjpWE.png" alt="wifi_station_clear_cert_key" />
<img src="http://i.imgur.com/Yh1PrWq.png" alt="wifi_station_connect" />
<img src="http://i.imgur.com/DZl8NZr.png" alt="wifi_station_disconnect" />
<img src="http://i.imgur.com/kApSlV0.png" alt="wifi_station_get_connect_status" />
<img src="http://i.imgur.com/Ts9TcYG.png" alt="wifi_station_scan" />
<img src="http://i.imgur.com/tmSeQd4.png" alt="scan_done_cb_t" />
<img src="http://i.imgur.com/3qUP8bn.png" alt="wifi_station_ap_number_set" />
<img src="http://i.imgur.com/KIVrSGI.png" alt="wifi_station_get_ap_info" />
<img src="http://i.imgur.com/TwvND65.png" alt="wifi_station_ap_change" />
<img src="http://i.imgur.com/5lvsPLw.png" alt="wifi_station_get_current_ap_id" />
<img src="http://i.imgur.com/4Kfn8ab.png" alt="wifi_station_get_auto_connect" />
<img src="http://i.imgur.com/oi0cgPi.png" alt="wifi_station_set_auto_connect" />
<img src="http://i.imgur.com/EWEmI4Z.png" alt="wifi_station_dhcpc_start" />
<img src="http://i.imgur.com/m82n4Zm.png" alt="wifi_station_dhcpc_stop" />
<img src="http://i.imgur.com/zaJSEFV.png" alt="wifi_station_dhcpc_status" />
<img src="http://i.imgur.com/SOkwKH3.png" alt="wifi_station_dhcpc_set_maxtry" />
<img src="http://i.imgur.com/E4qQCrP.png" alt="wifi_station_set_reconnect_policy" />
<img src="http://i.imgur.com/9rt7lqT.png" alt="wifi_station_get_rssi" />
<img src="http://i.imgur.com/ghg2o8V.png" alt="wifi_station_set_hostname" />
<img src="http://i.imgur.com/FAlGs8p.png" alt="wifi_station_get_hostname" />
<img src="http://i.imgur.com/5Pdrcxh.png" alt="wifi_softap_get_config" />
<img src="http://i.imgur.com/CZQUF2Q.png" alt="wifi_softap_get_config_default" />
<img src="http://i.imgur.com/UDNTbY5.png" alt="wifi_softap_set_config" />
<img src="http://i.imgur.com/ZDcmXW0.png" alt="wifi_softap_set_config_current" />
<img src="http://i.imgur.com/P9tlgeM.png" alt="wifi_softap_get_station_num" />
<img src="http://i.imgur.com/yHVy86S.png" alt="wifi_softap_get_station_info" />
<img src="http://i.imgur.com/x5ngKIb.png" alt="wifi_softap_free_station_info" />
<img src="http://i.imgur.com/78K07qB.png" alt="wifi_softap_dhcps_start" />
<img src="http://i.imgur.com/1qfrMUV.png" alt="wifi_softap_dhcps_stop" />
<img src="http://i.imgur.com/HxrV1vR.png" alt="wifi_softap_set_dhcps_lease" />
<img src="http://i.imgur.com/0E9KVU1.png" alt="wifi_softap_get_dhcps_lease" />
<img src="http://i.imgur.com/SRSOODU.png" alt="wifi_softap_set_dhcps_lease_time" />
<img src="http://i.imgur.com/Hx99GO2.png" alt="wifi_soft_dhcps_status" />
<img src="http://i.imgur.com/l97H0jZ.png" alt="wifi_softap_set_dhcps_offer_option" />
<img src="http://i.imgur.com/XcDbqxT.png" alt="wifi_set_phy_mode" />
<img src="http://i.imgur.com/GUa5O5O.png" alt="wifi_get_phy_mode" />
<img src="http://i.imgur.com/xyPVuhn.png" alt="wifi_get_ip_info" />
<img src="http://i.imgur.com/Zr9vWoq.png" alt="wifi_set_ip_info" />
<img src="http://i.imgur.com/Z9LwYlW.png" alt="wifi_set_macaddr" />
<img src="http://i.imgur.com/kTZanO6.png" alt="wifi_get_macaddr" />
<img src="http://i.imgur.com/uDAgvRn.png" alt="wifi_set_sleep_type" />
<img src="http://i.imgur.com/rYM4D3u.png" alt="wifi_get_sleep_type" />
<img src="http://i.imgur.com/lSCPGbX.png" alt="wifi_status_led_install" />
<img src="http://i.imgur.com/ggsdLte.png" alt="wifi_status_led_uninstall" />
<img src="http://i.imgur.com/ZjWAM9E.png" alt="wifi_set_broadcase_if" />
<img src="http://i.imgur.com/j7IEi5C.png" alt="wifi_get_broadcast_if" />
<img src="http://i.imgur.com/SDZx9vy.png" alt="wifi_set_event_handler_cb" />
<img src="http://i.imgur.com/WOrpmmZ.png" alt="wifi_wps_enable" />
<img src="http://i.imgur.com/nIabYMP.png" alt="wifi_wps_disable" />
<img src="http://i.imgur.com/mbemUfV.png" alt="wifi_wps_start" />
<img src="http://i.imgur.com/UjUURzV.png" alt="wifi_set_wps_cb" />
<img src="http://i.imgur.com/Fc9Vy7R.png" alt="wifi_register_send_pkt_freedom_cb" />
<img src="http://i.imgur.com/82xDFc1.png" alt="wifi_send_pkt_freedom" />
<img src="http://i.imgur.com/2KAsPlg.png" alt="wifi_rfid_locp_recv_open" />
<img src="http://i.imgur.com/gIVEqHb.png" alt="wifi_rfid_locp_recv_close" />
<img src="http://i.imgur.com/atfre24.png" alt="wifi_register_rfid_locp_recv_cb" />
<img src="http://i.imgur.com/ySvAcKR.png" alt="wifi_unregister_rfid_locp_recv_cb" /></li>
</ol>
</li>
<li><p>Rate Control 接口
<img src="http://i.imgur.com/hsHHgyu.png" alt="wifi_set_user_fixed_rate" />
<img src="http://i.imgur.com/mbJAoHb.png" alt="wifi_get_user_fixed_rate" />
<img src="http://i.imgur.com/qb8MnZh.png" alt="wifi_set_user_sup_rate" />
<img src="http://i.imgur.com/X0Upq9z.png" alt="wifi_set_user_rate_limit" />
<img src="http://i.imgur.com/asqAVuW.png" alt="wifi_set_user_limit_rate_mask" />
<img src="http://i.imgur.com/iqOBgeg.png" alt="wifi_get_user_limit_rate_mask" /></p></li>
<li><p>强制休眠接口
使用强制休眠功能，必须先设置WiFi工作模式位NULL_MODE，从强制休眠中唤醒ESP8266，或者休眠时间到，进入唤醒回调（wifi_fpm_set_wakeup_cb注册）后，先关闭强制休眠功能，才能再设置WiFi工作模式为station、soft-AP或sta+AP的正常工作模式。
<img src="http://i.imgur.com/LMJT80U.png" alt="wifi_fpm_open" />
<img src="http://i.imgur.com/H0ajlD1.png" alt="wifi_fpm_close" />
<img src="http://i.imgur.com/aFSgMZu.png" alt="wifi_fpm_do_wakeup" />
<img src="http://i.imgur.com/nSg5lrr.png" alt="wifi_fpm_set_wakeup_cb" />
<img src="http://i.imgur.com/XVbopKI.png" alt="wifi_fpm_do_sleep" />
<img src="http://i.imgur.com/RJFmtGe.png" alt="wifi_fpm_set_sleep_type" />
<img src="http://i.imgur.com/hbiNG8u.png" alt="wifi_fpm_get_sleep_type" />
示例
<img src="http://i.imgur.com/mQaZk2x.png" alt="示例代码" /></p></li>
<li><p>ESP-NOW
ESP-NOW软件接口使用时注意：</p>

<ol>
<li>ESP-NOW目前不支持广播包和组播包</li>
<li>ESP-NOW现阶段主要为智能灯项目，建议slave角色对应ESP8266 soft-AP模式或者soft-AP+station共存模式；controller角色对应station模式</li>
<li>当ESP8266处于soft-AP+station共存模式时，若作为slave角色，将从soft-AP接口通信；若作为controller角色，将从station接口通信</li>
<li>ESP-NOW不实现休眠环形功能，因此如果通信对方的ESP8266 station正处于休眠状态，ESP-NOW发包将会失败</li>
<li>ESP8266 station模式下，最多可设置10个加密的ESP-NOW peer，加上不加密的设备，综述不超过20个</li>
<li>ESP8266 soft-AP模式或者soft-AP+station模式下，最多设置6个加密的ESP-NOW peer，加上不加密的设备，总数不超过20个
<img src="http://i.imgur.com/ZqxmdUT.png" alt="esp_now_init" />
<img src="http://i.imgur.com/jnoadVK.png" alt="esp_now_deinit" />
<img src="http://i.imgur.com/hVQrHz9.png" alt="esp_now_register_recv_cb" />
<img src="http://i.imgur.com/KCRctG7.png" alt="esp_now_unregister_recv_cb" />
<img src="http://i.imgur.com/kqTxtwA.png" alt="esp_now_register_send_cb" />
<img src="http://i.imgur.com/6eVV4AH.png" alt="esp_now_unregister_send_cb" />
<img src="http://i.imgur.com/45s7eeI.png" alt="esp_now_send" />
<img src="http://i.imgur.com/500z8ub.png" alt="esp_now_add_peer" />
<img src="http://i.imgur.com/2S8zfbW.png" alt="esp_now_del_peer" />
<img src="http://i.imgur.com/JlYx4aq.png" alt="esp_now_set_self_role" />
<img src="http://i.imgur.com/Guzjbw0.png" alt="esp_now_get_self_role" />
<img src="http://i.imgur.com/osSgTqs.png" alt="esp_now_set_peer_role" />
<img src="http://i.imgur.com/0GiHi1M.png" alt="esp_now_get_peer_role" />
<img src="http://i.imgur.com/hIq3URt.png" alt="esp_now_set_peer_key" />
<img src="http://i.imgur.com/q945HqV.png" alt="esp_now_get_peer_key" />
<img src="http://i.imgur.com/ZL6L5o7.png" alt="esp_now_set_peer_channel" />
<img src="http://i.imgur.com/eOa2xH8.png" alt="esp_now_get_peer_channel" />
<img src="http://i.imgur.com/H3U5eoY.png" alt="esp_now_is_peer_exist" />
<img src="http://i.imgur.com/3bUBgdm.png" alt="esp_now_fetch_peer" />
<img src="http://i.imgur.com/0vxZrA2.png" alt="esp_now_get_cnt_info" />
<img src="http://i.imgur.com/diYBk7z.png" alt="esp_now_set_tok" /></li>
</ol>
</li>
<li><p>云端升级（FOTA）
<img src="http://i.imgur.com/vI1fgnj.png" alt="system_upgrade_userbin_check" />
<img src="http://i.imgur.com/5drhXqB.png" alt="system_upgrade_flag_set" />
<img src="http://i.imgur.com/RJoi4Ax.png" alt="system_upgrade_flag_check" />
<img src="http://i.imgur.com/yAC2blM.png" alt="system_upgrade_start" />
<img src="http://i.imgur.com/1YM4Vqy.png" alt="system_upgrade_reboot" /></p></li>
<li><p>Sniffer接口
<img src="http://i.imgur.com/hp8xnhl.png" alt="wifi_promiscuous_enable" />
<img src="http://i.imgur.com/IG127Hv.png" alt="wifi_promiscuous_set_mac" />
<img src="http://i.imgur.com/a83zveF.png" alt="wifi_set_promiscuous_rx_cb" />
<img src="http://i.imgur.com/Mv6Iz1J.png" alt="wifi_get_channel" />
<img src="http://i.imgur.com/ubo9cpS.png" alt="wifi_set_channel" /></p></li>
<li><p>smart config
开启smart config功能前，先要确保AP已经开启
<img src="http://i.imgur.com/LnOwF3z.png" alt="smartconfig_start" />
<img src="http://i.imgur.com/X8GqB53.png" alt="smartconfig_stop" />
<img src="http://i.imgur.com/KVw3EWh.png" alt="smartconfig_set_type" /></p></li>
<li><p>SNTP
<img src="http://i.imgur.com/JidngYO.png" alt="sntp_setserver" />
<img src="http://i.imgur.com/LoF3zE2.png" alt="sntp_getserver" />
<img src="http://i.imgur.com/Aa5MuMU.png" alt="sntp_setservername" />
<img src="http://i.imgur.com/TsNRL1v.png" alt="sntp_getservername" />
<img src="http://i.imgur.com/xdbOU1A.png" alt="sntp_init" />
<img src="http://i.imgur.com/edA5UWl.png" alt="sntp_stop" />
<img src="http://i.imgur.com/mjPbh2d.png" alt="sntp_get_current_timestamp" />
<img src="http://i.imgur.com/4LFCzuZ.png" alt="sntp_get_real_time" />
<img src="http://i.imgur.com/bhKWquX.png" alt="sntp_set_timezone" />
<img src="http://i.imgur.com/xLD8Muv.png" alt="sntp_get_timezone" />
<img src="http://i.imgur.com/d16kfdb.png" alt="sntp实例" /></p></li>
<li><p>TCP/UDP接口</p>

<ol>
<li>通用接口
<img src="http://i.imgur.com/b7JpuSF.png" alt="espconn_delete" />
<img src="http://i.imgur.com/oYeFFV5.png" alt="espconn_gethostbyname" />
<img src="http://i.imgur.com/byn3M8b.png" alt="espconn_port" />
<img src="http://i.imgur.com/RWTvtPX.png" alt="espconn_regist_sentcb" />
<img src="http://i.imgur.com/kyjCZLo.png" alt="espconn_regist_recvcb" />
<img src="http://i.imgur.com/9TiclzH.png" alt="espconn_sent_callback" />
<img src="http://i.imgur.com/EGx24RQ.png" alt="espconn_recv_callback" />
<img src="http://i.imgur.com/ZMdDW5D.png" alt="espconn_send" /></li>
<li>TCP APIs
<img src="http://i.imgur.com/tvFIHXv.png" alt="espconn_accept" />
<img src="http://i.imgur.com/MQDJ2dm.png" alt="espconn_regist_time" />
<img src="http://i.imgur.com/JHhTCX8.png" alt="espconn_get_connection_info" />
<img src="http://i.imgur.com/qnPMqHW.png" alt="espconn_connect" />
<img src="http://i.imgur.com/AXFBUEl.png" alt="espconn_regist_connectcb" />
<img src="http://i.imgur.com/PapbezX.png" alt="espconn_connect_callback" />
<img src="http://i.imgur.com/qDyblQ6.png" alt="espconn_set_opt" />
<img src="http://i.imgur.com/SGEKnoP.png" alt="espconn_clear_opt" />
<img src="http://i.imgur.com/p0qCJtW.png" alt="espconn_set_keepalive" />
<img src="http://i.imgur.com/zBb9208.png" alt="espconn_get_keepalive" />
<img src="http://i.imgur.com/vG8gNaV.png" alt="espconn_reconnect_callback" />
<img src="http://i.imgur.com/bsyzRMX.png" alt="espconn_regist_reconcb" />
<img src="http://i.imgur.com/D0ksaOd.png" alt="espconn_disconnect" />
<img src="http://i.imgur.com/5HlP8kD.png" alt="espconn_regist_disconcb" />
<img src="http://i.imgur.com/87L2XO8.png" alt="espconn_abort" />
<img src="http://i.imgur.com/g9FFQ2T.png" alt="espconn_regist_write_finish" />
<img src="http://i.imgur.com/4iDHlaW.png" alt="espconn_tcp_get_max_con" />
<img src="http://i.imgur.com/7zcoIEJ.png" alt="espconn_tcp_set_max_con" />
<img src="http://i.imgur.com/tj1A4IN.png" alt="espconn_tcp_get_max_con_allow" />
<img src="http://i.imgur.com/YnFUF40.png" alt="espconn_tcp_set_max_con_allow" />
<img src="http://i.imgur.com/Di7fpNE.png" alt="espconn_recv_hold" />
<img src="http://i.imgur.com/p9Wh4ar.png" alt="espconn_recv_unhold" />
<img src="http://i.imgur.com/x77iFAZ.png" alt="espconn_secure_accept" />
<img src="http://i.imgur.com/yf0nu6u.png" alt="espconn_secure_delete" />
<img src="http://i.imgur.com/aJTmXp1.png" alt="espconn_secure_set_size" />
<img src="http://i.imgur.com/LYSOddi.png" alt="espconn_secure_get_size" />
<img src="http://i.imgur.com/vWyey95.png" alt="espconn_secure_connect" />
<img src="http://i.imgur.com/MjT9kZI.png" alt="espconn_secure_send" />
<img src="http://i.imgur.com/Q8Pc8mB.png" alt="espconn_secure_disconnect" />
<img src="http://i.imgur.com/KbuaGLw.png" alt="espconn_secure_ca_disable" />
<img src="http://i.imgur.com/EjurJ9N.png" alt="espconn_secure_ca_enable" />
<img src="http://i.imgur.com/mLQrUcq.png" alt="espconn_secure_cert_req_enable" />
<img src="http://i.imgur.com/ssMcZnw.png" alt="espconn_secure_cert_req_disable" />
<img src="http://i.imgur.com/NOkGIJa.png" alt="espconn_secure_set_default_certificate" />
<img src="http://i.imgur.com/vSJnk8r.png" alt="espconn_secure_set_default_private_key" /></li>
<li>UDP APIs
<img src="http://i.imgur.com/b4U0hIS.png" alt="espconn_crerat" />
<img src="http://i.imgur.com/qJXFCtQ.png" alt="espconn_sendto" />
<img src="http://i.imgur.com/hnz1IKo.png" alt="espconn_igmp_join" />
<img src="http://i.imgur.com/IaZYyTV.png" alt="espconn_igmp_leave" />
<img src="http://i.imgur.com/3LSmGln.png" alt="espconn_dns_setserver" /></li>
<li>mDNS APIs
<img src="http://i.imgur.com/6ZtF0Cx.png" alt="espconn_mdns_init" />
<img src="http://i.imgur.com/4diP7CK.png" alt="espconn_mdns_close" />
<img src="http://i.imgur.com/JHgRWYC.png" alt="espconn_mdns_server_register" />
<img src="http://i.imgur.com/uWcpQwi.png" alt="espconn_mdns_server_unregister" />
<img src="http://i.imgur.com/WGx1eCJ.png" alt="espconn_mdns_get_servername" />
<img src="http://i.imgur.com/fQ1FfCr.png" alt="espconn_mdns_set_servername" />
<img src="http://i.imgur.com/5fmYZOd.png" alt="espconn_mdns_set_hostname" />
<img src="http://i.imgur.com/JztcNEV.png" alt="espconn_mdns_get_hostname" />
<img src="http://i.imgur.com/JWvn7uS.png" alt="espconn_mdns_disable" />
<img src="http://i.imgur.com/iyADme0.png" alt="espconn_mdns_enable" />
<img src="http://i.imgur.com/MlaoB7u.png" alt="nDNS示例" /></li>
</ol>
</li>
<li><p>MESH接口
<img src="http://i.imgur.com/IBvybY2.png" alt="espconn_mesh_enable" />
<img src="http://i.imgur.com/OAC3v1k.png" alt="espconn_mesh_disable" />
<img src="http://i.imgur.com/4VE4LfU.png" alt="espconn_mesh_get_status" />
<img src="http://i.imgur.com/nL1ApJU.png" alt="espconn_mesh_connect" />
<img src="http://i.imgur.com/HW2jL3C.png" alt="espconn_mesh_disconnect" />
<img src="http://i.imgur.com/bDVScnj.png" alt="espconn_mesh_sent" />
<img src="http://i.imgur.com/SWhdlPv.png" alt="espconn_mesh_set_max_hop" />
<img src="http://i.imgur.com/7XQeKKP.png" alt="espconn_mesh_get_max_hop" />
<img src="http://i.imgur.com/iPK4CLN.png" alt="espconn_mesh_get_node_info" />
<img src="http://i.imgur.com/9lqq5x0.png" alt="espconn_mesh_local_addr" />
<img src="http://i.imgur.com/hxtkS50.png" alt="espconn_mesh_server_init" />
<img src="http://i.imgur.com/kk27vxO.png" alt="espconn_mesh_get_router" />
<img src="http://i.imgur.com/8MO0BNo.png" alt="espconn_mesh_set_router" />
<img src="http://i.imgur.com/OYFa67D.png" alt="espconn_mesh_encrypt_init" />
<img src="http://i.imgur.com/UUmQjpb.png" alt="espconn_mesh_set_ssid_prefix" />
<img src="http://i.imgur.com/wsGGmGK.png" alt="espconn_mesh_group_id_init" />
<img src="http://i.imgur.com/ciwvwV1.png" alt="espconn_mesh_set_dev_type" />
<img src="http://i.imgur.com/crA8NVu.png" alt="espconn_mesh_get_dev_type" />
<img src="http://i.imgur.com/MddfA9d.png" alt="espconn_mesh_print_ver" />
<img src="http://i.imgur.com/oTx1V3H.png" alt="espconn_mesh_scan" /></p></li>
<li><p>AT接口
<img src="http://i.imgur.com/uBBcloa.png" alt="at_response_ok" />
<img src="http://i.imgur.com/Hl7Wxrw.png" alt="at_response_error" />
<img src="http://i.imgur.com/wMckYre.png" alt="at_cmd_array_regist" />
<img src="http://i.imgur.com/4bqK9gn.png" alt="at_get_next_int_dec" />
<img src="http://i.imgur.com/c0oafeU.png" alt="at_data_str_copy" />
<img src="http://i.imgur.com/UdkkoRg.png" alt="at_init" />
<img src="http://i.imgur.com/bRMNu26.png" alt="at_port_print" />
<img src="http://i.imgur.com/Qh4Egbh.png" alt="at_set_custom_info" />
<img src="http://i.imgur.com/ojVLj93.png" alt="at_enter_special_state" />
<img src="http://i.imgur.com/7893WIC.png" alt="at_leave_special_state" />
<img src="http://i.imgur.com/Ntv3tdk.png" alt="at_get_version" />
<img src="http://i.imgur.com/9DJBqHV.png" alt="at_register_uart_rx_intr" />
<img src="http://i.imgur.com/BX32Nhi.png" alt="at_response" />
<img src="http://i.imgur.com/JTr50kC.png" alt="at_register_response_func" /></p></li>
<li><p>JSON接口
<img src="http://i.imgur.com/ON88llK.png" alt="jsonparse_setup" />
<img src="http://i.imgur.com/QiEDpFB.png" alt="jsonparse_next" />
<img src="http://i.imgur.com/SCa6Qd3.png" alt="jsonparse_copy_value" />
<img src="http://i.imgur.com/brv0X37.png" alt="jsonparse_get_value_as_int" />
<img src="http://i.imgur.com/d5RR8Wt.png" alt="jsonparse_get_value_as_long" />
<img src="http://i.imgur.com/WVOl4Ue.png" alt="jsonparse_get_value_len" />
<img src="http://i.imgur.com/HOFZdUg.png" alt="jsonparse_get_value_as_type" />
<img src="http://i.imgur.com/37m1XVv.png" alt="jsonparse_strcmp_value" />
<img src="http://i.imgur.com/ACKNxRZ.png" alt="jsontree_set_up" />
<img src="http://i.imgur.com/MxdDQEF.png" alt="jsontree_reset" />
<img src="http://i.imgur.com/YKXsm2O.png" alt="jsontree_path_name" />
<img src="http://i.imgur.com/tpRuPOI.png" alt="jsontree_write_int" />
<img src="http://i.imgur.com/0dfzHBw.png" alt="jsontree_write_int_array" />
<img src="http://i.imgur.com/JMdzDbN.png" alt="jsontree_write_string" />
<img src="http://i.imgur.com/kTFiCg8.png" alt="jsontree_print_next" />
<img src="http://i.imgur.com/YPZRVqT.png" alt="jsontree_find_next" /></p></li>
<li><p>GPIO接口
<img src="http://i.imgur.com/l4cAWaW.png" alt="PIN相关宏定义" />
<img src="http://i.imgur.com/0dYog5W.png" alt="gpio_output_set" />
<img src="http://i.imgur.com/LMjDjU1.png" alt="GPIO输入输出相关宏" />
<img src="http://i.imgur.com/xh7jhE8.png" alt="GPIO中断" />
<img src="http://i.imgur.com/HBeRCSR.png" alt="gpio_pin_intr_state_set" />
<img src="http://i.imgur.com/myjm32J.png" alt="GPIO中断处理函数" /></p></li>
<li><p>UART接口
默认情况下，UART0作为系统的打印信息输出接口，当配置为双UART时，UART0作为数据收发接口，UART1作为打印信息输出接口
<img src="http://i.imgur.com/SG8nMkv.png" alt="uart_init" />
<img src="http://i.imgur.com/7xpciAa.png" alt="uart0_tx_buffer" />
<img src="http://i.imgur.com/yPCsPRq.png" alt="uart0_rx_intr_handler" /></p></li>
<li><p>I2C Master接口
ESP8266不能作为I2C从设备，但可以作为I2C主设备，对其他I2C从设备进行控制和读写。每个GPIO管脚内部都可以配置为开漏模式，从而可以灵活地将GPIO口用作I2C data或者clock功能。同时芯片内部提供上拉电阻，以节省外部的上拉电阻
<img src="http://i.imgur.com/cFCO4NY.png" alt="i2c_master_gpio_init" />
<img src="http://i.imgur.com/9dEjKkE.png" alt="i2c_master_init" />
<img src="http://i.imgur.com/lj8qJuy.png" alt="i2c_master_start" />
<img src="http://i.imgur.com/dKOHZpG.png" alt="i2c_master_stop" />
<img src="http://i.imgur.com/UTNUycs.png" alt="i2c_master_send_ack" />
<img src="http://i.imgur.com/3UGpatY.png" alt="i2c_master_send_nack" />
<img src="http://i.imgur.com/UU2TSbP.png" alt="i2c_master_checkAck" />
<img src="http://i.imgur.com/gjxuJFt.png" alt="i2c_master_readByte" />
<img src="http://i.imgur.com/xOwdzPq.png" alt="i2c_master_writeByte" /></p></li>
<li><p>PWM接口
PWM驱动接口不能跟hw_timer的接口同时使用，因为二者共用了同一个硬件定时器
<img src="http://i.imgur.com/Xtahx9b.png" alt="pwm_init" />
<img src="http://i.imgur.com/XIbDsa7.png" alt="pwm_start" />
<img src="http://i.imgur.com/iKhLfuh.png" alt="pwm_set_duty" />
<img src="http://i.imgur.com/sJ3mGcB.png" alt="pwm_get_duty" />
<img src="http://i.imgur.com/Ixgd7Kz.png" alt="pwm_set_period" />
<img src="http://i.imgur.com/7PB2YeI.png" alt="pwm_get_period" />
<img src="http://i.imgur.com/jxVThkr.png" alt="pwm_get_version" /></p></li>
</ol>


<h2>参数结构和宏定义</h2>

<ol>
<li>定时器
<img src="http://i.imgur.com/SWbnx7J.png" alt="ETSTimer" /></li>
<li>WiFi参数
<img src="http://i.imgur.com/dA8A124.png" alt="station参数" />
<img src="http://i.imgur.com/QNMFXtn.png" alt="soft-AP参数" />
<img src="http://i.imgur.com/E7jjlFd.png" alt="scan参数" />
<img src="http://i.imgur.com/Uw9zTI9.png" alt="WiFi event结构体" />
<img src="http://i.imgur.com/ZP29Rew.png" alt="smart config结构体" /></li>
<li>json相关结构体
<img src="http://i.imgur.com/wnY8lSb.png" alt="json结构体" />
<img src="http://i.imgur.com/amJ4Pbv.png" alt="json宏定义" /></li>
<li>espconn参数
<img src="http://i.imgur.com/YCKqSWm.png" alt="回调函数" />
<img src="http://i.imgur.com/glbsJWw.png" alt="espconn" /></li>
<li>中断相关宏定义
<img src="http://i.imgur.com/i8UAMcA.png" alt="中断宏定义" /></li>
</ol>


<h2>ESPCONN编程</h2>

<ol>
<li>TCP client模式，步骤：

<ol>
<li>依据工作协议初始化espconn参数</li>
<li>注册连接成功的回调函数和连接失败重连的回调函数</li>
<li>调用espconn_connect建立与TCP Secver的连接</li>
<li>TCP连接建立成功后，在连接成功的回调函数(espconn_connect_callback)中，注册接收数据的回调函数，发送数据成功的回调函数和断开连接的回调函数</li>
<li>在接收数据的回调函数，或者发送数据成功的回调函数中，执行断开连接操作时，建议适当延时一定时间，确保底层函数执行结束</li>
</ol>
</li>
<li>TCP Server模式，步骤

<ol>
<li>依据工作协议初始化espconn参数</li>
<li>注册连接成功的回调函数和连接失败重连的回调函数</li>
<li>调用espconn_accept侦听TCP连接</li>
<li>TCP连接建立成功后，在连接成功的回调函数中，注册接收数据的回调函数，发送数据成功的回调函数和断开连接的回调函数</li>
</ol>
</li>
<li>espconn callback
<img src="http://i.imgur.com/X0xci3I.png" alt="espconn callback" />

<ul>
<li>注意：回调函数中传入的指针arg，对应网络连接的结构体espconn指针。该指针为SDK内部维护的指针，不同回调传入的指针地址可能不一样，请勿依此判断网络连接。可根据espconn结构体中的remote_ip，remote_port判断多连接中的不同网络传输</li>
<li>如果espconn_connect（或者espconn_secure_connect）失败，返回非零值，连接未建立，不会进入任何espconn callback</li>
<li>请勿在espconn热河回调中调用espconn_disconnect（或者espconn_secure_disconnect）断开连接。如果有需要，可以在espconn回调中使用触发任务的方式（system_os_task和system_os_post）调用espconn_disconnect（或者espconn_secure_disconnect）断开连接</li>
</ul>
</li>
</ol>


<h2>RTC使用实例</h2>

<p>以下测试示例，可以验证RTC时间和系统时间，在system_restart时的变化，以及读写RTC memory
<img src="http://i.imgur.com/SqM8KtO.png" alt="RTC示例" /></p>

<h2>Sniffer结构体说明</h2>

<ol>
<li>ESP8266可以进入混杂模式，接收空气中的IEEE802.11包，可支持如下HT20的包：

<ol>
<li>802.11b</li>
<li>802.11g</li>
<li>802.11n（MCS0到MCS7）</li>
<li>AMPDU</li>
</ol>
</li>
<li>尽管有些类型的IEEE802.11包是ESP8266不能完全接收的，但ESP8266可以获得它们的包长。因此，sniffer模式下，ESP8266或者可以接收完整的包，或者可以获得包的长度</li>
<li>ESP8266可完全接收的包，包含：

<ol>
<li>一定长度的MAC头信息（包含了收发双发的MAC地址和加密方式）</li>
<li>整个包的长度</li>
</ol>
</li>
<li>ESP8266不可完全接收的包，它包含：

<ol>
<li>整个包的长度</li>
</ol>
</li>
<li>结构体RxControl和sniffer_buf分别用于via哦是这两种类型的包。其中结构体sniffer_buf包含结构体RxControl。
<img src="http://i.imgur.com/WiqsD0p.png" alt="sniffer结构体" />
回调函数wifi_promiscuous_rx含两个参数（buf和len）。len表示buf的长度，分为三种情况：len=128，len为10的整数倍，len=12；

<ol>
<li>LEN==128的情况

<ul>
<li>buf的数据是结构体sniffer_buf2，该结构体对应的数据包是管理包，含有112字节的数据</li>
<li>sniffer_buf2.cnt为1</li>
<li>sniffer_buf2.len为管理包的长度</li>
</ul>
</li>
<li>LEN为10的整数倍的情况

<ul>
<li>buf的数据是结构体sniffer_buf，该结构体是比较可信的，它对应的数据包是通过CRC校验正确的</li>
<li>sniffer_buf.cnt表示了该buf包含的包的个数，len的值由sniffer_buf.cnt决定</li>
<li>sniffer_buf.cnt==0表示此buf无效；否则len=5=+cnt*10</li>
<li>sniffer_buf.buf表示IEEE802.11包的前36字节。从成员sniffer_buf.lenseq[0]开始，每一个lenseq结构体表示一个包长信息</li>
<li>当sniffer_buf.cnt>1，由于该包是一个AMPDU，认为每个MPDU的包头基本是相同的，因此没有给出所有的MPDU包头，只给出了每个包的长度（从MAC包头开始到FCS）</li>
<li>该结构体中较为游泳的信息有：包长、包的发送者和接收者、包头长度</li>
</ul>
</li>
<li>LEN==12的情况

<ul>
<li>buf的数据是一个结构体RxControl，该结构体是不太可信的，它无法表示包所属的发送和接收者，也无法判断该报的包头长度</li>
<li>对于AMPDU包，也无法判断子包的个数和每个子包的长度</li>
<li>该结构体中较为有用的信息有：包长，rssi和FEC_CODING</li>
<li>RSSI和FEC_CODING可以用于评估是否是同一个设备所发</li>
</ul>
</li>
</ol>
</li>
</ol>


<h2>ESP8266信道的定义</h2>

<ol>
<li>虽然ESP8266支持soft-AP和station共存模式，但是ESP8266实际只有一个硬件通道。因此在soft-AP+station模式时，ESP8266 soft-AP会动态调整信道值与ESP8266 station一致
<img src="http://i.imgur.com/0l6M5tU.png" alt="ESP8266 soft-AP+station模式注意事项" /></li>
</ol>


<h2>AT 官方指令</h2>

<ol>
<li>如果开发板Flash为4Mbit，则无法使用固件升级功能（对应指令AT+CIUPDATE），只能采用non-boot的烧录方式。固件升级功能要求Flash容量为8Mbit或以上，采用boot mode的烧录方式</li>
<li>AT底层已经占用system_os_task优先级0和1，因此用户如基于AT开发，仅支持建立一个优先级为2的任务</li>
<li>波特率为115200</li>
<li>AT指令必须大写，以回车换行符结尾“\r\n”</li>
<li>AT Demo仅在ESP8266作为TCP client单连接或者UDP传输时，支持透传</li>
<li>目前AT Demo ESP8266仅支持一个TCP服务器，且必须使能多连接，即可连接多个TCP client
<img src="http://i.imgur.com/ZHMdvIV.png" alt="基础AT指令" />
<img src="http://i.imgur.com/KWLgQRV.png" alt="WiFi功能AT指令" />
<img src="http://i.imgur.com/qftT477.png" alt="TCP/IP相关AT指令" />
<img src="http://i.imgur.com/iY82gSq.png" alt="保存设置到Flash的AT指令" /></li>
</ol>


<h2>GPIO</h2>

<p><img src="http://i.imgur.com/DtNrGiF.png" alt="ESP8266-GPIO" /></p>

<ol>
<li>ESP8266共有16个通用IO，管脚的位置和管脚的名称分别为：</li>
<li>在四线（QUAD）模式flash下，有6个IO用于flash通讯；在两线（DUAL）模式flash下，有四个IO用于与flash通讯</li>
<li>与其他IO口不同，GPIO16不属于通用GPIO模块，它属于RTC模块，可以用来在深度睡眠时候唤醒整个芯片，可以配置为输入或者输出模式，但是无法触发IO中断

<ol>
<li>将GPIO16配置为输出模式：gpio16_output_conf(void)</li>
<li>从GPIO16输出高/低电平，需要先配置为输出模式：gpio16_output_set(uint8 value)</li>
<li>将GPIO16配置为输入模式:gpio16_input_conf(void)</li>
<li>读取GPIO16的输入电平状态，需要先配置为输入模式:gpio16_input_get(void)</li>
</ol>
</li>
</ol>


<h2>Free-RTOS</h2>

<ol>
<li>编程注意事项：

<ol>
<li>建议使用定时器实现长时间的查询功能，可将定时器设置为循环调用</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[电源设计]]></title>
    <link href="http://suda-morris.github.io/blog/2015/12/03/power-design/"/>
    <updated>2015-12-03T12:21:30+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/12/03/power-design</id>
    <content type="html"><![CDATA[<h2>开关电源芯片</h2>

<ol>
<li>MP1584</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verilog基础知识]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/22/verilog/"/>
    <updated>2015-11-22T19:53:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/22/verilog</id>
    <content type="html"><![CDATA[<h2>Verilog的模块</h2>

<ol>
<li>模块是Verilog语言的基本单元，其基本语法如下：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Verilog'><span class='line'><span class="k">module</span> <span class="o">&lt;</span><span class="err">模块名</span><span class="o">&gt;</span><span class="err">（</span><span class="o">&lt;</span><span class="err">端口列表</span><span class="o">&gt;</span><span class="err">）</span>
</span><span class='line'>  <span class="err">端口说明（</span><span class="k">input</span><span class="err">，</span><span class="k">output</span><span class="err">，</span><span class="k">inout</span><span class="err">）</span>
</span><span class='line'>  <span class="err">参数定义</span>
</span><span class='line'>  <span class="err">数据类型定义：指定模块内用到的数据对象为寄存器型、存储器型还是连续型</span>
</span><span class='line'>  <span class="err">连续赋值语句（</span><span class="k">assign</span><span class="err">）</span>
</span><span class='line'>  <span class="err">过程块（</span><span class="k">initial</span><span class="err">和</span><span class="k">always</span><span class="err">）</span>
</span><span class='line'>      <span class="o">-</span><span class="err">行为描述语句</span>
</span><span class='line'>  <span class="err">底层模块实例</span>
</span><span class='line'>  <span class="err">任务和函数</span>
</span><span class='line'>  <span class="err">延时说明块：对模块各个输入和输出端口之间的路径延时进行说明</span>
</span><span class='line'><span class="k">endmodule</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>模块的描述方式

<ol>
<li>模块的描述方式又称建模方式。verilog既是一门行为化又是一门结构化的HDL语言，根据设计的需要，每个模块的内部可以分为四种抽象级别来进行描述。模块在外部环境中的表现都是同等的，而与其内部具体描述的抽象级别无关。因此模块的内部具体描述相对于外部环境来说是隐藏的，该表一个模块内部描述的抽象级别，可以不用对其外部环境做任何的改动。</li>
<li>模块的4类抽象级别的描述

<ol>
<li>行为级建模：这是Verilog最高抽象级别的描述方式。一个模块可以按照要求的设计算法来实现，而不用关心具体硬件实现的细节。行为描述通过行为语句来实现，行为功能可使用下述过程语句结构描述

<ul>
<li>initial语句，此语句只执行一次</li>
<li>always语句，此语句循环执行</li>
</ul>
</li>
<li>数据流描述方式（数据流级建模）

<ol>
<li>数据流描述方式也称RTL（寄存器传输级）描述方式。在这种描述方式下，设计者需要知道数据是如何在寄存器之间传输的以及将被如何处理。数据流描述防护四类似于布尔方程，它能够比较直观地表达底层逻辑行为。在Verilog中数据流描述方式主要用来描述组合逻辑，具体由连续赋值语句“assign”来实现。</li>
</ol>
</li>
<li>门级描述方式

<ol>
<li>在这种描述方式下，模块是按照逻辑门和他们之间的互连线来实现的，在这种抽象级别下的设计与按照门级逻辑图来描述一个设计类似。门级描述就是指调用Verilog内建的基本门级元件来对硬件电路进行结构设计。这些基本的门级元件是一类特殊的模块，共有14种，分成4类，他们分别由Verilog语言自身提供。</li>
</ol>
</li>
<li>开关级描述方式

<ol>
<li>开关级描述方式也称晶体管级描述方式，是Verilog最低级别的描述方式。在这种描述方式下，模块是按照开关级元件和存储节点以及它们之间的互连来实现的。具体来说是指调用Verilog内建的基本开关级原价来对硬件电路进行结构设计。与门级元件类似，这些基本的开关级元件也是一类特殊的模块，共有12种，由Verilog语言自身提供</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>模块调用</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Verilog'><span class='line'><span class="o">&lt;</span><span class="err">模块名</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="err">参数值列表</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="err">实例名</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="err">端口连接表</span><span class="o">&gt;</span><span class="p">)</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>


<h2>语法基础</h2>

<ol>
<li>注释：<code>/*多行注释*/</code>和<code>//单行注释</code></li>
<li>数值可取下面的4类值：

<ol>
<li>0：逻辑0或者假状态</li>
<li>1：逻辑1或者真状态</li>
<li>x(X)：未知状态</li>
<li>z(Z)：高阻状态</li>
</ol>
</li>
<li>整数型常量

<ol>
<li>简单的十进制格式。由0~9的数字串组成的十进制数，可以在数值前面加上符号“+”或“-”来表示数的正负</li>
<li>指定位宽的基数格式，由三部分组成：<size>&lt;&lsquo;base_format><number>

<ol>
<li>size指定数的二进制位宽，是一个非零的无符号十进制常量，size若省略默认32位</li>
<li>&lsquo;base_format:单引号'是指定位宽格式表示法的固有字符，不能省略。base_format指定数的基数格式，用一个字母表示，对大小写不敏感。在base_format之前，单引号之后可以加上字母s(S)表示该数为有符号数。合法的技术格式字符串字母有d(D)-十进制；h(H)-十六进制；o(O)-八进制；b(B)-二进制。number是一个无符号的数，由相应基数格式的数字串组成。十六进制数字a~f对大小写也是不敏感的。可以在size之前加上“+”或“-”表示数的正或负，但是不能再base_format和number之间加“+”或“-”，因为这违背了Verilog的语法规则</li>
</ol>
</li>
<li>下划线符号“_”除了不能放在数值的首位外，可以放在整数型和实数型内任何地方。它们对数值没有任何影响，在编译时会被忽略，只是为了将长的数值分段，提高可读性</li>
</ol>
</li>
<li>实数型常量

<ol>
<li>实数型常量可以通过对小数的四舍五入，转换为最靠近的整数型常量，而不是直接将小数舍弃，从而得到整数。当一个实数常量被赋给一个整数变量时，一种隐式的转换就发生了。例如实数-1.5转换为整数-2，实数35.2转换为整数得到35</li>
</ol>
</li>
<li>字符串：用双引号“”括起来的字符序列，必须包含在一行内，不能分成多行书写

<ol>
<li>字符串变量是寄存器类型的变量，该字符串变量的位数要大于等于字符串的最大长度</li>
<li>存储一个12字符的字符串“Hello world！”需要一个8*12=96位的寄存器变量。

<ul>
<li><code>reg [8*12:1] stringvar;</code></li>
<li><code>stringvar = "Hello world";</code></li>
</ul>
</li>
<li>如果声明的字符串变量位数大于字符串实际长度，则在赋值操作后，字符串变量的左端（即高位）补0.如果声明的字符串变量位数小于字符串实际长度，那么字符串的左端被截取，这些高位字符就丢失了</li>
</ol>
</li>
<li>标识符分为简单标识符、转义标识符、生成标识符、关键字

<ol>
<li>简单标识符是由字母、数字、美元符号、下划线构成的任意序列。简单标识符的第一个符号不能是数字或者美元符号$</li>
<li>关键字都用小写字母定义</li>
</ol>
</li>
<li>系统任务和函数

<ol>
<li>为了便于设计者对仿真过程进行控制，以及对仿真结果进行分析，Verilog提供了大量的系统功能调用，大致分为：

<ol>
<li>任务型的功能调用，称为系统任务</li>
<li>函数型的功能调用，称为系统函数</li>
</ol>
</li>
<li>Verilog的系统任务和系统函数是以字符$开头的标识符，他们的主要区别是

<ol>
<li>系统任务可以没有返回值或者有多个返回值，而系统函数只有一个返回值</li>
<li>系统任务可以带有延迟，而系统函数不允许延迟，在0时刻执行</li>
</ol>
</li>
<li>用户可以根据需要基于Verilog仿真系统提供的PLI编程接口，编制特殊的系统任务和系统函数，根据系统任务和系统函数实现的功能不同，可将其分成以下几类：

<ol>
<li>标准输出任务

<ol>
<li>$display:将特定信息输出到标准输出设备时，具有自动换行的功能</li>
<li>$write：不带有行结束符</li>
<li>$displayb和writeb（输出二进制）</li>
<li>$displayo和writeo（输出八进制）</li>
<li>$displayh和writeh（输出十六进制）</li>
</ol>
</li>
<li>文件管理任务

<ol>
<li><file_handle>=$fopen(&ldquo;<file_name>&rdquo;);如果文件名<file_name>正确，则返回一个32位的句柄描述符<file_handle>，且其中只有一位为高电平</li>
<li>Verilog中用来将信息输出到文件的系统任务有$fdisplay,$fwrite,$fmonitor:<task_name>(<file_handles>,<format_specifiers>);其中<task_name>是上述三种系统任务中的一种。<file_handles>是文件句柄描述符，与打开文件所不同的是，可以对句柄进行多位设置。<format_specifiers>用来指定输出格式</li>
<li>$fclose(<file_handle>);关闭文件</li>
<li>Verilog中有两个系统任务$readmemb和$readmemh,它们能够把一个数据文件中的数据内容读入到一个指定的存储器中。这两个系统任务的区别在于，前者要求以二进制数据格式存放数据文件，而后者要求以十六进制数据格式存放数据文件。他们具有相同的语法格式：<task_name>(<file_name>,<register_array>,<start>,<end>);其中<task_name>用来指定系统任务，可取上述任务中的一个。<file_name>是读出数据的文件名。<register_array>为要读入数据的存储器。<start>和<end>分别为存储器的起始地址和结束地址。</li>
</ol>
</li>
<li>仿真控制任务

<ol>
<li>Verilog中有三种仿真监控任务：$monitor,$monitoron,$monitoroff</li>
<li>$monitor(<format_specifiers>,signal,signal,&hellip;);该任务可用来连续监控指定的信号参数，如果发现其中的任一信号发生变化，则系统按照调用$monitor时规定的格式，在时间歩结束时显示整个信号表</li>
<li>$finish和$stop这两个系统任务可以用来结束仿真。$finish用来终止仿真器的运行，结束仿真过程返回到操作系统。$stop暂时挂起仿真器，进入Verilog界面，可以通过输入相应命令使仿真继续进行</li>
</ol>
</li>
<li>时间函数

<ol>
<li>$timeformat(<unit>,<precision>,<suffix>,<min_field_width>)其中<unit>用于指定时间单位，取值范围是0~-15。<precision>指定所要显示时间信息的精度，<suffix>是诸如“ms”，“ns”之类的字符，<min_field_width>说明时间信息的最小字符数</li>
<li><code>$timeformat(-9,2,"ns",10)</code></li>
<li>时间显示函数

<ol>
<li>$time，返回64位整数，指定当前的仿真时间</li>
<li>$stime，返回32位的仿真时间</li>
<li>$realtime，以实数形式范湖当前的仿真时间</li>
</ol>
</li>
</ol>
</li>
<li>其他

<ol>
<li>随机函数

<ol>
<li>$random%<number>,其中<number>用来指定所产生的随机数的范围，即-<number>+1到<number>-1</li>
</ol>
</li>
<li>转换函数

<ol>
<li>有时需要将整数转换成实数，或将实数转换成整数，或者用向量形式来表示实数等。Verilog提供了许多转换函数可以方便实现上述功能。</li>
<li>$rtio：通过截断小数部分，将实数转换成整数</li>
<li>$itor:将整数转换成实数</li>
<li>$realtobits:将实数转换成64位的实数向量表示</li>
<li>$bitstoreal:将位模式转换为实数</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TinyHttpd]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/22/tinyhttpd/"/>
    <updated>2015-11-22T15:56:10+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/22/tinyhttpd</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<ol>
<li>tinyhttpd是一个不到500行的超轻量型Http Server</li>
</ol>


<h2>函数介绍</h2>

<ol>
<li>void accept_request(int);

<ul>
<li>处理从套接字上监听到的一个HTTP请求，在这里可以很大一部分体现服务器处理请求流程</li>
</ul>
</li>
<li>void bad_request(int);

<ul>
<li>返回给客户端这是一个错误请求，HTTP状态码400 BAD REQUEST</li>
</ul>
</li>
<li>void cat(int, FILE *);

<ul>
<li>读取服务器上某个文件写到socket套接字</li>
</ul>
</li>
<li>void cannot_execute(int);

<ul>
<li>主要处理发生在执行cgi程序时出现的错误</li>
</ul>
</li>
<li>void error_die(const char *);

<ul>
<li>将错误信息写到perror并退出</li>
</ul>
</li>
<li>void execute_cgi(int, const char <em>, const char </em>, const char *);

<ul>
<li>运行cgi程序的处理</li>
</ul>
</li>
<li>int get_line(int, char *, int);

<ul>
<li>读取套接字的一行，把回车换行等情况都统一为换行结束符</li>
</ul>
</li>
<li>void headers(int, const char *);

<ul>
<li>把HTTP响应的头部写到套接字</li>
</ul>
</li>
<li>void not_found(int);

<ul>
<li>主要处理找不到请求的文件时的情况</li>
</ul>
</li>
<li>void serve_file(int, const char *);

<ul>
<li>调用cat把服务器文件返回给浏览器</li>
</ul>
</li>
<li>int startup(u_short *);

<ul>
<li>初始化httpd服务，包括建立套接字，绑定端口，进行监听等</li>
</ul>
</li>
<li>void unimplemented(int);

<ul>
<li>返回给浏览器表明收到的HTTP请求所用的method不被支持</li>
</ul>
</li>
</ol>


<h2>源码详解</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cm">/* J. David&#39;s webserver */</span>
</span><span class='line'><span class="cm">/* This is a simple webserver. </span>
</span><span class='line'><span class="cm"> * Created November 1999 by J. David Blackstone. </span>
</span><span class='line'><span class="cm"> * CSE 4344 (Network concepts), Prof. Zeigler </span>
</span><span class='line'><span class="cm"> * University of Texas at Arlington </span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="cm">/* This program compiles for Sparc Solaris 2.6. </span>
</span><span class='line'><span class="cm"> * To compile for Linux: </span>
</span><span class='line'><span class="cm"> *  1) Comment out the #include &lt;pthread.h&gt; line. </span>
</span><span class='line'><span class="cm"> *  2) Comment out the line that defines the variable newthread. </span>
</span><span class='line'><span class="cm"> *  3) Comment out the two lines that run pthread_create(). </span>
</span><span class='line'><span class="cm"> *  4) Uncomment the line that runs accept_request(). </span>
</span><span class='line'><span class="cm"> *  5) Remove -lsocket from the Makefile. </span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;sys/socket.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;netinet/in.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;arpa/inet.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;ctype.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;strings.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;sys/stat.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;pthread.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;sys/wait.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;  </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define ISspace(x) isspace((int)(x))  </span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define SERVER_STRING &quot;Server: jdbhttpd/0.1.0\r\n&quot;  </span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">accept_request</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">bad_request</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">cat</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">cannot_execute</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">error_die</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">execute_cgi</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">get_line</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">headers</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">not_found</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">serve_file</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">startup</span><span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">unimplemented</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* A request has caused a call to accept() on the server port to </span>
</span><span class='line'><span class="cm"> * return.  Process the request appropriately. </span>
</span><span class='line'><span class="cm"> * Parameters: the socket connected to the client */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">accept_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">numchars</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">method</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">url</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">cgi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="cm">/* becomes true if server decides this is a CGI program */</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">query_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*得到请求的第一行*/</span>
</span><span class='line'>    <span class="n">numchars</span> <span class="o">=</span> <span class="n">get_line</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/*把客户端的请求方法存到 method 数组*/</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ISspace</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>        <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">method</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*如果既不是 GET 又不是 POST 则无法处理 */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;GET&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;POST&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">unimplemented</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* POST 的时候开启 cgi */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;POST&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">cgi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*读取 url 地址*/</span>
</span><span class='line'>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">ISspace</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)))</span>
</span><span class='line'>        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ISspace</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*存下 url */</span>
</span><span class='line'>        <span class="n">url</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>        <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">url</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*处理 GET 方法*/</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;GET&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* 待处理请求为 url */</span>
</span><span class='line'>        <span class="n">query_string</span> <span class="o">=</span> <span class="n">url</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">query_string</span> <span class="o">!=</span> <span class="sc">&#39;?&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">query_string</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span>
</span><span class='line'>            <span class="n">query_string</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="cm">/* GET 方法特点，? 后面为参数*/</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">query_string</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="cm">/*开启 cgi */</span>
</span><span class='line'>            <span class="n">cgi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="o">*</span><span class="n">query_string</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>            <span class="n">query_string</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*格式化 url 到 path 数组，html 文件都在 htdocs 中*/</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;htdocs%s&quot;</span><span class="p">,</span> <span class="n">url</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/*默认情况为 index.html */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">strcat</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;index.html&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/*根据路径找到对应文件 */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*把所有 headers 的信息都丢弃*/</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">((</span><span class="n">numchars</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>  <span class="cm">/* read &amp; discard headers */</span>
</span><span class='line'>            <span class="n">numchars</span> <span class="o">=</span> <span class="n">get_line</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span><span class='line'>        <span class="cm">/*回应客户端找不到*/</span>
</span><span class='line'>        <span class="n">not_found</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*如果是个目录，则默认使用该目录下 index.html 文件*/</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">((</span><span class="n">st</span><span class="p">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="o">==</span> <span class="n">S_IFDIR</span><span class="p">)</span>
</span><span class='line'>            <span class="n">strcat</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;/index.html&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">((</span><span class="n">st</span><span class="p">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="n">S_IXUSR</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="n">S_IXGRP</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="n">S_IXOTH</span><span class="p">)</span>    <span class="p">)</span>
</span><span class='line'>          <span class="n">cgi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="cm">/*不是 cgi,直接把服务器文件返回，否则执行 cgi */</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgi</span><span class="p">)</span>
</span><span class='line'>          <span class="n">serve_file</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>          <span class="n">execute_cgi</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">query_string</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*断开与客户端的连接（HTTP 特点：无连接）*/</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Inform the client that a request it has made has a problem. </span>
</span><span class='line'><span class="cm"> * Parameters: client socket */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">bad_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*回应客户端错误的 HTTP 请求 */</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;HTTP/1.0 400 BAD REQUEST</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Content-type: text/html</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;P&gt;Your browser sent a bad request, &quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;such as a POST without a Content-Length.</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Put the entire contents of a file out on a socket.  This function </span>
</span><span class='line'><span class="cm"> * is named after the UNIX &quot;cat&quot; command, because it might have been </span>
</span><span class='line'><span class="cm"> * easier just to do something like pipe, fork, and exec(&quot;cat&quot;). </span>
</span><span class='line'><span class="cm"> * Parameters: the client socket descriptor </span>
</span><span class='line'><span class="cm"> *             FILE pointer for the file to cat */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">cat</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">resource</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*读取文件中的所有数据写到 socket */</span>
</span><span class='line'>    <span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">resource</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">resource</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">resource</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Inform the client that a CGI script could not be executed. </span>
</span><span class='line'><span class="cm"> * Parameter: the client socket descriptor. */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">cannot_execute</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 回应客户端 cgi 无法执行*/</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;HTTP/1.0 500 Internal Server Error</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Content-type: text/html</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;P&gt;Error prohibited CGI execution.</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Print out an error message with perror() (for system errors; based </span>
</span><span class='line'><span class="cm"> * on value of errno, which indicates system call errors) and exit the </span>
</span><span class='line'><span class="cm"> * program indicating an error. */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">error_die</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="cm">/*出错信息处理 */</span>
</span><span class='line'>    <span class="n">perror</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Execute a CGI script.  Will need to set environment variables as </span>
</span><span class='line'><span class="cm"> * appropriate. </span>
</span><span class='line'><span class="cm"> * Parameters: client socket descriptor </span>
</span><span class='line'><span class="cm"> *             path to the CGI script */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">execute_cgi</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">method</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">query_string</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">cgi_output</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">cgi_input</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">numchars</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">content_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;GET&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="cm">/*把所有的 HTTP header 读取并丢弃*/</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">((</span><span class="n">numchars</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>  <span class="cm">/* read &amp; discard headers */</span>
</span><span class='line'>            <span class="n">numchars</span> <span class="o">=</span> <span class="n">get_line</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span><span class='line'>    <span class="k">else</span>    <span class="cm">/* POST */</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* 对 POST 的 HTTP 请求中找出 content_length */</span>
</span><span class='line'>        <span class="n">numchars</span> <span class="o">=</span> <span class="n">get_line</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">((</span><span class="n">numchars</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="cm">/*利用 \0 进行分隔 */</span>
</span><span class='line'>            <span class="n">buf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>            <span class="cm">/* HTTP 请求的特点*/</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Content-Length:&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>                <span class="n">content_length</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]));</span>
</span><span class='line'>            <span class="n">numchars</span> <span class="o">=</span> <span class="n">get_line</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="cm">/*没有找到 content_length */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">content_length</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="cm">/*错误请求*/</span>
</span><span class='line'>            <span class="n">bad_request</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 正确，HTTP 状态码 200 */</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 建立管道*/</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*错误处理*/</span>
</span><span class='line'>        <span class="n">cannot_execute</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="cm">/*建立管道*/</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*错误处理*/</span>
</span><span class='line'>        <span class="n">cannot_execute</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*错误处理*/</span>
</span><span class='line'>        <span class="n">cannot_execute</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="cm">/* child: CGI script */</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">meth_env</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">query_env</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">length_env</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="cm">/* 把 STDOUT 重定向到 cgi_output 的写入端 */</span>
</span><span class='line'>        <span class="n">dup2</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* 把 STDIN 重定向到 cgi_input 的读取端 */</span>
</span><span class='line'>        <span class="n">dup2</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* 关闭 cgi_input 的写入端 和 cgi_output 的读取端 */</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>        <span class="cm">/*设置 request_method 的环境变量*/</span>
</span><span class='line'>        <span class="n">sprintf</span><span class="p">(</span><span class="n">meth_env</span><span class="p">,</span> <span class="s">&quot;REQUEST_METHOD=%s&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
</span><span class='line'>        <span class="n">putenv</span><span class="p">(</span><span class="n">meth_env</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;GET&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="cm">/*设置 query_string 的环境变量*/</span>
</span><span class='line'>            <span class="n">sprintf</span><span class="p">(</span><span class="n">query_env</span><span class="p">,</span> <span class="s">&quot;QUERY_STRING=%s&quot;</span><span class="p">,</span> <span class="n">query_string</span><span class="p">);</span>
</span><span class='line'>            <span class="n">putenv</span><span class="p">(</span><span class="n">query_env</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>   <span class="cm">/* POST */</span>
</span><span class='line'>            <span class="cm">/*设置 content_length 的环境变量*/</span>
</span><span class='line'>            <span class="n">sprintf</span><span class="p">(</span><span class="n">length_env</span><span class="p">,</span> <span class="s">&quot;CONTENT_LENGTH=%d&quot;</span><span class="p">,</span> <span class="n">content_length</span><span class="p">);</span>
</span><span class='line'>            <span class="n">putenv</span><span class="p">(</span><span class="n">length_env</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="cm">/*用 execl 运行 cgi 程序*/</span>
</span><span class='line'>        <span class="n">execl</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>    <span class="cm">/* parent */</span>
</span><span class='line'>        <span class="cm">/* 关闭 cgi_input 的读取端 和 cgi_output 的写入端 */</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;POST&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="cm">/*接收 POST 过来的数据*/</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">content_length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">recv</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>                <span class="cm">/*把 POST 数据写入 cgi_input，现在重定向到 STDIN */</span>
</span><span class='line'>                <span class="n">write</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="cm">/*读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT */</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="cm">/*关闭管道*/</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>        <span class="cm">/*等待子进程*/</span>
</span><span class='line'>        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Get a line from a socket, whether the line ends in a newline, </span>
</span><span class='line'><span class="cm"> * carriage return, or a CRLF combination.  Terminates the string read </span>
</span><span class='line'><span class="cm"> * with a null character.  If no newline indicator is found before the </span>
</span><span class='line'><span class="cm"> * end of the buffer, the string is terminated with a null.  If any of </span>
</span><span class='line'><span class="cm"> * the above three line terminators is read, the last character of the </span>
</span><span class='line'><span class="cm"> * string will be a linefeed and the string will be terminated with a </span>
</span><span class='line'><span class="cm"> * null character. </span>
</span><span class='line'><span class="cm"> * Parameters: the socket descriptor </span>
</span><span class='line'><span class="cm"> *             the buffer to save the data in </span>
</span><span class='line'><span class="cm"> *             the size of the buffer </span>
</span><span class='line'><span class="cm"> * Returns: the number of bytes stored (excluding null) */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">get_line</span><span class="p">(</span><span class="kt">int</span> <span class="n">sock</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*把终止条件统一为 \n 换行符，标准化 buf 数组*/</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">))</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*一次仅接收一个字节*/</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="cm">/*收到 \r 则继续接收下个字节，因为换行符可能是 \r\n */</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="cm">/*使用 MSG_PEEK 标志使下一次读取依然可以得到这次读取的内容，可认为接收窗口不滑动*/</span>
</span><span class='line'>                <span class="n">n</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MSG_PEEK</span><span class="p">);</span>
</span><span class='line'>                <span class="cm">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span>
</span><span class='line'>                <span class="cm">/*但如果是换行符则把它吸收掉*/</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">))</span>
</span><span class='line'>                    <span class="n">recv</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>                <span class="k">else</span>
</span><span class='line'>                    <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="cm">/*存到缓冲区*/</span>
</span><span class='line'>            <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*返回 buf 数组大小*/</span>
</span><span class='line'>    <span class="k">return</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Return the informational HTTP headers about a file. */</span>
</span><span class='line'><span class="cm">/* Parameters: the socket to print the headers on </span>
</span><span class='line'><span class="cm"> *             the name of the file */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">headers</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">filename</span><span class="p">;</span>  <span class="cm">/* could use filename to determine file type */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*正常的 HTTP header */</span>
</span><span class='line'>    <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/*服务器信息*/</span>
</span><span class='line'>    <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">SERVER_STRING</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Content-Type: text/html</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Give a client a 404 not found status message. */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">not_found</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 404 页面 */</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;HTTP/1.0 404 NOT FOUND</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/*服务器信息*/</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">SERVER_STRING</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Content-Type: text/html</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;your request because the resource specified</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;is unavailable or nonexistent.</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;/BODY&gt;&lt;/HTML&gt;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Send a regular file to the client.  Use headers, and report </span>
</span><span class='line'><span class="cm"> * errors to client if they occur. </span>
</span><span class='line'><span class="cm"> * Parameters: a pointer to a file structure produced from the socket </span>
</span><span class='line'><span class="cm"> *              file descriptor </span>
</span><span class='line'><span class="cm"> *             the name of the file to serve */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">serve_file</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">FILE</span> <span class="o">*</span><span class="n">resource</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">numchars</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*读取并丢弃 header */</span>
</span><span class='line'>    <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">((</span><span class="n">numchars</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>  <span class="cm">/* read &amp; discard headers */</span>
</span><span class='line'>        <span class="n">numchars</span> <span class="o">=</span> <span class="n">get_line</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*打开 sever 的文件*/</span>
</span><span class='line'>    <span class="n">resource</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">resource</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>        <span class="n">not_found</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*写 HTTP header */</span>
</span><span class='line'>        <span class="n">headers</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/*复制文件*/</span>
</span><span class='line'>        <span class="n">cat</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">resource</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">fclose</span><span class="p">(</span><span class="n">resource</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* This function starts the process of listening for web connections </span>
</span><span class='line'><span class="cm"> * on a specified port.  If the port is 0, then dynamically allocate a </span>
</span><span class='line'><span class="cm"> * port and modify the original port variable to reflect the actual </span>
</span><span class='line'><span class="cm"> * port. </span>
</span><span class='line'><span class="cm"> * Parameters: pointer to variable containing the port to connect on </span>
</span><span class='line'><span class="cm"> * Returns: the socket */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">startup</span><span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">httpd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*建立 socket */</span>
</span><span class='line'>    <span class="n">httpd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">httpd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">error_die</span><span class="p">(</span><span class="s">&quot;socket&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
</span><span class='line'>    <span class="n">name</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span><span class='line'>    <span class="n">name</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="o">*</span><span class="n">port</span><span class="p">);</span>
</span><span class='line'>    <span class="n">name</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">httpd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">error_die</span><span class="p">(</span><span class="s">&quot;bind&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/*如果当前指定端口是 0，则动态随机分配一个端口*/</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="cm">/* if dynamically allocating a port */</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">getsockname</span><span class="p">(</span><span class="n">httpd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">namelen</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="n">error_die</span><span class="p">(</span><span class="s">&quot;getsockname&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="cm">/*开始监听*/</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">httpd</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">error_die</span><span class="p">(</span><span class="s">&quot;listen&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/*返回 socket id */</span>
</span><span class='line'>    <span class="k">return</span><span class="p">(</span><span class="n">httpd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="cm">/* Inform the client that the requested web method has not been </span>
</span><span class='line'><span class="cm"> * implemented. </span>
</span><span class='line'><span class="cm"> * Parameter: the client socket */</span>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">unimplemented</span><span class="p">(</span><span class="kt">int</span> <span class="n">client</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* HTTP method 不被支持*/</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;HTTP/1.0 501 Method Not Implemented</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/*服务器信息*/</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">SERVER_STRING</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Content-Type: text/html</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;&lt;/BODY&gt;&lt;/HTML&gt;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**********************************************************************/</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">server_sock</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">u_short</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">client_sock</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client_name</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">client_name_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_name</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="n">newthread</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*在对应端口建立 httpd 服务*/</span>
</span><span class='line'>    <span class="n">server_sock</span> <span class="o">=</span> <span class="n">startup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;httpd running on port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="cm">/*套接字收到客户端连接请求*/</span>
</span><span class='line'>        <span class="n">client_sock</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_sock</span><span class="p">,(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_name</span><span class="p">,</span><span class="o">&amp;</span><span class="n">client_name_len</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">client_sock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="n">error_die</span><span class="p">(</span><span class="s">&quot;accept&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="cm">/*派生新线程用 accept_request 函数处理新请求*/</span>
</span><span class='line'>        <span class="cm">/* accept_request(client_sock); */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newthread</span> <span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">accept_request</span><span class="p">,</span> <span class="n">client_sock</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;pthread_create&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">server_sock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[i.MX280]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/12/i-dot-mx280/"/>
    <updated>2015-11-12T15:40:17+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/12/i-dot-mx280</id>
    <content type="html"><![CDATA[<h2>Linux内核组成部分</h2>

<ol>
<li>内存管理

<ol>
<li>进程管理负责控制进程对CPU的访问，如任务的创建、调度和终止等。任务调度是进程管理最核心的工作，由Linux内核调度器来完成。Linux内核调度器根据一定算法来选择最值得运行的进程</li>
<li>运行态：已经获得了资源，并且进程正在被CPU执行进程既可以运行在内核态，也可运行在用户态

<ol>
<li>内核态：内核和驱动所运行时的状态，程序处于特权阶级，能够访问系统的任何资源</li>
<li>用户态：用户程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序运行的状态，处于非特权阶级，不能随意访问系统资源，必须通过驱动程序方可访问，用户态程序可通过系统调用进入内核态。</li>
</ol>
</li>
<li>就绪态：当系统资源已经可用，但由于前一个进程还没有执行完而释放CPU，准备进入运行状态</li>
<li>可中断睡眠状态：当进程处于可中断等待状态时，系统不会调度改程序执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以被唤醒进入就绪状态或者运行态</li>
<li>不可中断睡眠状态：处于中断等待状态，但是该进程只能被使用wake_up（）函数明确唤醒的时候才可进入就绪状态。</li>
<li>暂停状态：当进程收到SIGSTOP、SIGSTP、SIGTTIN或者SIGTTOU就会进入暂停状态，收到SIGCONT信号即可进入运行态</li>
<li>僵死态：进程已经被停止运行，但是其父进程还没有询问其状态
<img src="http://i.imgur.com/bBBsOdX.png" alt="Linux进程状态和转换" /></li>
</ol>
</li>
<li>内存管理

<ul>
<li>内存管理的主要作用是控制和管理多个进程，使之能够安全的共享主内存区域。当CPU提供内存管理单元MMU时，内存管理为各进程实现虚拟地址到内存物理地址的转换。在32位系统上，Linux内核将4G空间分为1G内核空间（3~4G）和3G（0~3G）用户控件，通过内存管理，每个进程都可以使用3G的用户空间</li>
</ul>
</li>
<li>文件系统

<ul>
<li>Linux内核支持众多的逻辑文件系统，如Ext2、Ext3、Ext4、btrfs、NFS、VFAT等。VFS则是Linux基于各种逻辑文件系统抽象出的一种内存中的文件系统，隐藏了各种硬件设备的细节，为用户提供了同意的操作接口，是用户访问各种不同文件系统和设备时，不用区分具体的逻辑文件系统。</li>
</ul>
</li>
<li>网络接口

<ul>
<li>Linux对网络支持相当完善，网络接口提供了对各种网络标准的存取和各种网络硬件的支持，接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序</li>
</ul>
</li>
<li>进程间通信

<ul>
<li>支持进程间各种通信机制，如管道、命令管道、信号、消息队列、内存共享、信号量和套接字等。

<ol>
<li>管道通常用于具有亲缘关系的父子进程或者兄弟进程间通信，是半双工的，数据只能往一个方向流动，先入先出，与自来水管很相似。如果双方胡同时，需要建立两个管道</li>
<li>命名管道突破了进程间的亲缘关系限制，即非父子、兄弟进程之间也可以相互通信</li>
<li>信号是软件中断，用于在多个进程之间传递一步信号。</li>
<li>信号能传递的信息很有限，而消息队列正好弥补了这点。</li>
<li>共享内存常用于不同进程间进行大量数据传递。Linux下每个进程都有自己的独立空间，各自都不能直接访问其他进程的空间。</li>
<li>信号量用于进程同步。只有获得了信号量的进程才可以运行，没有获得信号量的进程则只能等待。</li>
<li>套接字起源于BSD，也常称“BSD套接字”，用于多个进程间通信，可以基于文件，也可以基于网络。
<img src="http://i.imgur.com/fk3Ryjy.png" alt="Linux操作系统基本体系结构" /></li>
</ol>
</li>
</ul>
</li>
</ol>


<h2>设置主板支持虚拟化</h2>

<ol>
<li>进入BIOS（F2或者F10等等）</li>
<li>找到Intel Virtualization Technology选项，设置为Enable</li>
<li>设置好后重启电脑</li>
</ol>


<h2>虚拟网卡有三种模式</h2>

<ol>
<li>桥接模式

<ol>
<li>这种情况下，虚拟机虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台主机。在桥接模式下，虚拟系统和宿主机的关系就像连接在同一个Hub上的两台电脑。用户需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的而一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或罗尤其访问互联网。在进行嵌入式Linux开发，要目标板通过NFS挂载虚拟机的NFS共享目录的话，必须将虚拟王珂配置为桥接模式</li>
</ol>
</li>
<li>NAT模式

<ol>
<li>使用NAT模式，就是让虚拟机系统借助NAT（网络地址转化）功能，通过宿主机器在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，虚拟机无法正常对主机锁链网络中的其他主机提供普通的而络服务，如TFTP、NFS和FTP等。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，用户不需要进行任何其他的配置，只需要宿主机器能访问互联网即可</li>
</ol>
</li>
<li>Host-Only模式

<ol>
<li>在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔开，这是用户就可采用仅主机（Host-Only）模式。在Host-Only模式中，所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的。</li>
</ol>
</li>
</ol>


<h2>简单的Shell</h2>

<ol>
<li>cd -:切换至之前的工作目录</li>
<li>ls -lash:查看当前目录文件信息</li>
<li>pwd：查看当前路径</li>
<li>mkdir -p：创建多级目录</li>
<li>rmdir：删除空目录</li>
<li>alias rm=&ldquo;rm -vi"：为rm -vi取别名</li>
<li>rm -rf:强制删除某些文件或者目录</li>
<li>touch a：创建a文件，文件大小为0</li>
<li>file a：读取a文件的文件头并识别文件类型。a文件必须具有可读属性</li>
<li>more/less：两个命令都能用来浏览文本文件，可以分页查看文件内容，空格翻页。文件浏览完毕，按键盘q退出。相比来说，less命令更加灵活，支持键盘Page Up和Page Down键，可任意向前后翻页浏览，并且还支持文本搜索。使用less打开文件后，输入/abc可在文本中搜索字符串abc</li>
<li>head/tail：这两个命令可分别查看文件头部和文件尾部，一般用于查看ASCII文件。默认显示10行，加上参数-n【数字】可以指定显示行数或者加上参数-c【数字】指定显示的字节数</li>
<li>cat：cat命令可以将一个或者多个文件输出到标准输出上，可以用于文件查看</li>
<li>文件合并：cat [选项] 文件1 文件2 &hellip; [>文件3]

<ol>
<li>选项

<ul>
<li>-n ：从1开始对输出进行编号</li>
<li>-b：类似于-n，从1开始编号，但是忽略空白行</li>
<li>-s：遇到连续两行或者以上的空白行，就替换为一行空白行</li>
</ul>
</li>
</ol>
</li>
<li>文件压缩/解压：tar [选项] 文件

<ol>
<li>tar是UNIX系统的一个文件打包工具，只是连续首位相连的将文件堆放起来，并不具备压缩功能，但是加上选项，tar可以调用其它压缩/解压工具，能够实现文件的压缩和解压</li>
<li>选项

<ul>
<li>-c：创建存档文件，与-x相斥</li>
<li>-t：列出档案文件的文件列表</li>
<li>-x：解包存档文件，与-c相斥</li>
<li>-A：合并存档文件</li>
<li>-d：比较存档文件与源文件</li>
<li>-r：追加文件到存档文件末尾</li>
<li>-u：更新存档文件</li>
<li>-f：指定存档文件，与其他选项同时使用时，必须在最后，如tar -xjvf a.tar.bz2</li>
<li>-v:显示详细处理信息</li>
<li>-C：转到指定目录，常用于解开存档文件</li>
<li>-j：调用bzip2程序</li>
<li>-z：调用gzip程序</li>
<li>-Z：调用compress程序</li>
<li>&ndash;exclude=PATH：排除指定文件或者目录，常用于打包文件</li>
</ul>
</li>
</ol>
</li>
<li>文件复制：cp [选项] 源文件/目录 目的文件/目录

<ol>
<li>选项：

<ul>
<li>-a：保留链接，文件属性并递归复制，等同于-dpR组合，常用于复制目录</li>
<li>-d：复制时保留链接</li>
<li>-f：若目标文件已经存在，则直接删除而不提示</li>
<li>-i：若目标文件已经存在，需要用户确认操作，与-f相反</li>
<li>-p：除复制文件内容外，把访问权限和修改时间也复制到新文件中</li>
<li>-f：递归复制，递归复制指定目录下的文件和目录</li>
<li>-v：显示文件复制过程</li>
</ul>
</li>
</ol>
</li>
<li>创建链接：ln [选项] 源文件/目录 目标文件

<ol>
<li>硬链接通过索引节点进行链接，相当于源文件的镜像，占用源文件一样大小的空间，修改其中任何一个，另外一个都会进行同样的改动。给一个文件创建硬链接后，文件属性的硬连接数会增加。硬链接不能跨越文件系统，只能在同一个文件系统内进行链接，且不能对目录文件建立硬链接，给目录文件建立硬链接会出错</li>
<li>软连接和硬链接不同，软连接是产生一个新文件，这个文件指向另一个文件的位置，类似于Windows下的快捷方式。软连接可以跨越文件系统，且用于任何文件，包括目录文件</li>
</ol>
</li>
<li>网卡配置：ifconfig 网络接口 [选项] 地址/参数

<ol>
<li>选项：

<ul>
<li>-a：查看系统拥有的全部网络接口</li>
<li>网络接口如eth0：指定操作某个网口</li>
<li>broadcast：设置网口的广播地址</li>
<li>netmask：设置网口的子网掩码</li>
<li>hw ether：设置网卡物理地址（如果驱动不支持则无效）</li>
<li>up：激活指定网卡</li>
<li>down：关闭指定网卡</li>
</ul>
</li>
</ol>
</li>
<li>安装和卸载文件系统

<ol>
<li>linux允许多个文件系统存在于同一个系统中，也允许用户在系统运行中安装内核所支持的文件系统。例如，讲一个FAT格式的U盘插入到linux系统中。</li>
<li>linux安装文件系统：mount [参数] [设备名] [挂载点]

<ol>
<li>参数：

<ul>
<li>-a：挂载/etc/fstab文件中列出的所有文件系统</li>
<li>-r：以只读的方式挂载</li>
<li>-w：以可写的方式挂载（默认）</li>
<li>-v：显示详细安装信息</li>
<li>-t&lt;文件系统类型>：指定文件系统类型，常见的有：

<ul>
<li>ext/ext2/ext3/ext4:Linux常用文件系统</li>
<li>msdos：MS-DOS的FAT，即FAT16</li>
<li>vfat：Windows系统的FAT，FAT32</li>
<li>nfs：网络文件系统</li>
<li>ntfs：Windows2000/NT/XP的ntfs文件系统</li>
<li>auto：自动检测文件系统</li>
</ul>
</li>
<li>-o&lt;选项>：指定挂载时的一些选项，常用有：

<ul>
<li>defaults：使用默认值（auto，nouser，rw，suid）</li>
<li>suid/nosuid：确认/不确认suid和sgid位</li>
<li>user/nouser：允许/不允许一般用户挂载</li>
<li>codepage=XXX：指定codepage</li>
<li>iocharset=XXX：指定字符集</li>
<li>ro：以只读方式挂载</li>
<li>rw：以读写方式挂载</li>
<li>remount：重新安装已经安装了的文件系统</li>
<li>loop：挂载loopback设备以及ISO文件</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>挂载点必须是一个已经存在的目录</li>
<li>一个挂载点可以被多个设备/文件重复挂载，只是后一次挂载将覆盖前一次内容，卸载后可用</li>
<li>使用多个-o参数的时候，-o只用一次，参数之间用半角逗号隔开</li>
<li>例如，挂载FAT格式的U盘：

<ol>
<li>mount -t vfat /dev/sda1 /mnt</li>
</ol>
</li>
<li>nfs挂载，将远程主机主机Linux的某个共享目录挂载到嵌入式系统本地，当成本地设备进行操作：

<ol>
<li>mount -t nfs 192.168.1.138:/home/morris/lpc/mnt -o nolock</li>
<li>nolock表示禁用文件锁，当连接到一个旧版本的NFS服务器时常加该选项</li>
</ol>
</li>
<li>此外，嵌入式开发中常用的文件系统还有cramfs，jffs2，yaffs2以及ubifs等，特别是用于NOR Flash的jffs2和用于NAND Flash的yaffs/yaffs2,ubifs等，在进行系统操作中通常需要对各设备进行挂载或者卸载，需要在挂载的时候指定正确的文件系统类型。

<ul>
<li>挂载yaffs2分区的命令示例：mount -t yaffs2 /dev/mtdblock2 /mnt</li>
<li>挂载ubifs分区的命令示例：mount -t ubifs ubi0:rootfs /mnt</li>
</ul>
</li>
<li>文件系统卸载：umount 挂载点</li>
</ol>
</li>
<li>使用sudo命令需要管理员将用户添加到sudoer组中，一般在/etc/sudoer文件中修改</li>
<li>linux中，对文件的操作都是先保存在缓存中，并没有立即写入磁盘，经系统调度后方可写入磁盘。如果修改了缓存，还没来得及写到磁盘就断电，自然就会造成文件改变丢失。要避免这种情况，就是修改文件后，立即强制进行一次文件同步操作，将缓存的内容写入磁盘，确保文件系统的完整性。能完成这样功能的命令是sync。只需要在关闭文本编辑器后再shell输入sync即可</li>
<li>文件搜索，find 路径 选项 其他

<ol>
<li>最常用的就是根据文件名来查找，加上-name就可以了，还可以支持通配符，进行模糊搜索。例如：find arch/arm/ -name mux*.c</li>
</ol>
</li>
<li>字符串搜索： grep 选项

<ol>
<li>例如：grep &ldquo;pcf8563&rdquo; -R arch/arm</li>
<li>关键字最好加上双引号，特别是包含空格的关键字。</li>
<li>-R表示递归查找</li>
</ol>
</li>
<li>执行Shell脚本有多种方式：

<ol>
<li>点+斜线+文件名，这种方式要求文件必须具有可执行权限</li>
<li>点+空格+文件名，这种方式不要求文件一定具有可执行权限</li>
<li>sh+空格+文件名，这种方式不要求文件一定具有可执行权限</li>
<li>source+空格+文件名，这种方式不要求文件一定具有可执行权限</li>
</ol>
</li>
</ol>


<h2>重定向</h2>

<ol>
<li>Linux Shell终端启动的时候会打开3个标准文件：标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。shell从标准输入（通常是键盘）接收命令，命令执行结果信息打印到标准输出（通常是终端屏幕）上，如有错误信息，则打印到标准错误（通常是终端屏幕）上。</li>
<li>Shell允许用户对输入输出进行重定向。输出重定向允许将输出信息从标准输出重定向到其他文件上，也可以重定向到某个设备如打印机上。</li>
<li>重定向在Linux下用“>”和“>>”表示，“>”表示输出到一个新文件中，而“>>”则表示输出到现有文件的末尾。如果文件已经存在，直接操作文件，否则将创建新文件。</li>
<li>echo命令将内容回显到标准输出上，使用echo命令加上重定向可以创建一个带内容的非空文件。</li>
<li>回显内容如果不加引号，则用单空格替代多个连续空格，如果加了引号，则原封不动回显</li>
</ol>


<h2>使用内核模块和驱动</h2>

<ol>
<li>加载（插入）模块

<ol>
<li>linux能够动态加载和卸载模块。如果某些功能平时用不到，可以不编译进内核，而采取模块方式编译，在需要的时候再插入内核，不再需要的时候卸载。linux中最常见的模块是内核驱动</li>
<li>insmod [选项] 模块 [符号名称=值]，常用选项

<ol>
<li>-f：强制将模块载入，不检查目前kernel版本与模块编译时的kernel是否一致</li>
<li>-k：将模块设置为自动卸载</li>
<li>-p：测试模块是否能正确插入</li>
<li>-x：不导出模块符号</li>
<li>-X：导出模块所有外部符号（默认）</li>
<li>-v：显示执行过程</li>
</ol>
</li>
</ol>
</li>
<li>查看系统已经加载的模块：lsmod，其实际上就是列出/proc/modules的内容</li>
<li>卸载驱动模块：rm [选项] 模块，常用选项

<ol>
<li>-f：强制卸载正在被使用的模块，非常危险。需要内核支持CONFIG_MODULE_FORCE_UNLOAD使能，否则无效</li>
<li>-w：通常情况下不能卸载正在被使用的模块，加上-w选项，指定模块将会被孤立，直到不再被使用</li>
<li>-s：将错误信息写入syslog，而不是标准错误</li>
<li>-v：显示执行过程</li>
</ol>
</li>
<li>自动处理可加载模块：insmod/rmmod分别用于加载和卸载模块，但是每次只能加载/卸载一个模块，如果一个模块依赖于多个模块，则需要进行多次操作，比较繁琐。modprobe命令集加载/卸载功能于一身，并且可以自动解决模块的依赖关系。modprobe [选项] 模块[符号=值]，常用选项：

<ol>
<li>-C&lt;文件>：不使用默认配置文件，使用指定文件作为配置文件</li>
<li>-i：忽略配置文件中的加载和卸载命令</li>
<li>-r：卸载指定模块，包括依赖模块</li>
<li>-f：强制安装</li>
<li>-l：显示所有匹配模块</li>
<li>-a：安装所有匹配的模块</li>
<li>&ndash;show-depends：显示模块的依赖关系</li>
<li>-v：显示执行过程</li>
<li>-q：不显示任何信息</li>
<li>-V：显示版本信息</li>
</ol>
</li>
<li>modprob处理模块时忽略模块的路径，这要求系统模块和驱动是按照make modules_install方式安装的，即模块必须放在/lib/modules/$(uname -r)目录下，并且有正确的/lib/modules/$(uname -r)/modules.dep文件，modprobe根据该文件来寻找和解决依赖关系</li>
<li>如果系统不能自动创建设备节点，加载驱动后，则需要为驱动建立对应的设备节点，否则无法通过驱动来操作设备。mknod 设备名 设备类型 主设备号 次设备号</li>
</ol>


<h2>环境变量</h2>

<ol>
<li>Linux是一个多用户操作系统，每个用户都有自己专有的运行环境，用户所使用的环境由一系列变量所定义，这些变量被称为环境变量，系统环境变量一般都是大写</li>
<li>常见的环境变量：

<ol>
<li>PATH：决定了Shell将到哪些目录中寻找命令或程序，这个变量是在日常使用中经常需要修改的变量</li>
<li>TERM：指定系统终端</li>
<li>SHELL：当前用户shell类型</li>
<li>HOME：当前用户主目录</li>
<li>LOGNAME：当前用户的登录名</li>
<li>USER：当前用户名</li>
<li>HISTSIZE：历史命令记录数</li>
<li>HOSTNAME：主机名</li>
<li>LANGUGE：语言相关的环境变量，多语言可以修改此环境变量</li>
<li>MAIL：当前用户的邮件存放目录</li>
<li>PS1：基本提示符，对于root用户是#，对于普通用户是$</li>
<li>PS2：附属提示符，默认是“>”</li>
<li>LS_COLORS:ls命令结果颜色显示</li>
</ol>
</li>
<li>在shell下通过$符号来引用环境变量，使用echo可以查看某个具体环境变量的值</li>
<li>使用env或者printenv命令可以查看系统全部的环境变量设置</li>
<li>修改系统配置文件以达到修改环境变量的目的

<ol>
<li>修改/etc/profile文件会影响使用本机的全部用户</li>
<li>修改~/.bashrc则仅仅影响当前用户</li>
</ol>
</li>
</ol>


<h2>Linux目录树标准与文件系统</h2>

<ol>
<li>文件层次标准（FHS）对Linux根文件系统的基本目录结构做了比较详细的规定

<ol>
<li>bin：基本命令的程序文件，里面不能再包含目录</li>
<li>boot：Bootloader静态文件</li>
<li>dev：设备文件</li>
<li>etc：系统配置文件，配置文件必须是静态文件，不能是二进制文件</li>
<li>home：存放各用户的个人数据</li>
<li>lib：基本的共享库和内核模块</li>
<li>media：可移动介质的挂载点</li>
<li>mnt：临时的文件系统挂载点</li>
<li>opt：附件的应用程序软件包</li>
<li>root：root用户目录</li>
<li>sbin：基本的系统命令二进制文件</li>
<li>srv：系统服务的一些数据</li>
<li>tmp：临时文件</li>
<li>usr

<ol>
<li>/usr/bin:众多的应用程序</li>
<li>/usr/sbin:超级用户的一些管理程序</li>
<li>/usr/doc:linux文档</li>
<li>/usr/lib:常用的动态链接库和软件包的配置文件</li>
<li>/usr/man:帮助文档</li>
<li>/usr/src:源代码</li>
<li>/usr/local/bin:本地增加的命令</li>
<li>/usr/local/lib:本地增加的库</li>
</ol>
</li>
<li>var：可变数据</li>
</ol>
</li>
<li>Linux下所有文件的描述结构都是相同的，包含索引节点和数据

<ol>
<li>索引节点：又称I节点，是Linux文件系统用来记录文件信息的一种数据结构，信息包括文件名、文件长度、文件权限、存放位置、所属关系、创建和修改时间。文件系统维护了一个索引节点的数组，每个文件都与索引节点数组中的唯一元素对应，索引节点在数组中的索引号称为索引节点号。每个文件都有一个索引号与之对应，而一个索引节点号可以对应多个文件。</li>
<li>数据：文件的实际内容，可以是空的，也可以非常大，并且拥有自己的结构</li>
</ol>
</li>
<li>Linux系统中，文件名以点号（.）开始的文件是隐藏文件，用ls命令不加-a将看不到这类文件</li>
<li>设备文件

<ol>
<li>设备是一种特殊的的文件，除了存放在文件I节点中的信息外，它们不包含任何数据，有效的设备文件与相应的设备对应，通过设备文件，可以操作与之对应的硬件设备</li>
<li>设备文件包括字符设备和块设备文件。字符设备按照字符操作设备，如键盘、中断等；块设备文件以块为单位操作设备，如磁盘、光盘等。Linux系统的设备文件都放在/dev目录下，用ls -la命令可以查看各设备的属性</li>
</ol>
</li>
<li>Linux支持多种文件系统，且同时存在于一个一个运行的系统中，查看/proc/filesystems文件，可以看到系统支持的全部文件系统</li>
<li>proc文件系统

<ol>
<li>proc是Linux系统中的一种特殊的文件系统，是内核和内核模块用来向进程发送消息的机制，只存在于内存中，实际上是一个伪文件系统。用户和应用程序可通过/proc获得系统的信息，还可以改变内核的某些参数。</li>
<li>/proc/cpuinfo：CPU信息</li>
<li>/proc/meminfo：物理内存，交换空间信息</li>
<li>/proc/mounts：已加载的文件系统列表</li>
<li>/proc/devices：可用设备的列表</li>
<li>/proc/filesystems：被支持的文件系统</li>
<li>/proc/modules：已加载的模块</li>
<li>/proc/version：内核版本</li>
<li>/proc/cmdline：系统启动时输入的内核命令行参数</li>
</ol>
</li>
<li>sysfs文件系统

<ol>
<li>sysfs是Linux2.6引入的新型文件系统是一个基于内存的文件系统，它的作用是将内核的信息以文件的方式提供给用户程序使用。该文件系统的目录层次结构严格按照内核的数据结构组织，除了二进制文件外，sysfs文件内容均以ASCII格式保存，且一个文件只保存一个数据，另外，一个文件不可大于一个内存页（通常为4096字节）</li>
<li>sysfs提供一种机制，使得可以显式地描述内核对象，对象属性及对象间关系。sysfs有两组接口，一组针对内核，用于将设备映射到文件系统中，另一组针对用户程序，用于读取或操作这些设备
<img src="http://i.imgur.com/yE7Xrtx.png" alt="sysfs内部结构与外部表现" /></li>
<li>sysfs产生了一个包含所有系统硬件的层次视图，把连接在系统上的设备和总线组织成为一个分级的文件，向用户空间导出内核数据结构和以及它们的属性。sysfs清晰地展示了设备驱动模型中各组件的关系，顶层目录包括block、device、bus、drivers、class、power和firmware等。各目录和所包含的内容如下
<img src="http://i.imgur.com/JjRYVxz.png" alt="sysfs目录结构" /></li>
</ol>
</li>
</ol>


<h2>vi的使用</h2>

<ol>
<li>从命令模式进入编辑模式：插入（i或者I），附件（a或者A），打开（o或者O）</li>
<li>光标移动：命令模式下，h（左），j（下），k（上），l（右）</li>
<li>快速光标定位：

<ol>
<li>命令G：将光标定位到最后一行</li>
<li>命令nG：将光标定位到第n行</li>
<li>命令gg：将光标定位到第1行</li>
<li>命令ngg：将光标定位到第n行</li>
<li>命令:n将光标定位到第n行</li>
</ol>
</li>
<li>文本块选定

<ol>
<li>将光标移动到将要选定的文本块开始处，按esc进入命令模式，再按v，进入可视状态，然后移动光标至文本块结尾，被选定的文本块高亮显示。连按两次esc可以取消所选定的文本块</li>
</ol>
</li>
<li>复制和粘贴

<ol>
<li>如果已经选定文本块，按y即可将所选定文本复制到缓冲区，将光标移到将要粘贴的地方，按p，就可完成文本粘贴</li>
<li>在命令模式下，连按yy，即可复制光标所在的行的内容，连按yny即可复制从光标所在行开始的n行</li>
</ol>
</li>
<li>剪切和删除

<ol>
<li>最后一次剪切和删除的内容都可以被粘贴到其他位置</li>
<li>x或nx：剪切从光标所在位置开始的一个或者n个字符</li>
<li>X或nX：剪切光标前的一个或n个字符</li>
<li>dd：删除光标所在行</li>
<li>D：删除光标位置开始至行尾</li>
<li>dw：删除从光标位置至该词末尾的所有字符</li>
<li>d0：删除从光标位置开始至行首</li>
<li>dnd：删除光标所在行开始的n行</li>
<li>dnG：将光标所在行至第n行删除</li>
</ol>
</li>
<li>文本查找

<ol>
<li>在命令模式下，输入“/字符串”即可从光标位置开始向下查找字符串。输入“？字符串”则从光标位置开始向上查找字符串。无论向上还是向下查找，查找下一个，按键盘n键即可</li>
<li>全局匹配搜索：先将光标移动到字符串abc，然后按下“SHIFT+*”，完成搜索。</li>
</ol>
</li>
<li>文本替换

<ol>
<li>在命令模式下，输入：%s /old/new/gc，能够将文本内全部的字符串old替换为new，为了安全起见，可以在替换命令尾部加上c，这样每次替换前都需要确认一下</li>
</ol>
</li>
<li>撤销和回复

<ol>
<li>在命令模式下输入u，可以撤销所做的更改，回复编辑前的状态，这里的编辑以保存命令为界。不小心多按了u时可以用Ctrl+R来恢复</li>
</ol>
</li>
<li>Vi的配置文件

<ol>
<li>在vi内执行的配置命令的效果是临时IDE，关闭vi，再次打开vi，需要重新配置。vi有自己的配置文件，可以是"/etc/vim/vimrc"或者"~/.vimrc"。两者的区别是前者是全局的，影响登陆本机的全部用户，后者仅仅对当前用户有效</li>
</ol>
</li>
<li>文本对比

<ol>
<li>Vim提供了文本对比工具vimdiff</li>
<li>用法：vimdiff file1 file2 file3</li>
<li>vimdiff可以同时进行2个以上文件的对比</li>
</ol>
</li>
</ol>


<h2>如何使全局环境变量生效</h2>

<ol>
<li>添加在/etc/profile中的全局变量生效的方法：. /etc/profile（点+空格+文件名）</li>
</ol>


<h2>MCIMX28x处理器（i.MX28X）</h2>

<ol>
<li>基于ARM926EJ-S内核，主频454MHz</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matlab基础知识]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/11/matlab/"/>
    <updated>2015-11-11T22:45:49+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/11/matlab</id>
    <content type="html"><![CDATA[<h2>几个常用命令</h2>

<ol>
<li>help：查看某个命令的帮助文档</li>
<li>version：获得当前Matlab的版本</li>
<li>pwd：给出当前的工作目录名</li>
<li>dir：ls或dir列出当前目录下的所有文件名清单</li>
<li>cd：改变目录</li>
<li>what：列出当前工作目录下所有的M文件、MAT文件和MEX文件</li>
<li>who：列出当前工作空间里的变量名</li>
<li>clock：时钟设置命令</li>
<li>data：日期设置命令</li>
<li>path：显示MATLAB的当前搜索路径</li>
<li>getenv：getenv（‘matlabpath’）显示当前的MATLAB路径</li>
<li>diary on，diary off：利用diary可以记录MATLAB窗口中进行的所有操作</li>
<li>！（escape）：符号！是MATLAB的扩展运算符，通过该符号，用户有权使用DOS或UNIX命令</li>
<li>demo：该命令引导使用者通过菜单选择为数众多的演示程序</li>
<li>format：数据显示格式。系统默认的数据显示格式是5位</li>
<li>clear：清除工作空间中所有的变量</li>
<li>clear all：从工作空间中清除所有变量和函数</li>
<li>clf：清除图形窗口内容</li>
<li>delete&lt;文件名>：从磁盘中删除指定文件</li>
<li>load name：载入‘name’文件中的所有变量到工作空间</li>
<li>load name x y：载入‘name’文件中的变量x，y到工作空间</li>
<li>save name：保存工作空间变量到文件name.mat中</li>
<li>save name x y：保存工作空间变量x y到文件name.mat中</li>
<li>pack：整理工作空间内存</li>
<li>size：显示当前工作空间中变量的尺寸</li>
<li>length：显示当前工作空间中变量的长度</li>
<li>disp：显示当前工作空间中的变量</li>
</ol>


<h2>运算符</h2>

<ul>
<li>反除运算符：:该运算符得到商的倒数，即a\b等于b/a</li>
<li>不等于：~=</li>
<li>逻辑与：&amp;</li>
<li>逻辑或：|</li>
<li>逻辑非：~</li>
</ul>


<h2>变量名</h2>

<ol>
<li>区分大小写</li>
<li>长度不能超过31位</li>
<li>变量名以字母开头，可以是字母、数字、下划线组成</li>
</ol>


<h2>分支结构</h2>

<blockquote><p>if-else-end语句中的else子句是可选项
嵌套：if-elseif-elseif-&hellip;-else-end</p></blockquote>

<h2>循环结构</h2>

<blockquote><p>for-end
while-end；该语句中的循环判断语句为矩阵时，当且仅当所有的矩阵元素非零时，逻辑表达式的值为真
break；退出循环体，执行循环后的其他语句</p></blockquote>

<h2>数据输入与输出</h2>

<ol>
<li>input：通过键盘输入数据</li>
<li>fprintf：输出格式化信息和数字</li>
<li>disp：可以在命令窗口输出数字、向量、矩阵或字符串，无需变量名</li>
<li>sprintf：将输出写入字符串</li>
</ol>


<h2>数组</h2>

<ol>
<li>MATLAB中，行数组与行向量是同义语，列数组和列向量是同义语</li>
<li>对于加法和减法，数组运算与线性代数中的向量运算相同。但是符号.*和./分别被称为数组乘法运算符和数组除法运算符，它们不同于矩阵和向量乘除法。</li>
<li>计算数组长度：length（x）</li>
<li>删除数组元素：z（3）=[]</li>
<li>MATLAB里，二维数组变量等同于一个矩阵，每一行的元素以分号结束</li>
<li>二维数组的整行或整列可以用一个冒号表示。例如：m(1,:)和m(:,3)分别表示m的第一列和第三列</li>
<li>只有长度相同的向量才能在if语句中进行比较，如果将两个长度不同的向量进行比较，命令窗口会出现出错信息提示。在if语句中比较字符串之前一定要通过增加空格使字符串长度完全相同</li>
</ol>


<h2>MATLAB特有的数字特性</h2>

<blockquote><p>在MATLAB里，所有的变量均为双精度，整数变量和实数变量之间没有区别，实数变量和复数变量同样也没有区别</p></blockquote>

<h2>初等数学函数</h2>

<ul>
<li>sin(x)</li>
<li>cos(x)</li>
<li>tan(x)</li>
<li>asin(x)</li>
<li>acos(x)</li>
<li>atan(x):[-π/2,π/2]</li>
<li>atan2(y,x):与atan(y/x)结果相同，但是-π/2≥atan2(y,x)≥π</li>
<li>sinh(x)</li>
<li>cosh(x)</li>
<li>tanh(x)</li>
<li>asinh(x)</li>
<li>acosh(x)</li>
<li>atanh(x)</li>
<li>abs(x):x的绝对值</li>
<li>angle(x):复数x的相位角</li>
<li>sqrt(x):x的平方根</li>
<li>real(x)</li>
<li>imag(x)</li>
<li>conj(x):复数x的共轭数</li>
<li>round(x):向最近整数取整</li>
<li>fix(x):向0取整</li>
<li>floor(x):向-∞取整</li>
<li>ceil(x):向+∞取整</li>
<li>sign(x):如果x>0,则为+1；如果x&lt;0,则为-1</li>
<li>mod(x,y)：除后余数：x-y*fix(x/y)</li>
<li>rem(x,y):除后余数：x-y*fix(x/y).如果y≤0，则与mod不同</li>
<li>exp(x):以e为底的指数</li>
<li>log(x):以e为底的对数</li>
<li>log10(x):以10为底的对数</li>
<li>factor(x):将x分解质因数</li>
<li>isprime(x):如果x为素数，值为1，否则为0</li>
<li>factorial(x):x!</li>
</ul>


<h2>功能函数</h2>

<ol>
<li>sort(x):将x按照升序重新排列,如果x是矩阵，则重新排列按列进行</li>
<li>sum(x):如果是x是矩阵，返回值由矩阵各列元素和组成的一个行向量</li>
<li>max(x),min(x):如果x是矩阵，函数值为一个行向量，每个元素为矩阵相应列的最大或最小值</li>
<li>rand(n),返回一个nxn的矩阵，元素全是随机数。除非特别规定，否则所生成的是0~1之间均匀分布的随机数</li>
<li>eval：该命令可以作为字符串被编辑，然后用eval执行。字符串可以通过input读取，或在程序中创建</li>
</ol>


<h2>M文件</h2>

<ol>
<li>M文件可以分为脚本文件和函数文件两种</li>
<li>脚本文件操作对象为MATLAB工作空间内的变量，并且在脚本执行结束后，脚本中对变量的一切操作均会被保留。在MATLAB语言中也可以在脚本内部定义变量，并且该变量将会自动地被加入到当前的MATLAB工作空间中，并可以为其他的脚本或函数引用，直到MATLAB被关闭或采用一定的命令将其删除</li>
<li>MATLAB语言的函数文件包含5个部分：

<ol>
<li>函数题头：指函数的定义行，是函数语句的第一行，在该行中将定义函数名，输入变量列表以及输出变量列表等</li>
<li>HI行：指函数帮助文档的第一行</li>
<li>帮助信息</li>
<li>函数体</li>
<li>注释部分：注释语句是以%引导的</li>
</ol>
</li>
<li>echo on,echo off:M文件执行过程中，其命令语句通常不出现在屏幕上，但是当echo on命令将echo开启后，屏幕上会显示所有语句。这时，用户可以看到正在执行的那部分M文件。</li>
<li>开发函数M文件最基本且很有效的一个办法是将第一行的函数语句用%注释掉，然后作为一个命令M文件进行测试。测试通过后，再将函数语句恢复</li>
</ol>


<h2>保存和载入数据</h2>

<ol>
<li>save，load：如果直接使用save，则所有当前变量将被保存到默认文件matlab.mat里。load是与save相反的命令，它取回所有被save保存的变量。</li>
<li>save file_name data-ascii：save能以ASCII码格式保存数据。带有ASCII选项的save和load非常重要，因为他们可以从MATLAB导入和导出数据</li>
<li>自动创建文件名：在一个M文件中，常常需要自动创建一些文件名。如果整条命令连同文件名写为一个字符串，则可通过eval执行。</li>
</ol>


<h2>硬拷贝</h2>

<ul>
<li>使用diary命令制作一个屏幕内容的拷贝，如果其后不加任何文件名，屏幕内容将存入名为diary的文件中，此文件可以用文本方式打开。但是在diary文件里无法得到图形</li>
</ul>


<h2>Matlab中的默认常量</h2>

<ol>
<li>pi：圆周率</li>
<li>inf：无穷大</li>
<li>nan：不定值，即0/0</li>
<li>realmax：最大正实数</li>
<li>realmin：最小正实数</li>
<li>eps：浮点数的相对误差</li>
<li>i：虚数单位</li>
<li>nargin：函数实际输入参数个数</li>
<li>nargout：函数实际输出参数个数</li>
<li>ans：默认变量名</li>
</ol>


<h2>常用矩阵函数运算</h2>

<ol>
<li>rot90（）：矩阵逆时针旋转90°</li>
<li>flipud（）：矩阵上下翻转</li>
<li>fliplr（）：矩阵左右翻转</li>
<li>flipdim（）：矩阵的某维元素翻转</li>
<li>shiftdim（）：矩阵的元素移位</li>
<li>eig（）：计算矩阵的特征值和特征向量</li>
<li>rank（）：计算矩阵的秩</li>
<li>trace（）：计算矩阵的迹</li>
<li>norm（）：计算矩阵的范数</li>
<li>poly（）：计算矩阵的特征方程的根</li>
<li>svd（）：矩阵的奇异值分解</li>
<li>qr（）：矩阵的QR分解</li>
<li>chol（）：矩阵的Cholesky分解</li>
<li>schur（）：矩阵的Schur分解</li>
<li>lu（）：矩阵的LU分解</li>
</ol>


<h2>符号运算</h2>

<ol>
<li>syms 符号变量名1 符号变量名2 &hellip; 符号变量名n

<ol>
<li>用这种格式定义符号变量时不要在变量名上加字符串分界符，变量间用空格而不用逗号分隔</li>
</ol>
</li>
<li>含有符号对象的表达式称为符号表达式，建立符号表达式有以下3中方法：

<ol>
<li>利用单引号来生成符号表达式</li>
<li>用sym函数建立符号表达式</li>
<li>使用已经定义的符号变量组成符号表达式
<img src="http://i.imgur.com/sjfydxI.png" alt="符号表达式创建实例" /></li>
</ol>
</li>
<li>Matlab中，数值矩阵不能直接参与符号运算，必须先转化为符号矩阵

<ol>
<li>将数值矩阵转化为符号矩阵：sym（数值矩阵）</li>
<li>将符号矩阵转化为数值矩阵：numeric（A）</li>
</ol>
</li>
<li>关于符号矩阵的函数

<ol>
<li>transpose（S）：返回S矩阵的转置矩阵</li>
<li>determ（S）：返回S矩阵的行列式值</li>
<li>许多数值矩阵的函数，如diag，triu，tril，inv，det，rank，eig等也可直接应用于符号矩阵</li>
</ol>
</li>
<li>符号表达式的四则运算

<ol>
<li>factor（S）：对S分解因式，S是符号表达式或符号矩阵</li>
<li>expand（S）：对S进行展开，S是符号表达式或符号矩阵</li>
<li>collect（S，v）：对S按变量v合并同类项，S是符号表达式或符号矩阵</li>
<li>simplify（S）：应用函数规则对S进行简化</li>
<li>simple（S）：调用MATLAB的其他函数对表达式进行综合化简，并显示化简过程</li>
</ol>
</li>
<li>常用的符号运算

<ol>
<li>limit，求极限的符号函数，常用的格式：limit（F，x，a，‘right’）或limit（F，x，a，‘left’）。当自变量x从右侧或左侧逼近a时，函数F的极值</li>
<li>diff，求微分用的符号函数，常用格式：diff（f，x，n），表示f关于x求n阶导数</li>
<li>int，求积分用的符号函数，常用格式：int（f，r，x0，x1），f为所要积分的表达式，r为积分变量，若为定积分，则x0与x1为积分上下限</li>
<li>symsum，级数求和的符号函数，常用的格式：S=symsum（fk，k，k0，kn），其中fk为级数的通项，k为级数自变量，k0和kn为级数求和的起始项和终止项，且可设为inf</li>
<li>dsolve，求解常微分方程的符号函数，常用格式：dsolve（'eqnl',&lsquo;condition&rsquo;,&lsquo;var'）;该函数求解微分方程eqnl在初始条件condition下的特解。参数var描述方程中的自变量符号，省略时按默认原则处理，若没有给出初值条件condition，则求方程的通解
<img src="http://i.imgur.com/o1KV20Q.png" alt="极限和极值的符号运算实例" />
<img src="http://i.imgur.com/Hp0qYod.png" alt="微积分的符号运算实例" />
<img src="http://i.imgur.com/sHRwiap.png" alt="常微分方程符号运算实例" /></li>
</ol>
</li>
</ol>


<h2>图形绘制</h2>

<ol>
<li>ploy,绘制二维图形，常用格式：plot(x1,y,option1,x2,y2,option2,&hellip;)</li>
<li>plot3,绘制三维图形，常用格式：plot3(x1,y1,z1,option1,x2,y2,z2,option2,&hellip;)</li>
<li>mesh,绘制三维曲面，常用格式：mesh(X,Y,Z,C),参数X,Y,Z都为矩阵值，C表示网格曲面的颜色分布。mesh(x,y,Z,C),参数x，y为长度分别是n和m的向量值，而参数Z是维数为mxn的矩阵</li>
<li>surf，绘制三维阴影曲面，常用格式：surf(X,Y,Z,C),surf(x,y,Z,C)
<img src="http://i.imgur.com/pZGpcxE.png" alt="三维网格曲面图绘制应用实例" />
<img src="http://i.imgur.com/0hS4l6O.png" alt="绘图命令使用实例" /></li>
</ol>


<h2>MATLAB程序</h2>

<p><img src="http://i.imgur.com/xWXusd3.png" alt="MATLAB程序基本组成结构" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UML-Knowledges]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/10/uml-knowledges/"/>
    <updated>2015-11-10T15:44:29+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/10/uml-knowledges</id>
    <content type="html"><![CDATA[<h2>StarUML 软件破解</h2>

<ol>
<li><a href="http://staruml.io">官网地址</a></li>
<li>该软件为跨平台的UML建模工具，采用NodeJs编写</li>
<li>破解：安装目录/www/license/node/LicenseManagerDomain.js文件修改为如下：</li>
</ol>


<figure class='code'><figcaption><span>LicenseManagerDomain.js</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">NodeRSA</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;node-rsa&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">validate</span><span class="p">(</span><span class="nx">PK</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">product</span><span class="p">,</span> <span class="nx">licenseKey</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">pk</span><span class="p">,</span> <span class="nx">decrypted</span><span class="p">;</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;morris&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="nx">product</span><span class="o">:</span> <span class="s2">&quot;StarUML&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="nx">licenseType</span><span class="o">:</span> <span class="s2">&quot;vip&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="nx">quantity</span><span class="o">:</span> <span class="s2">&quot;suda_morris.github.io&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="nx">licenseKey</span><span class="o">:</span> <span class="s2">&quot;later equals never!&quot;</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>        <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">pk</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NodeRSA</span><span class="p">(</span><span class="nx">PK</span><span class="p">);</span>
</span><span class='line'>            <span class="nx">decrypted</span> <span class="o">=</span> <span class="nx">pk</span><span class="p">.</span><span class="nx">decrypt</span><span class="p">(</span><span class="nx">licenseKey</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">terms</span> <span class="o">=</span> <span class="nx">decrypted</span><span class="p">.</span><span class="nx">trim</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;\n&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nx">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nx">name</span> <span class="o">&amp;&amp;</span> <span class="nx">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="nx">product</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">,</span>
</span><span class='line'>                <span class="nx">product</span><span class="o">:</span> <span class="nx">product</span><span class="p">,</span>
</span><span class='line'>                <span class="nx">licenseType</span><span class="o">:</span> <span class="nx">terms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
</span><span class='line'>                <span class="nx">quantity</span><span class="o">:</span> <span class="nx">terms</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
</span><span class='line'>                <span class="nx">licenseKey</span><span class="o">:</span> <span class="nx">licenseKey</span>
</span><span class='line'>            <span class="p">};</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Initializes the domain with several commands.</span>
</span><span class='line'><span class="cm">     * @param {DomainManager} domainManager The DomainManager for the server</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">init</span><span class="p">(</span><span class="nx">domainManager</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">domainManager</span><span class="p">.</span><span class="nx">hasDomain</span><span class="p">(</span><span class="s2">&quot;LicenseManager&quot;</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">domainManager</span><span class="p">.</span><span class="nx">registerDomain</span><span class="p">(</span><span class="s2">&quot;LicenseManager&quot;</span><span class="p">,</span> <span class="p">{</span><span class="nx">major</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">minor</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nx">domainManager</span><span class="p">.</span><span class="nx">registerCommand</span><span class="p">(</span>
</span><span class='line'>            <span class="s2">&quot;LicenseManager&quot;</span><span class="p">,</span> <span class="c1">// domain name</span>
</span><span class='line'>            <span class="s2">&quot;validate&quot;</span><span class="p">,</span>       <span class="c1">// command name</span>
</span><span class='line'>            <span class="nx">validate</span><span class="p">,</span>         <span class="c1">// command handler function</span>
</span><span class='line'>            <span class="kc">false</span><span class="p">,</span>            <span class="c1">// this command is synchronous in Node (&quot;false&quot; means synchronous&quot;)</span>
</span><span class='line'>            <span class="s2">&quot;Validate License&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="p">[</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;PK&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">description</span><span class="o">:</span> <span class="s2">&quot;PK&quot;</span>
</span><span class='line'>                <span class="p">},</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">description</span><span class="o">:</span> <span class="s2">&quot;name of license owner&quot;</span>
</span><span class='line'>                <span class="p">},</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;product&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">description</span><span class="o">:</span> <span class="s2">&quot;product name&quot;</span>
</span><span class='line'>                <span class="p">},</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;licenseKey&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">description</span><span class="o">:</span> <span class="s2">&quot;license key&quot;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">],</span>
</span><span class='line'>            <span class="p">[</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="c1">// return values</span>
</span><span class='line'>                    <span class="nx">type</span><span class="o">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="nx">description</span><span class="o">:</span> <span class="s2">&quot;result&quot;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">]</span>
</span><span class='line'>        <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">exports</span><span class="p">.</span><span class="nx">init</span> <span class="o">=</span> <span class="nx">init</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}());</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>打开软件，，help->Enter License,随便输入用户名密码即可破解成功</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Review C++]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/09/c++Primer/"/>
    <updated>2015-11-09T18:08:50+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/09/c++Primer</id>
    <content type="html"><![CDATA[<h2>补码的好处</h2>

<ol>
<li>0的表示唯一</li>
<li>符号位可以直接参与运算</li>
</ol>


<h2>常用的I/O流类库操纵符</h2>

<ol>
<li>dec：数值数据采用十进制表示</li>
<li>hex：数值数据采用十六进制表示</li>
<li>oct： 数值数据采用八进制表示</li>
<li>ws：  提取空白符</li>
<li>endl：插入换行符，并刷新流</li>
<li>ends： 插入空字符</li>
<li>setsprecision(int)： 设置浮点数的小数位数（包括小数点）</li>
<li>setw(int)： 设置域宽</li>
</ol>


<h2>类型别名</h2>

<ol>
<li>typedef 已有类型名 新类型名</li>
<li>using 新类型名 = 已有类型名</li>
</ol>


<h2>auto类型与decltype类型</h2>

<ol>
<li>auto：编译器通过初始值自动推断变量的类型</li>
<li>decltype：定义一个变量与某一表达式的类型相同，但并不用该表达式初始化变量

<ol>
<li>decltype（i） j=2,表示j以2作为初始值，类型与i一致</li>
</ol>
</li>
</ol>


<h2>引用类型</h2>

<ol>
<li>引用（&amp;）是标识符的别名

<ol>
<li>int i；int &amp;ri = i；</li>
</ol>
</li>
<li>定义一个引用时，必须同时对它初始化，使它指向一个已存在的对象</li>
<li>一旦一个引用被初始化后，就不能改为指向其它对象</li>
</ol>


<h2>含有可变参数的函数</h2>

<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LCD]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/05/lcd/"/>
    <updated>2015-11-05T10:19:01+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/05/lcd</id>
    <content type="html"><![CDATA[<h2>TFTLCD驱动芯片</h2>

<ul>
<li>ILI9341、ILI9325、RM68042、RM68021、ILI9320、ILI9328、LGDP4531、SSD1289等</li>
</ul>


<h2>ILI9341</h2>

<ol>
<li>自带显存，其显存总大小为172800（240X320X18/8），即18位模式下（26万色）的显存量。在16位模式下，ILI9341采用RGB565格式存储颜色数据</li>
<li>ILI9341所有的指令都是8位的，高8位无效，且参数除了读写GRAM的时候是16位，其他操作参数都是8位的。这个和ILI9320等驱动器不一样</li>
<li>命令

<ol>
<li>0xD3，这个是读ID4指令，用于读取LCD控制器的ID，这可以用来判断所用的LCD驱动器是什么型号，这样就可以根据控制器的型号去执行对应驱动IC的初始化代码。0xD3指令后跟了4个参数，最后2个参数读出来是0x93和0x41</li>
<li>0x36，这个是存储访问控制指令，可以控制ILI9341存储器的读写方向。简单说木九十在连续写GRAM的时候，可以控制GRAM指针增长的方向，从而控制显示方式。0x36指令后面紧跟一个参数，用来设置GRAM自增方式</li>
<li>0x2A，这是列地址设置指令，在从左到右、从上到下的扫描方式（默认）下面，该指令用于设置横坐标（x坐标）。该指令带有4个参数，实际上是2个坐标值：SC和EC，即列地址的起始值和结束值，SC必须小于等于EC。一般在设置x坐标的时候，我们只需要带2个参数即可，也就是设置SC即可，因为EC没有变化，我们只需要设置一次即可（在初始化ILI9341的时候设置）</li>
<li>0x2B，是页地址设置指令，在从左到右、从上到下的扫描方式（默认）下面，该指令用于设置纵坐标（y坐标）</li>
<li>0x2C，该指令是写GRAM指令，在发送该指令之后，我们便可以网LCD的GRAM里面写入颜色数据了。该指令支持连续写。ILI9341在收到0x2C指令之后，数据有效位宽变为16位，我们可以连续写入LCD GRAM值，而GRAM的地址将根据MY/MX/MV设置的扫描方式进行自增。</li>
<li>0x2E，该指令是读GRAM指令，用于读取ILI9341的显存GRAM。ILI9341在收到该指令后，第一次输出的是dummy数据，也就是无效的数据，第二次开始读取到的才是有效的GRAM数据（从坐标SC、SP开始），输出规律为：每个颜色分量占8位，一次输出2个颜色分量。比如第一次输出的是R1G1，随后的规律为B1R2->G2B2->R3G3->B3R4->G4B4->R5G5&hellip;以此类推。</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CMOS图像传感器OV7670]]></title>
    <link href="http://suda-morris.github.io/blog/2015/11/04/ov7670/"/>
    <updated>2015-11-04T20:19:43+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/11/04/ov7670</id>
    <content type="html"><![CDATA[<h2>OV7670简介</h2>

<ol>
<li>通过SCCB总线控制，可以输出整帧、子采样、取窗口等方式及各种分辨率的8位影响数据。VGA图像最高达到30帧/秒。用户可以完全控制图像质量、数据格式和传输方式</li>
<li>具有自动曝光控制、自动增益控制、自动白平衡，自动消除灯光条纹、自动黑电平校准等自动影像控制功能</li>
<li>支持VGA、GIF和从CIF到40X30的各种尺寸。</li>
<li>所有图像处理功能过程包括伽马曲线、白平衡、饱和度、色度等都可以通过SCCB接口编程。</li>
<li>OV7670 CMOS图像传感器通过减少或消除光学或电子缺陷（如固定图案噪声、拖尾、浮散等），提高图像质量，得到清晰的稳定的彩色图像</li>
<li>OV7670芯片内部有：感光阵列、模拟信号处理模块（包括自动增益和自动白平衡）、10位的ADC、测试图案发生器（八色彩条图案渐变至黑白色条图案）、数字信号处理器（控制由原始信号差值到RGB信号的过程，并控制边缘锐化、颜色空间转换等图像质量处理）、图像缩放模块（按照预先设置的要求输出数据格式）、时许发生模块（产生阵列控制和帧率、帧率的时序、自动曝光控制、输出外部时序）、数字视频端口、SCCB接口、LED和闪光灯输出控制电路等</li>
</ol>


<h2>OV7670参数</h2>

<ol>
<li>感光阵列：640*480</li>
<li>稳定工作温度0~50℃</li>
<li>输出格式：

<ol>
<li>YUV/YCbCr4:2:2</li>
<li>RGB565/555/444</li>
<li>GRB4:2:2</li>
<li>Raw RGB Data</li>
</ol>
</li>
<li>光学尺寸：1/6″</li>
<li>视场角：25°</li>
<li>最大帧率：VGA30 f/s</li>
</ol>


<h2>视频帧存储器AL422B简介</h2>

<ol>
<li>AL422B是一个存储容量为3Mb的视频帧存储器，能够配置为384KB（393，216）X8b FIFO，支持VGA、CCIR、NTSC、PAL和HDTV分辨率</li>
<li>具有独立的读写操作能力，读/写周期时间为20ns，访问时间为15ns，具有高速异步串行存取、输出使能控制、自行刷新数据等功能。</li>
<li>目前1帧图像信息通常包含640X480或者720X480字节。</li>
<li>操作过程：

<ol>
<li>初始化。上电后，分别给nWRST和nRRST各0.1ms的初始化脉冲，使AL422B初始化。</li>
<li>复位操作。通常，复位信号可在任何时候给出而不考虑nWE，nRE以及nOE的状态，但是它们仍然要参照时钟信号的输入情况，使它们满足建立时间和保持时间的要求。如果在禁止时钟周期内给给出复位信号，必须等到允许周期到来后才会执行复位操作。当nWRST和nRRST均为低电平时，数据的输入和输出均从地址0开始</li>
<li>写操作。当写使能信号nWE为低电平时，在WCK信号的上升沿，数据通过DI7~DI0写入寄存器，参照WCK的输入周期，写入的数据必须满足建立时间和保持时间的要求。当nWE为高电平时，写操作被禁止，写地址指针停在当前位置上；当nWE再次变为低电平时，写地址指针从当前位置继续开始</li>
<li>读操作。当读使能nRE和数据输出使能nOE均为低电平时，在RCK信号的上升沿，数据由DO7~DO0输出。当nRE为高电平时，读地址指针停在当前位置上；当nRE再次变为低电平时，读地址指针从当前位置开始。执行读操作时，nOE须为低电平，如nOE为高电平，则数据输出端均为高阻态，且读地址指针任然同步加1.nRE和nOE须参照RCK的输入周期，满足建立时间和保持时间的要求。</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SD卡与文件系统]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/30/sd-card-driver/"/>
    <updated>2015-10-30T16:58:07+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/30/sd-card-driver</id>
    <content type="html"><![CDATA[<h2>Micro SD卡简介</h2>

<p><img src="http://i.imgur.com/baGsEky.jpg" alt="SD卡" /></p>

<ol>
<li>Micro SD卡的控制指令功能强大，支持SPI、SDIO模式，兼容MMC。在SPI模式下，CS/MOSI/MISO/CLK都需要加10~100K左右的上拉电阻</li>
<li>SD卡有5个寄存器

<ol>
<li>CID：128比特，卡标识寄存器,只读</li>
<li>RCA：16比特，相对卡地址寄存器，即本地系统中卡的地址，动态变化，在主机初始化的时候确定。SPI模式中没有此寄存器</li>
<li>CSD：128比特，卡描述数据，主要存储了卡的容量、数据格式、DSR寄存器是否可用、数据传输相关参数、数据传输速度、最大的数据访问时间、最大的读写数据块长度等，是可配置寄存器</li>
<li>SCR：64比特，SD配置寄存器，即SD卡特定信息数据如：SCR版本号、SD卡版本号、是否支持安全性、擦除后卡状态默认值、SD总线宽度等，由生产商在卡生产阶段写入</li>
<li>OCR：32比特，操作条件寄存器,提供SD Host查询SD卡支持的电压范围，是否是大容量卡OCR[30],卡省电过程是否结束OCR[31]</li>
</ol>
</li>
<li>每发送一个命令，SD卡都会给出一个应答，以告知主机该命令的执行情况，或者返回主机需要获取的数据。SPI模式下，SD卡针对不同的命令，应答可以是R1~R7。命令与响应都是MSB优先。除了SEND_STATUS和READ_OCR指令外，其他指令的响应格式都是R1，格式R1的长度是1Byte，并且最高位总是0，其余每位均是错误提示，在指令接收过程中发生了什么样的错误，对应的错误位就会是‘1’。R1b和R1具有相同的格式，它将伴随一个附加的busy信号，busy信号的长度可以是任意个字节，全0表示卡处在“忙”的状态。格式R2的长度为2字节，它是指令SEND_STATUS的响应，它的高字节和R1相同，低字节同样作为状态提示。格式R3的长度是5字节，它是指令READ_OCR的响应，最高字节和R1相同，其余4字节包含SD卡的OCR寄存器信息</li>
<li>在SD卡收到复位命令（CMD0）时，CS为低电平则SD卡的SPI模式被启用。不过在发送CMD0之前，要发送>74个时钟这是因为SD卡内部有一个供电电压上升时间，大概为64个CLK，剩下的10个CLK用于SD卡同步，之后才能开始CMD0的操作。在卡初始化的时候，CLK时钟最大不能超过400KHz</li>
<li>对SD卡的常用基本操作主要由：单块读、连续读、单块写、连续写。SPI模式下，通过向SD卡发送响应的命令并读取相应的响应来实现对SD卡的控制。</li>
</ol>


<h2>SD 命令</h2>

<ol>
<li>命令:每个命令都有一个起始位和结束位，总长度为48 bits，并且每个命令都有 7 bits 的CRC 校验码，高字节优先传输
<img src="http://i.imgur.com/sDb6XU5.jpg" alt="SD Command" /></li>
<li>Command 共分为12类（class0 - class11），在寄存器CSD中有12 bits CCC（Card Command Class）对本卡支持的分类进行描述
<img src="http://i.imgur.com/2QG9Ein.jpg" alt="SD命令" /></li>
<li>几个重要的命令
<img src="http://i.imgur.com/Xh1BWEV.png" alt="常用命令" /></li>
<li>CMD8命令格式
<img src="http://i.imgur.com/9oboqjq.jpg" alt="CMD8" /></li>
</ol>


<h2>SD 应答</h2>

<ol>
<li>R1响应格式
<img src="http://i.imgur.com/ZYbXuth.png" alt="R1响应格式" /></li>
</ol>


<h2>SD卡初始化</h2>

<p><img src="http://i.imgur.com/ccW4YbS.jpg" alt="SD卡初始化流程" /></p>

<ol>
<li>配置时钟，慢速一般为400Hz，设置工作模式</li>
<li>发送CMD0，对卡进行软复位，进入空闲态，该指令没有反馈</li>
<li>发送CMD8命令用于读取卡的接口信息，如果是SD2.0，则支持CMD8命令；如果是SD1.x，MMC，则不支持CMD8</li>
<li>发送CMD55+ACMD41，判断当前电压是否在卡的工作范围内，看卡能否识别命令，如果是MMC卡，则CMD55不能被识别，短反馈</li>
<li>发送CMD2，验证SD卡是否接入，长反馈</li>
<li>发送CMD3，读取SD卡的RCA地址，短反馈</li>
<li>以RCA作为参数，发送CMD9读取CSD，长反馈</li>
<li>发送CMD7，选中要操作的SD卡，短反馈</li>
<li>配置告诉时钟，准备数据传输，一般为20~25MHz</li>
<li>设置工作模式：DMA、中断或者查询模式</li>
</ol>


<h2>SD卡读取数据流程</h2>

<ol>
<li>发送CMD17</li>
<li>接收卡响应R1</li>
<li>接收数据起始令牌0xFE</li>
<li>接收数据</li>
<li>接收2字节的CRC，如果不使用CRC，这两个字节在读取后可以丢掉</li>
<li>禁止片选之后，发多8个CLK</li>
</ol>


<h2>SD卡写数据流程</h2>

<ol>
<li>发送CMD24</li>
<li>接收卡响应R1</li>
<li>发送写数据起始令牌0xFE</li>
<li>发送数据</li>
<li>发送2字节的伪CRC</li>
<li>禁止片选之后，发多8个CLK</li>
</ol>


<h2>SD卡读数据块操作</h2>

<ol>
<li>在读数据块模式下，数据传输的基本单元是数据块，它的大小在CSD中（READ_BL_LEN）定义</li>
<li>为了保证数据传输的正确，每个数据块后都有一个CRC校验码。</li>
<li>CMD17（Read_Single_Block）启动一次读数据块操作，在传输结束后返回返回到发送状态。</li>
<li>CMD18（Read_Multiple_Block）启动一次连续多个数据块的读操作</li>
<li>主机可以在多数据块读操作的任何时候终止操作，而不管操作的类型。发送停止传输命令即可终止操作</li>
<li>如果在多数据块读操作中，卡检测到错误（如越界，地址错位或内部错误），它将停止数据传输并仍处于数据状态；此时主机必须发送停止传输命令，终止操作</li>
</ol>


<h2>FATFS简介</h2>

<ol>
<li>FATFS是一个完全免费开源的FAT文件系统模块，专门为小型的嵌入式系统而设计。支持FAT12、FAT16和FAT32，支持多个存储媒介；有独立的缓冲区，可以对多个文件进行读/写。</li>
<li>拥有多种配置选项：

<ol>
<li>支持多卷（物理驱动器或分区，最多10个卷）</li>
<li>多个ANSI/OEM代码页包括DBCS</li>
<li>支持长文件名、ANSI/OEM或Unicode</li>
<li>支持RTOS</li>
<li>支持多种扇区大小</li>
<li>只读、最小化的API和I/O缓冲区等</li>
</ol>
</li>
<li>需要我们编写移植代码的是FATFS模块提供的底层接口，包括存储媒介读/写接口(disk I/O)和供给文件创建修改时间的实时时钟

<ol>
<li>ffconf.h:FATFS模块配置文件</li>
<li>ff.h:FATFS和应用模块共用的包含文件</li>
<li>ff.c:FATFS模块</li>
<li>diskio.h:FATFS和disk I/O模块共用的包含文件</li>
<li>interger.h:数据类型定义</li>
<li>option：可选的外部功能(比如支持中文等)</li>
<li>diskio.c:FATFS和disk I/O模块接口层文件</li>
</ol>
</li>
<li>ffconf.h

<ol>
<li>_CODE_PAGE,根据具体使用的而语言在ffconf.h中定义具体的宏定义。如果使用简体中文，则选择936；如果使用英文，则选择437；如果使用日文，则选择932。打开option文件夹，打开cc936.c文件，里面有一个很大的数组static const WCHAR uni2oem[]。这个数组用于unicode码和OEM码之间的相互转换。接下来又有两个函数，ff_convert()和ff_wtoupper()具体执行码型转换和将字符串转换为大写。unicode是一种双字节字符编码，无论中文还是英文，或者其他语言统一到2字节。与现有的任何编码都不兼容。WindowsNT的内核即使用该编码，所有数据进入内核前转换成UNICODE，退出内核后再转换成版本相关的编码(通常称为OEM，在简体中文下即为GB)</li>
<li>_FS_TINY，使用浓缩版的FATFS就设置为1</li>
<li>_FS_READONLY,这个用来配置是不是只读</li>
<li>_USE_STRFUNC,这个用来设置是否支持字符串类操作，比如f_putc,f_puts等</li>
<li>_USE_MKFS,这个用来设置是否使能格式化</li>
<li>_USE_FASTSEEK，这个用来使能快速定位</li>
<li>_USE_LABEL,这个用来设置是否支持磁盘盘符（磁盘名字）读取与设置</li>
<li><em>USE_LFN,该选项用于设置是否支持长文件名，还需要</em>CODE_PAGE支持，取值范围为0~3。0表示不支持长文件名，1~3是支持长文件名，但是存储地方不一样</li>
<li>_VOLUMES,用于设置FATFS支持的逻辑设备数目</li>
<li>_MAX_SS,扇区缓冲的最大值，一般设置为512</li>
</ol>
</li>
<li>ff.h中的函数定义

<ol>
<li>FRESULT f_mount (FATFS<em> fs, const TCHAR</em> path, BYTE opt);加载文件系统

<ul>
<li>fs表示文件系统对象，path表示本地设备驱动号，opt=1表示立即挂载，0表示延迟挂载</li>
</ul>
</li>
<li>FRESULT f_lseek (FIL* fp, DWORD ofs);移动文件的读写指针

<ul>
<li>ofs表示文件偏移量的数目</li>
</ul>
</li>
<li>FRESULT f_close (FIL* fp);关闭打开的文件对象</li>
<li>FRESULT f_opendir (DIR<em> dp, const TCHAR</em> path);打开目录，返回目录对象</li>
<li>FRESULT f_readdir (DIR<em> dp, FILINFO</em> fno);读取目录获得文件信息</li>
<li>FRESULT f_stat (const TCHAR<em> path, FILINFO</em> fno);读取文件的状态</li>
<li>FRESULT f_getfree (const TCHAR<em> path, DWORD</em> nclst, FATFS** fatfs);获取驱动器上的空闲簇数</li>
<li>FRESULT f_truncate (FIL* fp);截断文件</li>
<li>FRESULT f_sync (FIL* fp);刷新写文件的缓冲数据</li>
<li>FRESULT f_unlink (const TCHAR* path);删除目录中的一个文件</li>
<li>FRESULT f_mkdir (const TCHAR* path);创建一个新目录</li>
<li>FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);更改文件/目录的属性</li>
<li>FRESULT f_utime (const TCHAR<em> path, const FILINFO</em> fno);更改文件/目录的时间戳</li>
<li>FRESULT f_rename (const TCHAR<em> path_old, const TCHAR</em> path_new);重命名/移动文件或目录</li>
<li>FRESULT f_forward (FIL<em> fp, UINT(</em>func)(const BYTE<em>,UINT), UINT btf, UINT</em> bf);转发数据流</li>
<li>FRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);在驱动器上创建一个文件系统</li>
<li>FRESULT f_chdir (const TCHAR* path);改变当前目录</li>
<li>FRESULT f_chdrive (const TCHAR* path);更改当前驱动器</li>
<li>int f_putc (TCHAR c, FIL* fp);</li>
<li>int f_puts (const TCHAR<em> str, FIL</em> cp);</li>
<li>int f_printf (FIL<em> fp, const TCHAR</em> str, &hellip;);</li>
<li>TCHAR<em> f_gets (TCHAR</em> buff, int len, FIL* fp);</li>
</ol>
</li>
<li>diskio.c(需要用户提供如下几个函数接口)

<ol>
<li>DSTATUS disk_initialize (BYTE pdrv);初始化磁盘驱动器</li>
<li>DSTATUS disk_status (BYTE pdrv);获取磁盘状态</li>
<li>DRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);读扇区</li>
<li>DRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);写扇区</li>
<li>DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);设备相关的控制特性</li>
<li>get_fattime获取当前时间</li>
</ol>
</li>
<li>簇：文件数据分配的基本单位</li>
<li>FAT文件系统依次应该为:引导扇区、文件分配表两个、根目录区和数据区</li>
</ol>


<h2>汉字字库</h2>

<ol>
<li>常用的汉字内码系统有GB2312，GB13000，GBK，BIG5（繁体）等几种，其中GB2312支持的汉字仅有几千个，很多时候不够用，而GBK内码不仅完全兼容GB2312，还支持繁体字，总汉字数量达到2万多个。</li>
<li>每个GBK码由2字节组成，第一个字节为0X81~0xFE，第二个字节分为两部分，一是0x40~0x7E，二是0x80~0xFE。第一个字节代表的意义称为区，GBK里面总共有126个区，每个区内有190个汉字。</li>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FRDM_KL02Z]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/26/frdm-kl02z/"/>
    <updated>2015-10-26T15:51:29+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/26/frdm-kl02z</id>
    <content type="html"><![CDATA[<h2>FRDM_KL02Z开发板简介</h2>

<ol>
<li>MKL02Z32VFM4 MCU – 48 MHz、32 KB闪存、4 KB SRAM、32QFN</li>
<li>电容滑动触摸传感板，MMA8451Q加速度传感器，三色LED</li>
<li>新型OpenSDA调试接口：

<ol>
<li>大容量存储设备闪存编程接口(默认)；无需安装任何工具即可评估演示应用</li>
<li>P&amp;E调试接口具有运行控制调试功能并兼容IDE工具</li>
<li>CMSIS-DAP接口：面向嵌入式调试接口的ARM新标准</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[STM32_L4]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/26/stm32-l4/"/>
    <updated>2015-10-26T14:54:05+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/26/stm32-l4</id>
    <content type="html"><![CDATA[<h2>STM32L4系列超低功耗微控制器简介</h2>

<ol>
<li>最高主频80MHz，凭借带有DSP和浮点单元（FPU）的ARM® Cortex®-M4内核扩展了超低功耗产品系列及其性能。</li>
<li>提供USB（支持OTG2.0全速，LPM和BCD）</li>
<li>带有LCD驱动（4X44或8X40，带有升压转换器）</li>
<li>存储器范围可以利用SDIO、Quad SPI和FSMC接口轻松扩展</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[碎片阅读]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/18/short-news-and-knowledges/"/>
    <updated>2015-10-18T11:10:22+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/18/short-news-and-knowledges</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEO-M8N]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/16/neo-m8n/"/>
    <updated>2015-10-16T09:06:12+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/16/neo-m8n</id>
    <content type="html"><![CDATA[<h2>NEO-M8N模块</h2>

<ol>
<li>内嵌USB转串口功能</li>
<li>三维位置定位</li>
<li>测速</li>
<li>授时</li>
<li>MAXIM公司20.5dB高增益LNA芯片</li>
<li>应用场合：

<ol>
<li>语音报站</li>
<li>航模，飞控，无人机</li>
<li>同步授时</li>
<li>汽车导航</li>
</ol>
</li>
<li>接收制式：

<ol>
<li>GPS</li>
<li>GLONASS</li>
<li>Galileo</li>
<li>BeiDou</li>
<li>QZSS</li>
<li>SBAS</li>
</ol>
</li>
<li>72路接收通道</li>
<li>水平定位精度：2米（空旷地）</li>
<li>输出频率1Hz~10Hz</li>
<li>速度精度：0.1m/s</li>
<li>加速度精度：0.1m/s2</li>
<li>最大高度18000米，最大速度515m/s</li>
<li>最大加速度4g</li>
<li>基于UBX协议进行模块的配置</li>
<li>IIC接口的SDA与SCL已经内部接了上拉电阻</li>
</ol>


<h2>XH414法拉电容</h2>

<ol>
<li>参数:3.3V 0.07F</li>
<li>功能和锂电池一样，在主电源掉电的时候可以为GPS模块的RTC部分供电，以使GPS模块在下次启动时能快速搜索到卫星，一般可维持供电1小时</li>
</ol>


<h2>NMEA-0183协议</h2>

<ol>
<li>NMEA是美国国家海洋电子协会为海用电子设备指定的标准格式，目前已经成为了GPS导航设备统一的RTCM标准协议</li>
<li>NMEA-0183是一套定义接收机输出的标准信息，有几种不同的二格式，每种都是独立相关的ASCII，使用逗号隔开数据，数据流长度30-100字符不等，通常以每秒间隔选择输出，最常用的格式为“GGA”，它包含了定位时间，纬度，经度，高度，定位所用的卫星数，DOP值，差分状态和校正时段，其他的有速度，跟踪，日期等。</li>
<li>NMEA-0183常用语句格式说明：

<ol>
<li>$GPGGA:全球定位数据，最大帧长72</li>
<li>$GPGSA：卫星PRN数据，最大帧长65</li>
<li>$GPGSV：卫星状态信息，最大帧长210</li>
<li>$GPRMC：推荐最小数据，最大帧长70</li>
<li>$GPVTG：地面速度信息，最大帧长34</li>
<li>$GPGLL：大地坐标信息</li>
<li>$GPZDA：UTC时间和日期</li>
</ol>
</li>
<li>协议帧总说明：该协议采用ASCII码。帧格式形如：$aacc,dd,dd,&hellip;,ddd*hh<CR><LF>

<ol>
<li>$表示帧命令起始位</li>
<li>aaccc表示地址域，前两位是标识符，后三位为语句名</li>
<li>ddd&hellip;ddd表示数据</li>
<li>*表示校验和前缀</li>
<li>hh表示校验和，$与*之间所有字符ASCII码的校验和(各字节做异或运算，得到校验和后，再转换16进制格式的ASCII字符)</li>
<li><CR><LF>表示回车和换行</li>
</ol>
</li>
<li>GPGGA：GPS固定数据输出语句

<ol>
<li>格式：$GPGGA,<1>,<2>,<3>,<4>,<5>,<6>,<7>,<8>,<9>,<10>,<11>,<12>,<13>,<14>*<15><CR><LF></li>
<li>例子：$GPGGA,092725.00,4717.11399,N,00833.91590,E,1,8,1.01,499.6,M,48.0,M,,0*5B</li>
<li><1>UTC时间，格式为hhmmss.sss</li>
<li><2>纬度，格式ddmm.mmmm</li>
<li><3>纬度半球，N或者S</li>
<li><4>经度，格式ddmm.mmmm</li>
<li><5>经度半球，E或W</li>
<li><6>定位质量指标，0=定位无效，1=标准定位，2=差分定位，6=估算</li>
<li><7>使用卫星数量，从00到12</li>
<li><8>水平精确度，0.5到99.9</li>
<li><9>天线离海平面的高度，-9999.9到9999.9米</li>
<li><10>高度单位，M表示单位米</li>
<li><11>大地椭球面相对海平面的高度</li>
<li><12>高度单位，M表示单位米</li>
<li><13>差分GPS数据期限（RTCM SC-104），最后设立RTCM传送的秒数量</li>
<li><14>差分参考基站标号，从0000到1023</li>
<li><15>校验和</li>
</ol>
</li>
<li>GPGSA：GPS精度指针及使用卫星

<ol>
<li>格式：$GPGSA,<1>,<2>,<3>,<4>,<5>,<6>,<7>,<8>,<9>,<10>,<11>,<12>,<13>,<14>,<15>,<16>,<17>*<18><CR><LF></li>
<li>例子：$GPGSA,A,3,23,29,07,08,09,18,26,28,,,,,1.94,1.18,1.54*0D</li>
<li><1>模式2：M=手动，A=自动</li>
<li><2>模式1：定位型式1=未定位，2=二维定位，3=三维定位</li>
<li><3>第1信道正在使用的卫星PRN码编号(Pseudo Random Noise，伪随机噪声吗)，01至32</li>
<li><4> 第2信道正在使用的卫星PRN码编号</li>
<li><5> 第3信道正在使用的卫星PRN码编号</li>
<li><6> 第4信道正在使用的卫星PRN码编号</li>
<li><7> 第5信道正在使用的卫星PRN码编号</li>
<li><8> 第6信道正在使用的卫星PRN码编号</li>
<li><9> 第7信道正在使用的卫星PRN码编号</li>
<li><10> 第8信道正在使用的卫星PRN码编号</li>
<li><11> 第9信道正在使用的卫星PRN码编号</li>
<li><12> 第10信道正在使用的卫星PRN码编号</li>
<li><13> 第11信道正在使用的卫星PRN码编号</li>
<li><14> 第12信道正在使用的卫星PRN码编号</li>
<li><15> PDOP综合位置精度因子（0.5 - 99.9）</li>
<li><16> HDOP水平精度因子（0.5 - 99.9）</li>
<li><17> VDOP垂直精度因子（0.5 - 99.9）</li>
<li><18> 校验和</li>
</ol>
</li>
<li>GPGSV：可视卫星状态输出语句

<ol>
<li>格式：：$GPGSV, <1>,<2>,<3>,<4>,<5>,<6>,<7>,&hellip;,<4>,<5>,<6>,<7>*<8><CR><LF></li>
<li>例子：$GPGSV,3,1,10,23,38,230,44,29,71,156,47,07,29,116,41,08,09,081,36*7F</li>
<li><1> 总的GSV语句电文数</li>
<li><2> 当前GSV语句号</li>
<li><3> 可视卫星总数，00至12</li>
<li><4> 卫星编号，01至32</li>
<li><5> 卫星仰角，00至90度</li>
<li><6> 卫星方位角，000至359度。实际值</li>
<li><7> 信噪比（C/No），00至99dB；无表示未接收到讯号</li>
<li><8> 校验和。</li>
<li>每条语句最多包括四颗卫星的信息，每颗卫星的信息有四个数据项，即：卫星编号，卫星仰角，卫星方位角，信噪比</li>
</ol>
</li>
<li>GPRMC：推荐最小数据量的GPS信息

<ol>
<li>格式：$GPRMC,<1>,<2>,<3>,<4>,<5>,<6>,<7>,<8>,<9>,<10>,<11>,<12>*<13><CR><LF></li>
<li>例子：$GPRMC,083559.00,A,4717.11437,N,00833.91522,E,0.004,77.52,091202,,,A*57</li>
<li><1> UTC（Coordinated Universal Time）时间，hhmmss（时分秒）格式</li>
<li><2> 定位状态，A=有效定位，V=无效定位</li>
<li><3> Latitude，纬度ddmm.mmmm（度分）格式（前导位数不足则补0）</li>
<li><4> 纬度半球N（北半球）或S（南半球）</li>
<li><5> Longitude，经度dddmm.mmmm（度分）格式（前导位数不足则补0</li>
<li><6> 经度半球E（东经）或W（西经）</li>
<li><7> 地面速率（000.0~999.9节，Knot，前导位数不足则补0）</li>
<li><8> 地面航向（000.0~359.9度，以真北为参考基准，前导位数不足则补0）</li>
<li><9> UTC日期，ddmmyy（日月年）格式</li>
<li><10> Magnetic Variation，磁偏角（000.0~180.0度，前导位数不足则补0）</li>
<li><11> Declination，磁偏角方向，E（东）或W（西）</li>
<li><12> Mode Indicator，模式指示（仅NMEA0183 3.00版本输出，A=自主定位，D=差分，E=估算，N=数据无效）</li>
<li><13> 校验和。</li>
</ol>
</li>
<li>GPVTG：地面速度信息

<ol>
<li>格式：$GPVTG,<1>,<2>,<3>,<4>,<5>,<6>,<7>,<8>,<9>*<10><CR><LF></li>
<li>例子：$GPVTG,77.52,T,,M,0.004,N,0.008,K,A*06</li>
<li><1> 以真北为参考基准的地面航向</li>
<li><2> T，表示“真”</li>
<li><3> 以磁北为参考基准的地面航向</li>
<li><4> M，表示“磁场”</li>
<li><5> 地面速率</li>
<li><6> N，表示“节”</li>
<li><7> 地面速率</li>
<li><8> K，表示“千米/小时”</li>
<li><9> 模式指示（A=自主定位，D=差分，E=估算，N=数据无效）</li>
<li><10> 校验和</li>
</ol>
</li>
<li>GPGLL：定位地理信息

<ol>
<li>格式：$GPGLL,<1>,<2>,<3>,<4>,<5>,<6>,<7>*<8><CR><LF></li>
<li>例子：$GPGLL,4717.11364,N,00833.91565,E,092321.00,A,A*60</li>
<li><1> 纬度 ddmm.mmmmm（度分）</li>
<li><2> 纬度半球 N（北半球）或 S（南半球）</li>
<li><3> 经度 dddmm.mmmmm（度分）</li>
<li><4> 经度半球 E（东经）或 W（西经）</li>
<li><5> UTC 时间：hhmmss（时分秒）</li>
<li><6> 定位状态，A=有效定位，V=无效定位</li>
<li><7> 模式指示（A=自主定位，D=差分，E=估算，N=数据无效）</li>
<li><8> 校验和</li>
</ol>
</li>
<li>GPZDA：当前时间信息

<ol>
<li>格式：$GPZDA,<1>,<2>,<3>,<4>,<5>,<6>*<7><CR><LF></li>
<li>例子：$GPZDA,082710.00,16,09,2002,00,00*64</li>
<li><1> UTC 时间：hhmmss（时分秒，格林威治时间）</li>
<li><2> 日</li>
<li><3> 月</li>
<li><4> 年</li>
<li><5> 本地区域小时（NEO-6M 不支持，为 00）</li>
<li><6> 本地区域分钟（NEO-6M不支持，为 00）</li>
<li><7> 校验和</li>
</ol>
</li>
</ol>


<h2>NMEA解码库</h2>

<ol>
<li><a href="http://nmea.sourceforge.net/">下载地址</a></li>
<li>支持解析GPGGA，GPGSA，GPGSV，GPRMC，GPVTG这五种语句，解析得到的GPS数据信息以结构体存储，附加地理学相关功能，可支持导航等数据工作，除了解析NMEA语句，它还可以根据随机数产生NMEA语句，方便模拟</li>
<li>结构体：

<ol>
<li>nmeaINFO：保存GPS解码后得到的信息,结构成员介绍

<ol>
<li>smask（int类型）接收到的GPS信息包类型</li>
<li>utc（nmeaTIME结构）包含年、月、日、时、分、秒信息，格林威治时间</li>
<li>sig（int类型）定位质量，0-无效，1-标准定位，2-差分定位</li>
<li>fix（int类型）导航模式，1-无效，2-2D,3-3D</li>
<li>PDOP（double类型）位置精度因子</li>
<li>HDOP（double类型）水平精度因子</li>
<li>VDOP（double类型）垂直精度因子</li>
<li>lat（double类型）纬度</li>
<li>lon（double类型）经度</li>
<li>elv（double类型）海拔，单位m</li>
<li>speed（double类型）速度，单位km/h</li>
<li>direction（double类型）航向，单位：度2</li>
<li>satinfo（nameSATINFO结构）包含了可见卫星，正在使用的卫星，卫星信号等信息</li>
</ol>
</li>
<li>nmeaPARSER：解码时使用的缓冲区数据结构。它是一个链表，在解码时，NMEA库会把输入的GPS原始数据压入到nmeaPARSE结构的链表中</li>
</ol>
</li>
<li>函数：

<ol>
<li>nmea_zero_INFO(&amp;info);初始化解码后的数据</li>
<li>nmea_parse_init(&amp;parser);初始化解析使用的数据结构</li>
<li>nmea_parse(&amp;parser,&amp;buff[0],size,&amp;info);</li>
<li>GMTconvert(&amp;info.utc,&amp;beiJingTime,8,1);</li>
<li>nmea_parser_destory(&amp;parser);释放GPS数据结构</li>
</ol>
</li>
</ol>


<h2>u-center软件</h2>

<ol>
<li>具有配置模块工作方式的功能，方便开发调试</li>
<li>对GPS模块进行性能测试</li>
<li>更新GPS模块固件</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微纳加工技术]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/11/micro-fabrication/"/>
    <updated>2015-10-11T16:59:33+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/11/micro-fabrication</id>
    <content type="html"><![CDATA[<h2>信息时代</h2>

<ol>
<li>微电子产业是信息时代的基础</li>
<li>基于硅的晶体管是最基本的信息载体</li>
<li>以硅/半导体为基础的微纳加工技术是信息时代的材料技术基础</li>
</ol>


<h2>IC制造高度专业化</h2>

<ul>
<li>设计->制造->测试->封装</li>
</ul>


<h2>芯片制造工艺</h2>

<ul>
<li>芯片制造工艺是指由“硅片”到“集成电路结构晶圆”之间的工艺步骤</li>
</ul>


<h2>二氧化硅在半导体制造中的作用以原因</h2>

<ol>
<li>作用

<ol>
<li>层间隔离</li>
<li>器件隔离</li>
<li>屏蔽层</li>
</ol>
</li>
<li>原因

<ol>
<li>电阻率高，大于10MΩ·cm</li>
<li>击穿场强大，大于10MV/cm</li>
<li>禁带宽度较宽，越9eV</li>
</ol>
</li>
</ol>


<h2>微纳加工技术的使用场合</h2>

<ol>
<li>集成电路领域</li>
<li>MEMS传感器（如用在投影机里面的DLP芯片)</li>
<li>医疗微电子（如使用带摄像头的胶囊来看人体内的情况，通过一个微系统控制药释放的速度）</li>
<li>平板显示行业</li>
<li>太阳能电池行业</li>
</ol>


<h2>微纳加工技术的特点</h2>

<ol>
<li>资本密集。超净间和设备需要大量资金投入</li>
<li>分批工艺。单个晶元上有上亿的晶体管</li>
<li>杰出的可生产性。良率控制在95%以上,可靠性强（寿命要求不小于10年）</li>
<li>随着产品更新换代，成本更加低</li>
<li>技术渗透性强。集成电路，MEMS，太阳能电池，平板显示器，医疗微电子等领域都离不开微纳加工技术</li>
</ol>


<h2>微纳加工技术中选择Si作为常用材料的原因</h2>

<ol>
<li>Si是人类能做的最纯净、没有缺陷、最完美的材料</li>
<li>Si资源丰富，是地壳中第二大丰富的化学元素</li>
<li>Si形成的SiO2界面性好，Si材料提供了可控、稳定且可重复生产的表面SiO2钝化层，从而使现代集成电路技术真正可以实现</li>
<li>在众多半导体中，Si是唯一能够通过氧化形成稳定绝缘层的材料</li>
</ol>


<h2>集成电路发展历程</h2>

<ol>
<li>历史上第一个晶体管(点接触)是1947年在美国贝尔实验室研制出来；1956年获得了诺贝尔奖，发明人是：威廉·肖克利，约翰·巴丁和沃尔特·布拉顿</li>
<li>1949年第一个面结型晶体管诞生</li>
<li>1958年第一个集成电路只有一个晶体管加3个电阻和1个电容,基片用的材质是锗；获得了2000年的诺贝尔奖；器件之间的连线就是简单的用焊接实现的</li>
<li>1959第一个硅基集成电路实现，也只有4个晶体管加2个电阻</li>
<li>1960年平面工艺技术诞生,塑造了现代IC制造的基本特征</li>
<li>1960年MOSFET诞生，从此MOSFET成为成为构建集成电路的主要器件。相对于BJT，MOS具有更高的集成密度，更低的功耗以及更好的电路设计灵活性</li>
</ol>


<h2>平面工艺</h2>

<ol>
<li>定义：在Si半导体上通过氧化、光刻、扩散、离子注入等一系列流程，制作出晶体管和集成电路的工艺；器件和电路都是在芯片表面一层附近处，整个芯片基本上保持是平坦的</li>
<li>特征：批量生产，成本低廉</li>
</ol>


<h2>摩尔定律</h2>

<ol>
<li>当价格不变时，集成电路上晶体管的数目，约每隔18~24个月便会增加一倍，性能也将提升一倍</li>
<li>摩尔定律是一个<strong>经济学定律</strong></li>
<li>在摩尔定律下，新一代产品的的体积缩小30%(实现相同功能的前提下)，晶体管密度增加一倍，开关管开关速度增加0.5倍，功耗降低，成本降低，功能增加</li>
<li>More than Moore&rsquo;s Law(MtM):更加注重系统集成而不是增加晶体管数量</li>
<li>SoC(System on Chip)片上系统;SiP(System in Package)系统级封装</li>
<li>特征尺寸每两年缩小0.7倍，0.7≈1/根号二</li>
</ol>


<h2>微电子工艺综述</h2>

<ol>
<li>微纳加工工艺技术分类：

<ol>
<li>光刻：在硅片上图上光刻胶，然后通过曝光显影的办法把集成电路版图投影到硅片上的光刻胶上</li>
<li>刻蚀:除去裸露部分的硅或者介质材料，从而把光刻胶上的图形转移到硅片上，具体工艺手段分为：

<ol>
<li>湿法腐蚀</li>
<li>干法刻蚀</li>
</ol>
</li>
<li>掺杂：分为离子注入和热扩散</li>
<li>热处理：包括热氧化来制备介质膜，杂质的热扩散，离子注入后的热退火以及硅化物形成过程中的热处理</li>
<li>介质膜的沉积：微电子器件和集成电路中需要大量的各种介质层和隔离结构，制作方法是化学气相沉积(CVD)</li>
<li>化学机械抛光（CMP）：这是一种平坦化的技术，在现代集成电路的布线中，也用它来做图形加工，就是所谓的大马士革工艺</li>
<li>金属化：形成器件的引出电极以及电路的互连线，实现手段主要是：溅射和电镀</li>
</ol>
</li>
<li>加工步骤：
<img src="http://i.imgur.com/Frmykaj.png" alt="加工步骤" />

<ul>
<li>通过氧化，在晶元上长一层很厚的氧化层（场氧化层），这个氧化就是得到二氧化硅材料</li>
<li>旋转涂胶的方法涂上一层光刻胶，光刻胶是一种有机物，起到图形转移的作用</li>
<li>曝光，激光通过掩膜版，将图形照到了光刻胶上</li>
<li>显影，将已经曝光的光刻胶移除</li>
<li>刻蚀，将没有光刻胶保护的二氧化硅的部分移出</li>
<li>将光刻胶移出</li>
<li>再一次进行氧化，生长出高质量的栅极介质氧化层，也是二氧化硅</li>
<li>沉淀一层多晶硅材料</li>
<li>图形化方式将栅极图形转移到删介质层的二氧化硅上面</li>
<li>通过离子注入的方式将掺杂给加入进去</li>
<li>沉积氮化硅</li>
<li>包含了接触口的图形化</li>
</ul>
</li>
<li>在集成电路工艺制备过程中，就是加材料，图形化，减材料的过程不断循环，在每一循环中，后一次的图形需要和前一次的图形对准</li>
</ol>


<h2>超净间简介</h2>

<ol>
<li>为了保证零缺陷需要：避免引入颗粒，避免金属离子；颗粒引起成品率和可靠性问题，金属离子沾污会引起电性能和可靠性问题</li>
<li>超净间的净化级别：典型的IC Fab为光刻10级（每立方英尺中直径超过0.5um的颗粒不大于10个），其它工艺操作区为100级，“灰区”为1000级或者10000级</li>
<li>0.1~0.3um的颗粒最棘手：更大的颗粒容易沉淀，更小的颗粒容易凝结到更大的颗粒中</li>
<li>人员是一个重要的污染源，所以应当尽量采用SMIF(Standard Mechanical interface)和自动传输系统

<ul>
<li>SMIF是一个具有标准接口的盒子，可以与各个工艺设备来对接</li>
</ul>
</li>
<li>人员需要穿戴特制的超净服，经过封磷才能进入超净间</li>
<li>超纯水：IC制造中用的超纯水电阻率必须超过18MΩ·cm，制备过程包括多级数值过滤以及反渗透离子过滤；超纯水的输运需要通过特殊的聚四氟管道进行</li>
<li>标准的硅片的清洗流程叫做RCA清洗

<ol>
<li>浓硫酸+双氧水去除有机物，H2SO4碳化有机物，H2O2使C氧化成CO2</li>
<li>氢氟酸去除二氧化硅</li>
<li>氨水+双氧水去除可能的重金属离子沾污</li>
<li>盐酸去除碱金属离子沾污</li>
<li>超纯水漂洗</li>
</ol>
</li>
<li>超净间净化级别（最新的级别定义规范是Fed.Std.209E）

<ol>
<li>英制： CLASS（X）：单位立方英尺中的空气中，直径超过0.5um的颗粒不超过X个，1英尺=12英寸=30.48厘米</li>
<li>公制： M(X):单位立方米的空气中，直径超过0.5um的颗粒不超过10<sup>M</sup>个</li>
</ol>
</li>
<li>超净间的“无尘”的原因：

<ol>
<li>层层筛选滤除空气中的颗粒物，大颗粒使用超细纤维过滤，小颗粒使用静电吸附</li>
<li>空气流动采用层流的方式</li>
<li>设备使用无尘的材料制造</li>
<li>晶元在迷你工作台之间转移使用SMIF</li>
</ol>
</li>
<li>超净间温度要求：20~22℃，湿度要求：40~46%RH</li>
<li>超净间着装要求：

<ol>
<li>佩戴帽子，护目镜，面罩，手套，超净服和靴子</li>
<li>超净服由合成纤维制作，里面有一层是聚四氟乙烯材料。超净服是导电的，因此不会积累电荷产生静电发电或者吸附颗粒</li>
</ol>
</li>
</ol>


<h2>集成电路工艺用到的材料</h2>

<ol>
<li>单晶材料：结构晶体内部的微粒在三维空间呈有规律地，周期性的排列。整个晶体中质点在空间的排列短程有序，而且长程有序。单晶整个晶格是连续的</li>
<li>多晶材料：多晶是众多取向晶体的单晶的集合，短程有序，长程无序</li>
<li>非晶材料：短程长程均无序</li>
</ol>


<h2>单晶硅的特性及生长方法</h2>

<ol>
<li>熔融的单质硅在凝固时，硅原子以金刚石晶格结构，排列成许多晶核，如果这些晶核长成晶面取向相同的晶粒，则这些晶粒平行结合起来便结晶成单晶硅。单晶硅具有准金属的物理特性，有较弱的导电性，其电导率随温度升高而增加</li>
<li>单晶硅英文：Monocrystallinesilicon/Single Crystal Silicon</li>
<li>制备单晶硅的原材料是高纯度的多晶硅材料</li>
<li>多晶硅原料的制备：

<ol>
<li>从石英砂中提炼冶金级硅（纯度98%）</li>
<li>用冶金级的硅粉提炼电子级的硅（纯度9~11个“9”）</li>
</ol>
</li>
<li>单晶硅的生长：

<ol>
<li>直拉法（CZ）（生长单晶硅的棒材），切克劳斯基发明，

<ul>
<li>在一个直筒型的热系统里面，用石墨电阻加热，将装在高纯度石英坩埚中的多晶硅熔化，然后将籽晶插入熔体表面进行熔接，同时转动籽晶，再反转坩埚，籽晶缓慢向上提升，经过引晶，放大，转肩，等径生长，收尾等过程，一支单晶硅就能生长出来</li>
</ul>
</li>
<li>区熔法（FZ）（生长单晶硅的棒材）</li>
<li>外延法（生长单晶硅薄膜）</li>
</ol>
</li>
<li>在集成电路中主要用的是CZ的抛光片或者是外延片</li>
<li>直拉法生长机理：

<ol>
<li>可生产大直径单晶，是目前IC用Si单晶的主流拉制方法</li>
<li>将电子级多晶硅原料在石英坩埚中加温至Si的熔点以上使其熔化，“拉制”是溶液在籽晶上冷凝并规则排布的过程，采用单晶籽晶作为起始材料，籽晶的晶向决定着所拉出单晶的晶向</li>
<li>核心问题是温度场的控制，拉晶速度决定了单晶棒的直径，而单晶的晶格完整性，掺杂均匀性等也主要由冷凝过程的温度分布决定</li>
<li>直拉法中晶体在熔体表面处生长，而不与坩埚相接触，这样能显著地减小晶体的应力，并防止锅壁的寄生成核</li>
<li>高温下石英晶坩埚中的O、C等杂质会进入Si溶液，如何处理这些杂质也是一个关键问题</li>
</ol>
</li>
<li>单晶硅棒通过切片得到硅片，硅片尺寸一般有4寸，6寸，8寸或者12寸，通过化学机械抛光磨平表面，再在化学溶液中腐蚀，获得表面非常光整的单晶硅片（厚度约0.5mm，直径约300mm）</li>
<li>几种常见的半导体化学性质比较

<ol>
<li>禁带宽度：GaAs(砷化镓)>Si>Ge,因此Si的PN结反向电流比Ge小</li>
<li>禁带类型，Si和Ge都是间接带隙，GaAs是直接带隙，因此光电器件采用GaAs</li>
<li>电子迁移率：Si&lt;Ge&lt;GaAs,因此Si不适于在高频下工作，高频高速以及微波器件多采用GaAs</li>
</ol>
</li>
</ol>


<h2>集成电路和其它微结构器件中需要多种多样的薄膜</h2>

<ol>
<li>介质膜：高质量的超薄氧化层薄膜，绝缘性能好，包括MOS器件的栅氧化薄膜

<ol>
<li>超薄，1~3nm；很低的界面态；很好的绝缘性，约9eV bandgap，击穿场强需要7~15MV/cm；能够阻止硼（B）穿过</li>
<li>包括高质量超薄介质层和低热预算介质薄膜</li>
<li>制备技术：

<ol>
<li>热氧化和ALD(Atomic Layer Deposition，原子级沉积)技术</li>
<li>CVD(Chemical Vapor Deposition)技术：在器件形成或者金属互联之后淀积介质膜，要求低的热预算（thermal budget，温度与时间的乘积），使得在淀积薄膜的工艺下，不对已经形成的器件的杂质分布或者已经形成的金属互联网络产生不好的影响</li>
</ol>
</li>
<li>氧化的速率受温度和氧化时间的影响很大。当氧气浓度很丰富时，二氧化硅的生长速度由硅键断裂速度决定，而此过程大部分取决于温度的高低。为了得到致密的氧化层，必须使反应炉内的温度保持恒定</li>
<li>二氧化硅在整个工艺流程中多次用来作为硅衬底保护层和连个电极之间的隔离层</li>
<li>氮化硅非常致密并且比其他材料更能抵抗杂质扩散</li>
</ol>
</li>
<li>金属膜

<ol>
<li>布线层数和总长度：10层布线，最细线宽在45nm左右，而布线总长度可达到5公里量级</li>
<li>包括用于金属半导体接触的和用于金属互联网络的</li>
<li>制备技术：

<ol>
<li>溅射，蒸发，电镀</li>
</ol>
</li>
</ol>
</li>
<li>单晶态的半导体薄膜

<ol>
<li>制备技术：外延</li>
</ol>
</li>
<li>为了满足不同的应用场景的要求，对薄膜的要求也是不同的，制备技术的选择和优化要针对应用的需求：应力，附着性，化学稳定性，化学腐蚀的选择性和可加工性，保角性(conformation)

<ol>
<li>保角性：在图形的面上，沉积的速度大致相同</li>
</ol>
</li>
<li>二氧化硅的应用

<ol>
<li>在MOSFET中

<ol>
<li>栅极氧化</li>
<li>绝缘层</li>
<li>钝化层</li>
</ol>
</li>
<li>在IC中

<ol>
<li>器件隔离</li>
<li>层间介质</li>
<li>掩蔽层</li>
</ol>
</li>
</ol>
</li>
<li>IC中使用的SiO2是非晶体，即短程无序，长程也无序。晶体二氧化硅的密度2.65g/cm3,非晶体二氧化硅的密度2.2g/cm3</li>
</ol>


<h2>ALD(Atomic layer deposition)原子层沉积</h2>

<ol>
<li>原子层沉积是一种可以将物质以单原子膜形式一层一层的镀在基底表面的方法</li>
<li>通常用来制作MOS器件的栅氧化层(又薄质量又高的氧化层)</li>
<li>不是靠衬底（Si）氧化，而是靠化学气相沉积，可用于制备非SiO2系列的high-k(高介电常数)介质</li>
</ol>


<h2>热氧化过程</h2>

<ol>
<li>氧化气氛

<ol>
<li>干氧：O2;干氧能够提供更好的氧化质量和Si/SiO2界面，良好的界面性使得Si超越别的半导体材料，成为半导体工艺中最受欢迎的一种</li>
<li>湿氧：O2和H2O；需要注意，水汽在二氧化硅中的扩散速度远远大于氧气在二氧化硅中的扩散速度，可以形成厚的氧化层</li>
<li>其他添加元素：H（H2），Cl（TCA或者TCE），N（NH3或者N2O）。其中含氯氧化目的在于去除金属离子</li>
<li>实际生产中会采用dry-wet-dry-anneal的组合形式来进行氧化。anneal即退火，可以促进原子重排，将未反应的Si离子氧化，并减少界面缺陷</li>
</ol>
</li>
<li><img src="http://i.imgur.com/oqKEncN.png" alt="热氧化过程" /></li>
<li>Deal-Grove模型
<img src="http://i.imgur.com/KaExFIC.png" alt="Deal-Grove" /></li>
<li>氧化工艺中应注意的其他问题：

<ol>
<li>Na、K等碱金属离子在SiO2中是块扩散杂质，将在SiO2中起移动电荷作用，引起MOS器件阈值电压漂移。因此要严格栅氧化前的硅片清洗和氧化环节的污染控制。氧化气氛中通少量HCl气氛也是控制金属离子沾污的一个办法</li>
<li>Si/SiO2界面的缺陷将成为MOS器件栅下的界面态，也会引起MOS器件阈值电压漂移。需要优化氧化前的硅片表面处理，优化氧化工艺，尽量减少Si/SiO2界面缺陷</li>
<li>后续的家文过程中可能会引起多晶硅删中的B参杂穿透SiO2层进入沟道（B在SiO2中是快扩散杂质），从而改变沟道内的杂质分布；应对办法：提高SiO2的致密性，如采用氧化时加少量NO，形成更致密的SiON；采用尽可能厚的栅介质；不采用参杂的多晶硅栅</li>
</ol>
</li>
<li>氧化层质量的影响因素：

<ol>
<li>衬底洁净度</li>
<li>气体的纯净度</li>
<li>氧化过程</li>
</ol>
</li>
<li>反应扩散模型，可以有效解释氧化膜厚度大于20nm的时候，超薄氧化层不适用此模型，如栅氧
<img src="http://i.imgur.com/FAQ8O9b.png" alt="基础公式" />
<img src="http://i.imgur.com/uMbHfM7.png" alt="反应扩散模型" />

<ol>
<li>氧化层很薄的时候，氧化速率由反应速率控制；氧化层很厚的时候，氧化速率由扩散速率控制</li>
<li>k是反应速率常数，D是扩散系数，C0是氧化剂在SiO2中的固溶度，N是单位体积二氧化硅中氧分子数，x0表示t=0时刻氧化膜厚度。其中k，D和C0均与温度有关，C0还与压强有关，可以增大压强提高C0</li>
</ol>
</li>
<li>影响氧化反应速率的因素：

<ol>
<li>温度</li>
<li>压强</li>
<li>重掺杂削弱Si-Si键，提高了反应速率</li>
<li>含氯氧化，cl能与绝大多数金属反应，生成的氯化物易挥发，提高了反应质量。反应副产品H2O的加入加快了反应速率</li>
<li>不同的晶向反应速率不同，原因在于晶面之间的距离不同，111面最快，100面最慢</li>
</ol>
</li>
</ol>


<h2>干氧湿氧法的特点及原因</h2>

<ol>
<li>干氧：氧化层质量高，Si/SiO2界面特性更好，但是反应速率较慢</li>
<li>湿氧：氧化层较稀疏，通常适合生长较厚的氧化层，反应速率较快</li>
<li>原因：水分子比氧分子小，更容易在SiO2中扩散，水分子在SiO2中的溶解度大于氧分子</li>
</ol>


<h2>RTO（Rapid Thermal Oxidation）</h2>

<ol>
<li>超薄氧化膜（如栅极氧化膜）在低温或者低压下很难操控 ，不易生长</li>
<li>RTO技术能够生长1.8nm的氧化膜，氧化硅片的使用高功率的碘钨灯加热硅片以降低Thermal Budget，反应温度在1000℃左右，反应时间是毫秒级，更高的反应温度能够生长高质量的薄膜。RTO工艺只能单片操作，但是每一片消耗的时间很短。RTO技术的缺点在于，温度均匀性很难保证</li>
</ol>


<h2>Si/SiO2表面的杂质分离</h2>

<p><img src="http://i.imgur.com/xYRtMeX.png" alt="分离系数" /></p>

<ol>
<li>参杂的硅片在氧化和退火过程中，杂质会重分布，因为杂质在Si和SiO2中的平衡浓度不同</li>
<li>氧化过程中，新生长的SiO2会吸引受体，如硼（B），并且排斥施主，如磷（P）和砷（As）</li>
<li>杂质在SiO2中没有电学活性</li>
</ol>


<h2>热氧化前的清洗</h2>

<ol>
<li>SC1标准清洗，去除有机物和金属，使用氨水，80摄氏度</li>
<li>SC2标准清洗，去除离子，使用盐酸，80摄氏度</li>
<li>自然氧化层去除，使用HF，室温，几十秒时间就完成</li>
<li>评估清洗干净的标准是检测清洗后的水的电阻率是否超过18MΩ·cm</li>
</ol>


<h2>Si/SiO2氧化层电荷</h2>

<ol>
<li>评价界面的好坏

<ol>
<li>氧化层中的电荷越少越好</li>
<li>界面缺陷越少越好，即界面上Si的断键（悬挂键）越少越好</li>
</ol>
</li>
<li>可移动离子

<ol>
<li>阳离子Na会在氧化层中移动</li>
<li>氧化前的清洗非常重要，可以减少离子污染</li>
</ol>
</li>
<li>固定氧化电荷

<ol>
<li>在Si片表面的传输去区域由于最后停止O的输送导致Si与O没有形成完全的Si-O键（未完成的氧化反应）</li>
<li>可以通过后续的退火进行原子重排来减少，但是无法避免，因为与工艺相关</li>
</ol>
</li>
<li>氧化层内部残留电荷

<ol>
<li>由非桥氧所致，可正可负</li>
</ol>
</li>
<li>表面残留电荷

<ol>
<li>Si/SiO2表面原子级突变，形成缺陷</li>
<li>晶格不对齐导致的悬挂键</li>
<li>可以通入H2与Si形成Si-H键来降低缺陷态，但是不如Si-O稳定，在高压大电流，有应力的情况下，Si-H键容易断裂，影响器件特性</li>
</ol>
</li>
</ol>


<h2>LOCOS &amp; STI</h2>

<ol>
<li>LOCOS（Local Oxidation of Silicon，局部氧化隔离）是硅的选择性氧化，SiN作为扩散掩膜层，绝大多数分子很难扩散穿过SiN。先在有源区覆盖一层SiN，接着在暴露的隔离区通过湿氧氧化生长一层较厚的氧化层，最后去除SiN层，形成有源区，在有源区中制作器件。</li>
<li>SiN可以防止O2或者H2O扩散至底层与Si发生氧化反应，但是SiN无法防止气体从侧面扩散，导致横向氧化，因此会形成鸟嘴（bird&rsquo;s beak），鸟嘴处应力较大，易形成缺陷</li>
<li>STI即浅沟槽隔离，先淀积氧化硅，然后在隔离区腐蚀出一定深度的沟槽，再进行侧墙氧化，用CVD的方法在沟槽中淀积SiO2，最后通过CMP法平坦化，形成沟槽隔离区和有源区。与LOCOS相比较，更有效地隔离了器件，表面非常平坦，有利于下一代工艺的加工。但是STI工艺贵且复杂
<img src="http://i.imgur.com/kTy6eoo.png" alt="LOCOS" /></li>
</ol>


<h2>氧化膜厚度测量</h2>

<ol>
<li>椭偏仪，可以同时测量厚度与折射率，精度达到1nm，原理是光的偏振，可以测量介质膜</li>
<li>台阶仪，可以测量多种膜，但是需要 先刻蚀出一个台阶</li>
</ol>


<h2>外延</h2>

<ol>
<li>一种特殊的CVD过程三种外延过程，淀积产物呈单晶状态
<img src="http://i.imgur.com/Ce3SGrT.png" alt="外延技术" /></li>
<li>为了形成单晶，外延与普通CVD有两点主要不同：

<ol>
<li>衬底界面处理更加苛刻，需要利用衬底的晶格来引导薄膜的单晶生长</li>
<li>生长温度比普通CVD高很多</li>
</ol>
</li>
<li>典型应用：

<ol>
<li>功率器件：功率器件中耐压较高的器件需要在高阻的半导体上制备，同时为了使整体串联电阻很小，衬底需要低阻。整个wafer的上面是低参杂，下面高参杂，而且低参杂的厚度很厚，达到几十微米</li>
<li>改变硅的晶格常数，制备高迁移率应变沟道</li>
</ol>
</li>
</ol>


<h2>溅射、蒸发和电镀（制备金属薄膜）</h2>

<ol>
<li>集成电路对金属化的主要要求：

<ol>
<li>金属与半导体接触

<ol>
<li>肖特基接触</li>
<li>欧姆接触

<ol>
<li>高参杂后利用遂穿机制形成欧姆接触</li>
<li>硅化物的使用。在金属与半导体接触时，通常使用硅化物来作为接触层，避免金属和硅化物的共融体。主要采用钛硅化物，钴硅化物，镍硅化物</li>
</ol>
</li>
</ol>
</li>
<li>金属作为互连线。Al是目前集成电路工艺中最常用的金属链接材料，电阻率较低，工艺简单，易形成欧姆接触。但是铝容易形成电迁徙（高电流密度引发的电子风造成电迁徙），而且铝的RC延迟比较大。目前金属互联正从铝互联转向铜互联。但是铜的刻蚀比较困难，需要采用大马士革工艺。此外，为了简化工艺，在一些短距离的“局部互连”常使用多晶硅和硅化物。

<ol>
<li>有良好的导电性</li>
<li>容易与N型、P型硅形成低阻欧姆接触</li>
<li>与硅和二氧化硅等有良好的粘附性</li>
<li>易于淀积和刻蚀，便于键合</li>
<li>性能稳定可靠</li>
<li>互连线对台阶的覆盖性要好</li>
</ol>
</li>
</ol>
</li>
<li>蒸发：不易制备合金的膜</li>
<li>溅射（PVD）：可以制备合金膜，粘附性好，但是台阶覆盖性不太好
<img src="http://i.imgur.com/yaveWue.png" alt="溅射" /></li>
<li>电镀：台阶覆盖性最好</li>
<li>典型的金属化应用场合总结
<img src="http://i.imgur.com/Car7nUY.png" alt="金属化" /></li>
</ol>


<h2>光刻工艺综述</h2>

<ol>
<li>光刻常用在：有源区的图形化，栅极的图形化，接触孔的图形化，金属图形化</li>
<li>光刻过程的信息流：设计人员CAD设计->版图转移到掩膜版上MASK->通过光刻工艺在光刻胶表面的空中形成aerial image->转移到光刻胶表面real image->在1um的光刻胶里面形成Latent image->显影后形成Resist image->在器件上形成Device Layer；Each step can lose information, distoring device pattern</li>
<li>典型的图形化转移步骤：

<ol>
<li>旋转涂胶</li>
<li>曝光</li>
<li>显影</li>
<li>湿法刻蚀</li>
<li>去除光刻胶</li>
</ol>
</li>
</ol>


<h2>光刻工艺详解</h2>

<ol>
<li>MOS制备工艺中栅极的光刻步骤
<img src="http://i.imgur.com/fkNnt3m.png" alt="光刻步骤" /><img src="http://i.imgur.com/2hOh06Q.png" alt="光刻步骤" />

<ol>
<li>硅片清洗：将表面的颗粒和污染物去除，增强光刻胶和硅表面的附着力

<ol>
<li>化学清洗</li>
<li>去离子水漂净</li>
<li>甩干</li>
</ol>
</li>
<li>预烘及涂底胶

<ol>
<li>预烘在100℃左右，目的是去除硅片表面的水汽</li>
<li>涂底胶一般涂一层非常薄的HMDS，能够很好地促进光刻胶和硅片表面的结合</li>
</ol>
</li>
<li>涂光刻胶

<ol>
<li>光刻胶旋图的厚度影响因素：

<ol>
<li>光刻胶的种类</li>
<li>光刻胶的粘度</li>
<li>真空吸盘的转速</li>
</ol>
</li>
<li>光刻胶喷嘴在喷完光刻胶之后需要suck back（回吸）的动作，目的是避免悬在喷嘴口上的光刻胶掉落在硅片上</li>
<li>光刻胶旋涂后不仅覆盖硅片的正表面，还会覆盖边缘和背面一部分。边缘和背面的部分光刻胶称作Edge bead，需要去除（Edge bead removal，EBR），方法有化学EBR，曝光EBR</li>
</ol>
</li>
<li>软烤：将光刻胶里面80%的溶剂蒸发掉，提高光刻胶和硅片的粘附性

<ol>
<li>温度90℃~100℃</li>
<li>具体温度和软烤时间需要具体设置</li>
<li>方法：

<ol>
<li>烘箱退火</li>
<li>电炉烘烤</li>
</ol>
</li>
<li>过渡烘烤会降低光刻胶的光敏度</li>
</ol>
</li>
<li>对准：

<ol>
<li>这一步工艺决定了整个微纳加工的最小线宽</li>
<li>分类：接触式，接近式，投影式</li>
</ol>
</li>
<li>曝光

<ol>
<li>分为接触式，接近式和投影式</li>
</ol>
</li>
<li>后烤：停止光化学反应，让光刻胶的侧面光滑，提高精度，均匀驻波对光刻胶侧面带来的形貌的影响

<ol>
<li>温度高于软烤的温度，100℃，烘烤10分钟</li>
</ol>
</li>
<li>显影，硬烘和检测

<ol>
<li>在碱性溶液中显影，沉浸式或者喷雾，可以利用超声波来搅拌，让反应均匀</li>
<li>硬烤目的是将光刻胶中所有的溶剂都蒸发，光刻胶完成聚合化和剥离化，提供光刻胶抵抗刻蚀和注入的能力。同时在硬烤过程中，光刻胶内部的流动将内部的针孔给填满了</li>
</ol>
</li>
</ol>
</li>
<li>光刻机的原理：光的衍射

<ol>
<li>光刻机就是讲掩膜版上的图形与前次工序中已刻在硅片上的图形对准后，再将硅片表面的光刻胶进行曝光实现图形复制的设备</li>
<li>三个主要性能指标：

<ol>
<li>分辨率

<ul>
<li>是可以曝光出来的最小特征尺寸</li>
</ul>
</li>
<li>对准和套刻精度

<ul>
<li>是描述光刻机加工图形重复性能的一个指标，是层间套刻精度的度量，主要取决于掩膜版和硅片的支撑平台图形对准和移动控制精度性能</li>
</ul>
</li>
<li>产率

<ul>
<li>每个小时可加工的硅片的数目</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>接触式光刻：掩膜版直接与光刻胶接触

<ol>
<li>优点：结构简单，成本低，光的衍射效应小，曝光出来的图形与掩膜版上的图形分辨率相当，设备简单</li>
<li>缺点：光刻胶污染掩膜版，产能低</li>
</ol>
</li>
<li>接近式光刻：掩膜版和光刻胶略微分开，越2~20μm

<ol>
<li>优点：可以避免与光刻胶的直接接触而引起的掩膜版损伤</li>
<li>缺点：引入了衍射效应，降低了分辨率</li>
</ol>
</li>
<li>投影式曝光：在掩膜版和光刻胶之间使用透镜聚集光实现曝光。一般掩膜版的尺寸会以需要转移图形的4倍制作

<ol>
<li>优点：提高了分辨率；掩膜版的制作更加容易；掩膜版上的缺陷影响减小</li>
<li>缺点：成本非常高，维护成本也很高</li>
<li>分类：

<ol>
<li>扫描投影曝光（Scanning Project Printing）

<ul>
<li>掩膜版1：1，全尺寸</li>
</ul>
</li>
<li>步进重复投影曝光

<ul>
<li>掩膜版缩小比例（4：1），曝光区域22X22mm</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>掩膜版由石英作为基座，表面有一层50~500nm的铬层或者乳胶层，这层是带图形的

<ol>
<li>掩膜图形的制作方法有：镭射光刻写（不精确），电子束刻写（精确），两种方式都比较慢，需要几个小时</li>
</ol>
</li>
<li>光刻胶：光刻胶对光线敏感，所以需要在黄光下进行操作。光刻胶=基材+感光材料+溶剂

<ol>
<li>正性光刻胶：曝光区域更容易在显影液中溶解（光照破坏了聚合物链式结构）</li>
<li>负性光刻胶：曝光区域更不容易在显影液中溶解（光照促使产生了链式结构）</li>
<li>对光刻胶的要求：

<ol>
<li>旋涂方便</li>
<li>曝光性好</li>
<li>尺寸稳定</li>
<li>抗刻蚀</li>
</ol>
</li>
<li>光刻胶的清洗

<ol>
<li>浓硫酸+双氧水去除金属</li>
<li>使用有机溶剂清洗，但是很难去除硬化的光刻胶</li>
<li>氧的等离子体，将光刻胶燃烧</li>
</ol>
</li>
</ol>
</li>
<li>光线通过掩膜版后进入光刻胶，在硅片表面反射，与入射的光波产生干涉，形成驻波（standing wave），驻波的强光区域在显影时候溶解更多，驻波的弱光区域在显影的时候溶解更少，从而导致形成波浪状的侧面图形。避免形成驻波的方法：

<ol>
<li>在光刻胶里面加入吸收性更强的成分，削弱反射光</li>
<li>使用多层光刻胶</li>
<li>在硅片表面涂上一层防止反射的图层（bottom anti-reflection coating，BARC）。光刻胶不平整，底层反射会使被掩膜保护的光刻胶也得到了曝光，此时必须使用BARC材料。图形化工艺之前必须要平坦化工艺</li>
<li>PEB（后烤）均匀驻波对光刻胶侧面带来的形貌的影响</li>
</ol>
</li>
<li>多层对准（Overlay）产生的误差

<ol>
<li>掩膜版和硅片的热膨胀系数不同导致硅片上的图形与掩膜版上面的图形有误差，称为：Thermal run-in/run-out error</li>
<li>往同一个方向偏移（translation error）</li>
<li>旋转偏移（Rotational Error）</li>
<li>最大允许误差不能超过特征尺寸的1/3</li>
</ol>
</li>
<li>采用OPC（optical proximity correction）的方法对由于光学衍射和干涉带来的图形畸变</li>
<li>提高光刻分辨率的若干技术

<ol>
<li>更短波长的光源

<ol>
<li>汞灯G线波长436nm，H线405nm，I线365nm；KrF准分子激光波长248nm；ArF准分子激光波长193nm。进一步缩小波长，一方面受到没有足够功率和稳定性激光器的限制，另一方面也受到光线大气吸收的限制</li>
</ol>
</li>
<li>浸润式光刻技术

<ol>
<li>在光刻胶和投影镜头之间填充介电常数n大于1的物质，如水，等效波长就会减小为原来的1/n</li>
</ol>
</li>
<li>移相掩膜技术（光强不变，相位翻转，相长干涉变成相消干涉），移相子通常由透明的薄膜如SiO2来担任</li>
<li>DFM（Design For Manufacture）技术</li>
<li>EUV（Extreme Ultraviolet Lithography，极紫外光刻）使用波长非常小的紫外光来进行光刻，是一套光反射系统，波长11.2nm。目前EUV的瓶颈是光强</li>
<li>偏轴入射光，可以提高NA，原因是增加了高阶衍射的入射量（高阶衍射光中携带了精细图形的信息）</li>
</ol>
</li>
<li>光刻的非理想因素

<ol>
<li>光刻胶有厚度，上表面的光刻胶接收的光照比下表面强，显影过后，光刻胶的横截面呈现梯形。解决办法有：使用高对比度的光刻胶</li>
<li>光刻胶便面不平整，导致部分图形失焦，解决方案：平坦化工艺</li>
</ol>
</li>
</ol>


<h2>平坦化工艺对光刻的重要意义</h2>

<ol>
<li>随着光刻工艺分辨率的提高，DOF（焦深）在下降，对焦过程中很容易失焦，平坦化工艺可以避免</li>
<li>在不平坦的表面，由于光刻胶厚度不均匀，导致曝光不均匀</li>
<li>不平坦的表面会导致光的散射，使得曝光过程不受控制</li>
</ol>


<h2>分辨率与焦深</h2>

<ol>
<li>最小特征尺寸：W=k1λ/NA（瑞利判据）。k1是工艺决定的参数，约0.6~0.8，λ为波长，NA为光学系统的数值孔径NA=n0*sinα，n0为中间介质的折射率，NA代表光学系统收集光的能力。</li>
<li>焦深（景深）DOF=k2λ/(NA)<sup>2</sup>,k2也是工艺决定的参数。焦深越大，最小特征尺寸也越大，利用平坦化工艺可以解决焦深的问题</li>
</ol>


<h2>图形转移</h2>

<ol>
<li>图形转移就是利用光刻胶作为掩蔽，通过物理和化学的办法把下面的衬底或薄膜材料中没有被掩蔽的部分腐蚀掉。腐蚀的方式有：湿法腐蚀和干法刻蚀</li>
<li>湿法腐蚀：利用化学试剂进行腐蚀

<ol>
<li>通常是各向同性的，垂直和侧面刻蚀速率比约为1.2：1。但是KOH对Si的腐蚀与晶向有关，100面的腐蚀速率是111的一百倍</li>
<li>需要控制腐蚀液的浓度和腐蚀温度</li>
<li>不适合在更小尺度下进行刻蚀</li>
<li>只用于wafer的清洗和光刻胶的去除</li>
<li>温度敏感，工艺不好受控</li>
<li>均匀性不好，反应物在硅片表面运输受限</li>
<li>有时候与晶向相关</li>
</ol>
</li>
<li>干法刻蚀：在腐蚀气体的气氛下完成腐蚀。为了增强腐蚀气体的化学活性，通常需要将腐蚀气体激发成等离子体

<ol>
<li>为了形成等离子体，反应在低压下进行</li>
<li>反应生成物应该是易挥发性的</li>
<li>离子轰击：

<ul>
<li>电容极板的等离子状态下，等离子体与衬底表面会产生一个鞘层，鞘层产生的自电电势会加速这个离子轰击到衬底表面，离子轰击能量达到10~700eV。离子轰击增强腐蚀效果，腐蚀速率提高几到几十倍</li>
<li>所以Wafer放在阴极，离子轰击的效果更明显</li>
<li>离子轰击将被刻蚀材料表面的原子键破坏</li>
<li>将再沉淀于被刻蚀表面的产物或聚合物打掉，使被刻蚀表面能再与刻蚀气体接触</li>
<li>化学反应生成的聚合物淀积在侧壁，起到保护侧壁的作用，是的整个反应向下进行比较快</li>
</ul>
</li>
<li>增强等离子体离化的手段

<ol>
<li>用电感耦合产生高密度的等离子体。可单独调节轰击电压和等离子体密度</li>
<li>电子回旋共振</li>
<li>磁性增强RIE</li>
</ol>
</li>
<li>各向异性（Anisotropy）A=1-Vh/Vv,Vh表示水平刻蚀速度，Vv表示垂直刻蚀速度</li>
<li>选择性（Selectivity）Sab=Ea/Eb，Ea表示材料a的刻蚀速率，Eb表示材料b的刻蚀速率</li>
<li>影响干法刻蚀的因素：

<ol>
<li>压强</li>
<li>气体流量</li>
<li>射频功率</li>
<li>温度</li>
<li>腔体几何形状</li>
</ol>
</li>
</ol>
</li>
<li>各向同性刻蚀：以光刻胶的暴露的表面为起点，向下和向两侧的腐蚀速度相同</li>
<li>完全各向异性刻蚀：以光刻胶的暴露的表面为起点，腐蚀的放下仅仅向下进行，不向两侧扩展</li>
<li>部分各向异性刻蚀：腐蚀的过程向下推进，同时也向两侧扩展，但是速率不一样</li>
<li>刻蚀Si和SiO2

<ol>
<li>材料：CF4+O2，氧气是用来去除反应生成的聚合物</li>
<li>当氧气表较少的时候，随着氧气浓度的增加，刻蚀速率会增加；当氧气浓度高到一定程度，氧气浓度再上升，会导致刻蚀速率的下降</li>
<li>H2的存在会导致刻蚀速率下降，而且刻蚀Si的速度下降更快</li>
<li>通过通入O2和H2来调节刻蚀速度和选择比</li>
</ol>
</li>
<li>干法刻蚀的物理化学过程

<ol>
<li>化学腐蚀（中兴活性反应物参与）</li>
<li>等离子增强的化学腐蚀</li>
<li>离子轰击增强刻蚀</li>
<li>生成物的侧壁沉积</li>
</ol>
</li>
<li>刻蚀过程中需要over-etch，确保刻蚀的完全性，同时也需要很高的选择比，如果选择比达不到要求，又需要over-etch，这时候需要加一层etch-stop层。

<ol>
<li>刻蚀Si上面的氮氧化物，需要先在Si上加一层SiO2充当etch stop layer</li>
<li>如果etch-stop layer很薄，在工艺的最后阶段可以通过降低功率的方式来提高选择比</li>
</ol>
</li>
<li>湿法刻蚀机制：

<ol>
<li>固体与流体之间存在边界层，厚度在微米量级</li>
<li>反应物通过扩散穿过边界层到达wafer表面</li>
<li>热激发化学反应</li>
<li>反应物通过扩散穿过边界层离开</li>
</ol>
</li>
<li>湿法刻蚀SiO2

<ol>
<li>SiO2+6HF->2H2SiF6+2H2O</li>
<li>HF对Si，SiNx和光刻胶的选择比很高</li>
<li>反应生成的H2O降低了反应液的酸度，反应速率随之下降</li>
<li>通过加入NH4F可以保持溶液中HF浓度的稳定，因为NH4F+H2O->NH4OH+HF</li>
</ol>
</li>
<li>Si的氮化物湿法刻蚀

<ol>
<li>使用热磷酸H3PO4，温度150~160℃</li>
<li>对Si和氧化物有着高的选择比，但是对光刻胶和金属的选择比很低</li>
<li>所以需要加一层硬掩膜来提高对光刻胶的选择比，解决光刻胶不耐酸的问题。（选择比在下面很低用etch-stop layer，在光刻胶部分很低用Hard Mask）</li>
</ol>
</li>
<li>Si/Poly-Si的湿法刻蚀

<ol>
<li>各向同性：Si+HNO3+HF->H2SiF6+HNO2+H2+2H2O</li>
<li>KOH定向刻蚀Si的100面，保留111面不被刻蚀，得到原子级别的光滑面，倒金字塔形状</li>
</ol>
</li>
<li>Al的湿法刻蚀

<ol>
<li>氧化掉Al，然后用H3PO4刻蚀Al2O3，反应过程中会产生H2带来气泡，需要超声波辅助</li>
</ol>
</li>
<li>干法刻蚀的分类：

<ol>
<li>溅射：离子轰击靶表面，转移动量，表面几层原子的化学键断裂。溅射的各向异性好，选择性差</li>
<li>RIE（Reactive ion etch）：同时存在物理作用和化学反应，需要在各向异性和选择性之间权衡</li>
<li>化学干法刻蚀：各向异性差，更好的选择性
<img src="http://i.imgur.com/HWG5MZv.png" alt="不同材料的刻蚀" /></li>
</ol>
</li>
</ol>


<h2>等离子体</h2>

<ol>
<li>自然状态下，气体中会有一小部分分子由于热激发而离化，离化后的离子在内部复合地非常快。</li>
<li>等离子体就是被激发的电离气体，可看作是高度离化的气体，相比分子总数量，它包含了很少的离化分子。这些例子处于热激发态，并快速重组。整体表现为近似电中性的电离气体</li>
<li>常见的等离子体：太阳，闪电，汞灯H线，I线就是水银的等离子体从激发态转到基态而发出的光</li>
<li>等离子体内部组成：电子+离子+分子+自由基+激发态（快要离化的分子）

<ol>
<li>活化基（Radicals）：中性分子失去外围电子形成的非常有活性的化学物质，参与各向同性的化学反应，形成易挥发的物质</li>
<li>激发态物质：化学活性也很高</li>
<li>正电离子和自由电子：由被电离的物质形成，在电场作用下加速，能量高，各向异性好，参与刻蚀的物理作用：离子轰击，物理溅射</li>
</ol>
</li>
<li>举例：CF4

<ol>
<li>激发态：CF4*</li>
<li>自由基：CF3-，CF2&ndash;，F-</li>
<li>离子态：CF3+</li>
</ol>
</li>
</ol>


<h2>Plasma Etch与RIE</h2>

<ol>
<li>Plasma etch：Wafer 放在阳极（或者接地电极）一侧，属于各向同性刻蚀；避免了离子轰击，刻蚀主要依靠化学反应</li>
<li>RIE：Wafer放在阴极（或者功率电极）一侧，各向异性较好

<ol>
<li>离子朝着Wafer加速，促进了更多的各向异性刻蚀</li>
<li>同时存在化学反应和物理作用</li>
<li>离子轰击增强了化学作用，并且是各向异性的</li>
<li>实质上，垂直的物理刻蚀是微不足道的，因为离子的动量不大（气压高意味着自由程短，加速距离短）</li>
</ol>
</li>
</ol>


<h2>PID（Plasma Induced Damage）</h2>

<ul>
<li>表面损伤，缺陷和玷污</li>
<li>天线效应（金属、多晶硅刻蚀）。悬浮导体收集电荷，损伤下面的介质层</li>
</ul>


<h2>离子轰击可能的机制</h2>

<ol>
<li>离子轰击给Wafer表面造成的损伤对整个化学反应起到了催化作用</li>
<li>离子轰击直接分裂了反应物分子</li>
<li>离子轰击去除了那些抑制反应继续进行的不易挥发的物质</li>
</ol>


<h2>干法刻蚀与湿法刻蚀的比较</h2>

<p><img src="http://i.imgur.com/HkoqZ3w.png" alt="干湿法刻蚀的比较" /></p>

<h2>刻蚀的评价指标</h2>

<ol>
<li>选择比（有两个，膜与光刻胶，膜与下方一层的介质）</li>
<li>各向异性</li>
<li>均匀性</li>
</ol>


<h2>刻蚀中三个最重要的考虑要素</h2>

<ol>
<li>刻蚀的选择比</li>
<li>各向异性</li>
<li>离子轰击损伤</li>
</ol>


<h2>等离子体刻蚀的试剂中加入C、H、O的原因</h2>

<ul>
<li>C、H、O的有意引入目的在于使反应生成聚合物保护侧壁不被刻蚀，加强了各向异性的刻蚀</li>
</ul>


<h2>刻蚀的终点控制</h2>

<ol>
<li>干涉法，检测薄膜厚度</li>
<li>根据光发射谱，检测反应物浓度（最常用）</li>
<li>质谱法（最准确，最贵）</li>
</ol>


<h2>刻蚀中的若干问题</h2>

<ol>
<li>掩膜损失

<ol>
<li>刻蚀过程中光刻胶也会有所损失，使得光刻胶定义的窗口展宽，不利于定向腐蚀</li>
<li>解决办法：使用硬掩膜</li>
</ol>
</li>
<li>侧壁沉积物的控制

<ol>
<li>反应生成有机物在侧壁的沉积过多会使得光刻胶定义的窗口缩小</li>
<li>通过反应气氛中接入小量的O2去除适当的侧壁生成物，使之不产生大量的堆积</li>
</ol>
</li>
<li>侧壁堆积的聚合物对电路可靠性产生不利影响

<ol>
<li>刻蚀完成后需要加入阳等离子体的处理，去除侧壁聚合物，提高电路的可靠性</li>
</ol>
</li>
<li>负载效应（Loading effect）

<ol>
<li>刻蚀速率与被刻蚀材料的暴露表面积相关，表面积越大，刻蚀速率越慢，使得刻蚀均匀性受很大影响</li>
<li>解决方法：在图形稀疏区域加一些dummy pattern（加图形），使各个区域的图形密度大致相当</li>
</ol>
</li>
<li>天线效应

<ol>
<li>离子轰击是带电荷的，在对金属引线或者多晶硅的刻蚀过程中，金属对于器件来说相当于天线，收集了大量的电荷，这些电荷产生的电场有可能会击穿介质层</li>
<li>解决方法：工艺与设计相结合，设计时候避免较大较长的金属引线的刻蚀</li>
</ol>
</li>
</ol>


<h2>刻蚀过程中，由于几何表面不平整带来的影响（有好有坏）</h2>

<ol>
<li>光刻胶的重淀积，一方面保护了侧壁，另一方面会影响器件的性能</li>
<li>纵梁（stringer）效应：台阶处的薄膜厚度各不相同，各向异性刻蚀会在台阶侧壁形成一道“纵梁”，需要大量的over-etch才能消除纵梁效应</li>
</ol>


<h2>Blanket Metal Etch-back</h2>

<ul>
<li>填充连接孔（contact hole）&ndash;钨塞：首先用LPCVD 的方式淀积金属W，然后用RIE的方式刻蚀掉表面多余的W，只留下连接孔里面的金属W</li>
<li>回刻是不需要掩膜的</li>
</ul>


<h2>Lift-Off 工艺（剥离工艺）</h2>

<ul>
<li>如果薄膜在等离子体中刻蚀不能生成易挥发的化合物，比如刻蚀铜Cu，可以采用Lift-Off的方法

<ul>
<li>使用图形化的工艺淀积一层牺牲层（一般是光刻胶），只留下需要的图形没有淀积上光刻胶</li>
<li>淀积需要的金属铜Cu，此时没有覆盖光刻胶的部分就会淀积上一层Cu</li>
<li>使用简单的湿法刻蚀，去除掉光刻胶，最后剩下的就是需要的金属铜构成的图形</li>
</ul>
</li>
<li>低产量，低均匀性，不适用于量产</li>
</ul>


<h2>MOSFET多晶硅删的刻蚀</h2>

<p><img src="http://i.imgur.com/fHsTbdE.png" alt="MOSFET多晶硅删的刻蚀" /></p>

<h2>TSV（through silicon via）刻蚀</h2>

<p><img src="http://i.imgur.com/7CFMDkg.png" alt="TSV刻蚀" /></p>

<h2>掺杂</h2>

<ol>
<li>掺杂是将掺杂物替位式地引入半导体材料的晶体结构中以改变其电学特性</li>
<li>分类：

<ol>
<li>离子注入</li>
<li>热扩散</li>
<li>原位掺杂，用在单晶硅生长或者薄膜生长的过程中，例如拉单晶时候对硅进行磷或硼掺杂</li>
</ol>
</li>
<li>想要在掺杂区域获得良好的掺杂分布图需要对深度（depth）和浓度（concentration）有好的控制能力。离子注入方式在这方面做得比较好</li>
<li>参杂的来源可以是固体，气体，液体（BBr3，AsCl3，POCl3，在高温熔炉里此时都已称为蒸汽）和沉积源（如SOG，方法是让包含杂质的玻璃溶解）</li>
<li>固溶度（Solid solubility limit）：能够被热扩散进入Si的最大剂量。离子注入不受固溶度的限制</li>
<li>在氧化过程中将杂质引入，热扩散过程中伴随着Si的氧化

<ol>
<li>掺杂过程中有意引入氧气</li>
<li>掺杂B使用B2O3</li>
<li>掺杂P使用P2O5</li>
<li>掺杂As使用As2O3</li>
</ol>
</li>
<li>H,Li,Na,K,Ar等I，VIII族元素在Si的扩散属于<strong>间隙扩散</strong>，间隙扩散适用于原子半径小的元素。</li>
<li>替位扩散是一种空位扩散，依赖两种情况：

<ol>
<li>相邻位置有空位</li>
<li>杂质原子有足够的能量克服势垒</li>
</ol>
</li>
<li>替位式掺杂才有电学活性</li>
<li>间隙式扩散的激活能远远小于替位式扩散的激活能</li>
</ol>


<h2>扩散工艺综述</h2>

<p><img src="http://i.imgur.com/g7IMqR7.png" alt="扩散工艺介绍" /></p>

<ol>
<li>杂质在纵向扩散的同时，也进行横向扩散。一般横向扩散长度为纵向扩散深度的0.75~0.85，横向扩散是“设计规则”要考虑的重要因素，影响IC的集成度，也影响PN结电容</li>
<li><p>扩散系数D表征杂质在硅的晶体里面扩散的运动速率，不同的杂质在不同温度下有不同的扩散系数。
<img src="http://i.imgur.com/jcwfNB7.png" alt="扩散系数" /></p></li>
<li><p>Ea是原子扩散的激活能</p></li>
<li>在Si中，B和P的扩散属于替位式原子扩散，这种扩散需要通过晶体的热缺陷的产生和运动来实现，因此需要较高的温度</li>
<li>对于半径很小的原子，比如金原子，它在硅中是通过晶格间隙来扩散的，扩散温度比较低。</li>
<li>扩散中的掩膜使用SiO2，Si3N4这些耐高温的材质</li>
</ol>


<h2>两步扩散工艺</h2>

<p><img src="http://i.imgur.com/VI5ZUab.png" alt="两步扩散工艺" />
1. 预淀积（Predeposition），确定总体的掺杂数目，有两个影响因素：
    1. 杂质的扩散率
    2. 杂质的最大固溶度
2. 推进（Drive-in ），确定杂质的分布
3. 为什么要分成两步？
    * 因为需要控制浓度（剂量）和结深，很难在一步之内同时控制这两个参数
4. 使用SiO2扩散掩膜来实现选择性杂质扩散，SiO2膜需要一定的厚度以保证高的选择比
5. 多晶硅中的热扩散有一种效应叫做：晶界效应。即在晶粒内部的杂质扩散类似于单晶硅，但是在晶粒边界由于晶格缺陷造成大量空位，杂质的扩散速度大大加快</p>

<h2>菲克定律</h2>

<p><img src="http://i.imgur.com/9763hv6.png" alt="菲克定律" />
<img src="http://i.imgur.com/ACDN0b2.png" alt="菲克定律公式" />
<img src="http://i.imgur.com/CXbDq7g.png" alt="扩散过程计算" />
<img src="http://i.imgur.com/EPygnPf.png" alt="预淀积过程扩散浓度计算" />
<img src="http://i.imgur.com/OHhOG0Q.png" alt="推进过程的扩散浓度计算" />
1. 预淀积阶段，杂质分布服从余误差函数，扩散总量Q(t)=2Cs<em>sqrt(D</em>t)/sqrt(π)≈1.13<em>Cs</em>sqrt(D*t)
2. 热扩散的推进阶段，杂质分布服从半高斯分布，理论上中心点在0处；离子注入的杂质分布也服从高斯分布，中心在Rp（投影射程）处</p>

<h2>离子注入工艺</h2>

<ol>
<li>热扩散方法的缺陷

<ol>
<li>表面浓度和扩散深度相关</li>
<li>基本上只能获得高斯或余误差分布</li>
<li>受上述各种增强扩散因素的影响，实际上很难精确控制杂质浓度和深度</li>
</ol>
</li>
<li>离职注入可以精确地控制杂质数量和灵活的调节其分布，代价是晶格损伤。晶格损伤可以通过退火工艺来消除</li>
<li>离子注入设备

<ol>
<li>离子源：气态源或者固态源BF3，AsH3，PH3</li>
<li>放电室：低气压、分解离化气体，如BF3->B,B+,BF2+,F+等</li>
<li>引出狭缝：负电位，吸引出离子

<ol>
<li>离子束流量（最大mA量级）</li>
<li>吸极电压约为15~30KV,决定引出离子的能量</li>
</ol>
</li>
<li>质谱仪：选择注入所需的杂质成分

<ol>
<li>分析磁铁：磁场方向垂直于离子束的速度方向</li>
<li>出口狭缝：只允许一种(m/q)的离子离开分析仪</li>
</ol>
</li>
<li>加速管：加速离子，获得所需能量；高真空。最终获得动能和电压差，离子所带的电荷数有关</li>
<li>终端台：控制离子束扫描和剂量

<ol>
<li>法拉第杯：捕获进入的电荷，测量离子流</li>
</ol>
</li>
</ol>
</li>
<li>离子注入的优势

<ol>
<li>对剂量和杂质分布的精确控制，不受固溶度极限的限制</li>
<li>低温工艺，可以使用光刻胶作掩膜</li>
<li>更多的对掩膜材料的选择（如PR，SiO2，多晶硅，金属）</li>
<li>对表面清洁度不敏感</li>
<li>杂质有很少的横向扩散</li>
<li>可以穿过顶层对下层的材料进行掺杂</li>
<li>介质分布可以通过多次不同投影射程的离子注入来实现（如为了形成矩形分布）</li>
<li>杂质纯度非常高（因为使用了质谱仪将需要的杂质分离出来）</li>
</ol>
</li>
<li>离子注入关键的参数：

<ol>
<li>剂量（dose）：硅片上单位面积注入的离子数量，用法拉第杯测量注入的离子数量来控制束流大小</li>
<li>投影射程（project range）：指深度方向的延伸的距离。注入能量是决定注入深度的关键因素</li>
</ol>
</li>
<li>离子注入的局限性

<ol>
<li>难以得到B的浅结，或者As的深结，原因在于投影距离受到离子入射能量的限制（能量太高太低都不好做到）</li>
<li>离子注入损伤是无法避免的（部分Si晶格遭破坏，表面非晶化），需要后续高温热退火修复并且激活杂质</li>
<li>通常需要一层氧化层充当牺牲层，来保护衬底</li>
<li>有沟道效应
<img src="http://i.imgur.com/vw1Vg6s.png" alt="入射离子的分布" /></li>
</ol>
</li>
</ol>


<h2>溅射，散射与注入</h2>

<ol>
<li>当真空中有一束离子束摄像一块固体材料，离子束把固体材料的原子或者分子撞出固体材料的表面，这种现象叫做溅射</li>
<li>当离子束从固体表面反弹回来或者穿出固体材料而去，这种现象叫做散射</li>
<li>当离子束射到固体材料以后，受到固体材料的抵抗，速度慢慢降低，最终停留在固体材料中，这种现象叫做离子注入</li>
</ol>


<h2>影响离子注入的因数</h2>

<ol>
<li>横向偏差：入射离子的分布大于光刻胶开孔的区域</li>
<li>MASK的材料，很多情况下是图形化后的光刻胶，光刻胶的厚度要根据实际情况定</li>
<li>现代工艺需要浅结，一味降低加速电压会导致离子束流不稳定，为了实现离子的低能注入，可以采用分子注入的方法。如注入B+可以使用BF2+，B+的注入动能会降低为20%</li>
<li>沟道效应：一束准直带电粒子通单晶相互作用，当入射方向接近某一主晶轴方向，粒子射程明显增加。沟道效应会使注入注入分布产生很长的拖尾。解决方法是偏离轴注入，或者衬底表面非晶化处理。</li>
<li>注入损伤和退火。

<ol>
<li>注入损伤的形成：高能入射离子与靶原子核发生碰撞时，使靶原子离开初始晶格位置，并引发连续碰撞，引起大量靶原子跑哪里晶格位置，产生空位和填隙原子等晶格损伤。</li>
<li>注入损伤阈值剂量：超过某一剂量注入后，形成完全损伤，晶体的长程有序被破坏。离子越轻，阈值计量越高。温度越高，阈值计量越高。</li>
</ol>
</li>
</ol>


<h2>IC工艺中的热预算</h2>

<ol>
<li>IC制造过程中经过每一步高温工艺，都会对最终的杂质分布产生影响&ndash;杂质再分布</li>
<li>随着IC器件中尺寸的不断缩小，要求杂质的再分布要尽可能小，因此“Thermal Budget”称为工艺集成中要考虑的一个非常重要的概念，尽量减少采用高温工艺，采用RTA等</li>
<li>Rapid Thermal Process（RTP）和Rapid Thermal Annealing（RTA）成为常用工艺手段</li>
<li>RTA用来激活杂质，修复缺陷，并且能够防止杂质扩散，具有较低的热预算，在“浅结”器件的制作中不可缺少</li>
</ol>


<h2>浅结的制作</h2>

<ol>
<li>低能离子注入</li>
<li>分子注入代替离子注入</li>
<li>快速热退火RTA</li>
<li>表面非晶化</li>
<li>偏轴方向注入杂质</li>
</ol>


<h2>薄膜的分类</h2>

<ol>
<li>根据电学性质分类：

<ol>
<li>半导体薄膜，如Si，SiGe，SiC</li>
<li>绝缘体薄膜，如SiO2，PSG，low-k，high-k介质</li>
<li>金属薄膜，如互联使用的W，Al，Cu，金属硅化物TiSi2，NiSi2，和阻挡金属层，如TiN，TaN</li>
</ol>
</li>
<li>根据微结构分类：

<ol>
<li>单晶材料，如单晶硅</li>
<li>多晶材料，如多晶硅，大多数的金属</li>
<li>非晶材料，如SiO2，SiNx</li>
</ol>
</li>
</ol>


<h2>PVD与CVD比较</h2>

<ol>
<li>PVD直接将原子淀积到衬底表面，而CVD通过表面化学反应生成薄膜</li>
<li>PVD主要用来淀积金属膜，CVD主要用来淀积介质薄膜</li>
<li>CVD比PVD有更好的均匀性和保形性（或者叫台阶覆盖性）</li>
<li>外延生长可以通过CVD实现，但是PVD不能够实现外延生长</li>
</ol>


<h2>CVD工艺特点</h2>

<ol>
<li>气相反应物淀积成膜</li>
<li>高温和低压是最常见的反应条件，但也不总是需要</li>
<li>所有的CVD方法都需要某种能量源来将反应气体分解反应活性物质（自由基）</li>
<li>整个CVD过程要么是化学反应控制，要么是质量传输控制</li>
<li>分类：APCVD，LPCVD，PECVD，MOCVD，MBE（分子束外延），ALD（原子层淀积）</li>
</ol>


<h2>薄膜淀积过程（以多晶硅为例）</h2>

<ol>
<li>混合气体进入反应室，反应室尺寸远大于气体分子自由程，所以气流是粘滞流，主气流是层流，在硅片表面形成“边界层”</li>
<li>硅烷（SiH4）从主气流区以扩散方式穿过边界层到达衬底表面</li>
<li>在硅片表面硅烷及其分解的气态含硅原子团被吸附在硅片的表面，成为吸附分子</li>
<li>发生表面反应，生成的硅原子在硅片上聚集，连接成片，成膜；</li>
<li>H2从衬底表面解吸，被排出反应室</li>
</ol>


<h2>外延</h2>

<ol>
<li>外延工艺，指在晶体上用化学或者物理的方法规则地再排列所需晶体材料</li>
<li>外延层和衬底晶向相同，但掺杂类型、电阻率、材料可以不同</li>
<li>外延按工艺方法划分：

<ol>
<li>气相外延（VPE）：最为成熟，在单晶硅上用CVD方式将气态反应物淀积到表面，能够生长出晶格匹配的单晶硅层</li>
<li>液相外延（LVP）：拉单晶过程</li>
<li>固相外延（SPE）：使用单晶硅仔晶使无定型的硅结晶，通常用来修复离子注入损伤</li>
<li>分子束外延（MBE）：分子束注入到衬底表面，外延生长一层单晶层。技术先进，通常用来制备GaAs和其他混合半导体薄膜。能够精确控制单原子层生长。</li>
</ol>
</li>
<li>外延按照材料划分：

<ol>
<li>同质外延，又称均匀外延</li>
<li>异质外延，又称非均匀外延

<ol>
<li>外延层要与衬底相容，包括：

<ul>
<li>两者在外延温度不发生化学反应，不互溶</li>
<li>两者热力学匹配</li>
<li>两者晶格匹配</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>CVD技术（主要用来淀积介质薄膜，如多晶硅，SiO2和氮化硅）</h2>

<ol>
<li>过程：气态反应物在沉底反应生成固态的薄膜，例如siH4(g)+O2(g)->SiO2(g)+2H2(g)[400℃],3SiH4(g)+4NH3(g)->Si3N4(s)+12H2(g)[750℃],其中SiH4称为硅烷,SiH4(g)->Si(s)+2H2(650℃),WF6(g)+3H2(g)->W(s)+6HF(g)</li>
<li>工艺步骤：

<ol>
<li>反应物运输到淀积区域</li>
<li>反应物从主气流穿过边界层运输到晶片表面</li>
<li>反应物吸附在晶片表面</li>
<li>表面作用，包括化学分解或反应，在表面迁移向吸附位置（表面迁移可以消除几何因素，降低台阶效应，反应更加彻底，生成的薄膜更加致密）</li>
<li>副产物的吸解</li>
<li>副产物穿过边界层回到主气流中</li>
<li>副产物离开淀积区域排走</li>
</ol>
</li>
<li>CVD技术分类及设备简介

<ol>
<li>常压化学气相沉积（APCVD），激励源：温度；特点：产能(throughput)大,但是台阶覆盖性和均匀性不好。设备结构简单，淀积速率较快。但容易发生气相反应、产生微粒污染。

<ul>
<li>常压指的是亚大气压（约0.1个大气压）</li>
<li>反应速率快，气相质量运输成为瓶颈</li>
<li>优势：

<ul>
<li>反应设备简单，淀积速率快</li>
</ul>
</li>
<li>缺点

<ul>
<li>污染，气相反映产生了颗粒（因为APCVD的浓度高，反应可以不用借助表面）</li>
<li>均匀性差，因为是气相质量运输限制</li>
<li>台阶覆盖性差，因为衬底温度低</li>
</ul>
</li>
<li>应用

<ul>
<li>低温氧化，亚大气压下的气相外延</li>
</ul>
</li>
<li>将工艺温度控制在气相质量输运限制区，薄膜淀积速率对反应剂浓度敏感，而对衬底温度波动不敏感</li>
<li>在工艺过程中要精确控制反应剂成分、剂量以及分布的均匀性</li>
<li>衬底温度远高于气流温度，气流的变化会引起衬底温度略有起伏，但是对淀积速率影响不大</li>
</ul>
</li>
<li>低压化学气相沉积（LPCVD），激励源：温度；特点：气体稀薄，自由程大，硅片可以紧密排列，可以批量加工，并且保角性比较好，但是工艺温度比较高，石英管壁上的沉积物成为后续工艺中的颗粒；有气缺现象。

<ol>
<li>与APCVD相比增加了真空系统，是淀积多晶硅、氮化硅、二氧化硅、PSG、BPSG、W的常用方法</li>
<li>气缺效应：指一段进气，沿气流方向反应剂不断消耗，淀积膜厚不均现象</li>
<li>工艺控制

<ul>
<li>主要是工艺温度，气体总压，个反应剂分压，气流速度及分布均匀性。另外，工艺卫生也很重要，如淀积之前应清理反应室颗粒物</li>
<li>LPCVD通常将温度控制在表面化学反应控制区，薄膜淀积速率对温度波动非常敏感，而对反应剂浓度及分布均匀性不太敏感</li>
<li>气缺效应可通过沿气流方向逐步提高加热器温度，加快反应速度，从而提高淀积速率来消除。</li>
<li>优势

<ul>
<li>较少的污染</li>
<li>均匀性好（因为热墙式反应器的温度控制精确，Wafer受热更均匀）</li>
<li>一致性好（台阶覆盖性好）</li>
</ul>
</li>
<li>缺点

<ul>
<li>淀积速率较慢</li>
<li>提高反应速率需要更高的温度</li>
</ul>
</li>
<li>应用广泛

<ul>
<li>低温氧化（LTO），氮化物，多晶硅，W和WSi2</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>等离子体增强化学气相沉积（PECVD），激励源：等离子体，温度

<ol>
<li>工艺温度较低，淀积速率是表面反应控制，影响淀积速率与质量的因素除了温度之外，还有反应器结构，射频功率强度和频率，反应剂与稀释剂气体剂量，抽气速率</li>
<li>薄膜均匀性较好，台阶覆盖性和粘附性都好于APCVD和LPCVD。</li>
<li>薄膜较疏松，密度较低，含有较高浓度的氢，有时还含水、氮，成分不是理想的化学配比</li>
<li>PECVD是当前制备SiO2，Si3N4采用较多的CVD方法，所制备的薄膜适合作为集成电路或者分立器件芯片的钝化膜和保护膜</li>
<li>优点

<ul>
<li>温度低，淀积速率快，台阶覆盖性较好（需要离子轰击的辅助才能改善台阶覆盖性）</li>
</ul>
</li>
<li>缺点

<ul>
<li>反应内壁也有淀积，存在污染</li>
</ul>
</li>
<li>应用

<ul>
<li>金属绝缘层，钝化层，在低温材料的淀积（比如塑料）</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>几种最常见的CVD实例

<ol>
<li>W plug（钨塞），用于集成电路互联线层间连通金属，需要优化CVD工艺，提高保角性</li>
</ol>
</li>
<li>ClusterTools设备使得硅片在不同的反应腔中传输时不出真空环境，大大减少了环境影响因素，提高了工艺成品率</li>
<li>对下层非平面形貌的覆盖，包括台阶覆盖和孔的填充问题，通过控制反应气体理化特性和各种工艺条件，达到：

<ol>
<li>适当的粘附系数</li>
<li>主要由反应控制决定薄膜生长有利于台阶覆盖</li>
</ol>
</li>
</ol>


<h2>CVD-SiO2</h2>

<ol>
<li>与热氧化SiO2的理化性质相比略有差异，随着工艺温度降低，密度下降，耐腐蚀性下降，成分偏离化学配比。</li>
<li>TEOS为硅源淀积的SiO2台阶覆盖性好于以硅烷为硅源的反应剂系统</li>
<li>SiO2薄膜用途不同要求不同

<ol>
<li>作为多层布线中金属层之间的绝缘性，应有较好的台阶覆盖性，具备较高介质击穿电压</li>
<li>作为防止杂质外扩的覆盖层、掩膜以及钝化层：针孔密度低，薄膜致密</li>
</ol>
</li>
<li>PSG（磷硅玻璃）、BPSG（硼磷硅玻璃）

<ol>
<li>SiO2中掺P或B后软化温度下降，通过退火回流，可降低硅片表面台阶，实现平整化，掺杂剂：PH3、B2H4、TMB、TMP（高温下，膜软化，有一定的流动性，改善了台阶覆盖性）</li>
<li>PSG薄膜应力小，台阶覆盖性较好，P一般控制在6~8wt%</li>
<li>BPSG是三元氧化膜体系，软化温度低于PSG，回流温度在850℃，B控制在5wt%一下</li>
<li>高温退火可以使生成的薄膜致密</li>
</ol>
</li>
</ol>


<h2>APCVD-SiO2</h2>

<ol>
<li>SiH4/O2为源

<ol>
<li>工艺：通常淀积USG，温度450~500℃，用N2稀释SH4与过量O2的混合气体</li>
<li>特点：工艺成熟，孔隙填充和台阶覆盖性差</li>
<li>用途：作为多层金属铝布线中铝层之间的绝缘层（记为ILD）</li>
</ol>
</li>
<li>TEOS/O3为源

<ol>
<li>工艺：温度400℃，TEOS为液态，沸点168.1℃，用源瓶在其携带，温控流量；O3约1~2%。加入PH3、B2H4来淀积PSG、BPSG</li>
<li>特点：在SiO2薄膜中会含有水汽，针孔密度较高，通常需要高温退火去除潮气，提高薄膜致密度；良好的台阶覆盖性，填充空隙能力较强</li>
<li>用途：多用于淀积多层布线金属层之间的绝缘层。</li>
</ol>
</li>
<li>实际工艺中常将SiH4/O2和TEOS/O3两种系统连用，也可APCVD和其它方法结合起来使用</li>
</ol>


<h2>LPCVD-SiO2</h2>

<ol>
<li>TEOS或TEOS/O2为源

<ol>
<li>工艺：制备USG、PSG、BPSG，温度：680~750℃</li>
<li>特点：致密性、台阶覆盖性等好于同类低温工艺；O2的加入能改变薄膜的内应力</li>
<li>用途：USG用于金属层之间的绝缘层，PSG、BPSG作为制备金属化系统之前的绝缘层</li>
</ol>
</li>
<li>SiH2Cl2/N2O为源

<ol>
<li>工艺：淀积USG和PSG、BPSG，温度约900℃</li>
<li>特点：是高温工艺，薄膜的均匀性和台阶覆盖能力都好，HF的腐蚀速率、密度，以及电学性质和光学性质也都与热生长的氧化层接近。含有氯</li>
<li>用途：作为掩蔽膜</li>
</ol>
</li>
</ol>


<h2>PECVD-SiO2</h2>

<ol>
<li>源：SiH4/N2O、O2</li>
<li>工艺：200~400℃，10~100Pa</li>
<li>特点：薄膜含H、N，与LPCVD、APCVD相比薄膜应力小、不易开裂、保形性好，离子对衬底有轰击</li>
<li>用途：可作为保护膜、钝化膜</li>
</ol>


<h2>氮化硅薄膜淀积</h2>

<ol>
<li>氮化硅薄膜性质与用途

<ol>
<li>氮化硅薄膜与二氧化硅薄膜比较：

<ol>
<li>抗钠能力强，硬度大，针孔少，更致密，化学稳定性好，作为钝化膜、保护膜有优势</li>
<li>掩蔽能力强，SiO2对B、P、As、Sb有掩蔽作用，Si3N4还可以掩蔽Ga、In、ZnO。能作为多种杂质的掩蔽膜</li>
<li>介电常数大，导热性好，作为电容的介质层</li>
<li>与硅失配率大，与Si3N4接触的Si界面缺陷大，称为载流子陷阱，或者复合中心，影响硅的载流子迁移率。因此需要在Si和Si3N4之间生长一层薄的氧化层</li>
</ol>
</li>
<li>用途

<ol>
<li>MOS器件场区氧化使用Si3N4作为选择性氧化的掩膜(LPCVD)</li>
<li>刻蚀氧化层使用Si3N4作为自停止层(LPCVD)</li>
<li>使用Si3N4作为CMOS电路的保护膜(PECVD)</li>
</ol>
</li>
<li>分类

<ol>
<li>LPCVD-Si3N4：薄膜密度大，硬度高，耐腐蚀性强，又被称为硬质氮化硅

<ol>
<li>反应剂：SiCl2H2/NH3</li>
<li>工艺：硅烷应稀释，NH3要充足</li>
<li>速率影响因素：工艺温度，总气压，各气体分压及比例等</li>
<li>特点：台阶覆盖性好，也有粒子污染。薄膜的内应力大，超过200nm的厚度时可发生龟裂，耐HF、KOH等腐蚀</li>
</ol>
</li>
<li>PECVD-SixNy：工艺温度低，薄膜通常含有相当数量的H，密度、硬度、耐腐蚀性都不如LPCVD-Si3N4，又被称为软质氮化硅

<ol>
<li>反应剂：SiH4/NH3、N2</li>
<li>工艺：温度在200~400℃；压力10~100Pa，以N2为反应剂应比NH3要更充足</li>
<li>特点：薄膜中氢含量高；用N2代替NH3含氯明显下降，淀积速率也降低</li>
<li>用途：作为芯片的保护膜和钝化膜，但有些场合低温淀积薄膜质量的下降，也限制了它的应用</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>Low-k材料</h2>

<ol>
<li>随着器件特征尺寸减小，栅极延迟和互连层延迟越来越突出，主要是RC delay</li>
<li>R的减小可通过将Al替换成Cu，但是Cu很容易扩散到绝缘材料中，造成沾污</li>
<li>C的减小可以将SiO2转换成low-k材料，二氧化硅的介电常数是3.9，low-k材料的介电常数在1~3之间。典型的有：

<ol>
<li>SiOF</li>
<li>多孔介质</li>
<li>有机low-k材料（SiLK，含Si的有机材料）</li>
<li>空气</li>
</ol>
</li>
<li>low-k材料的优点

<ol>
<li>缩短了信号传播延时</li>
<li>降低了线路串扰</li>
</ol>
</li>
<li>需要开发介电常数在2甚至2以下的介质材料

<ol>
<li>有稳定的理化特性，保证电路的长期应用可靠性</li>
<li>与金属布线有很好的粘附性</li>
<li>便于RIE等加工</li>
</ol>
</li>
</ol>


<h2>high-k栅介质与金属栅</h2>

<ol>
<li>随着器件特征尺寸减小，栅氧厚度越来越小，随之带来的漏电流也增大，增加了耗电量</li>
<li>使用high-k材料作为栅极电介质，可以在减小等效栅氧厚度的同时不减小栅极电介质厚度</li>
<li>通常使用MOCVD或者ALD方法淀积high-k材料</li>
<li>有前景的high-k材料

<ol>
<li>HfO2，HfNO，Al2O3</li>
<li>目前HfO2是最常用的，但是HfO2与Si的界面不好，需要加入SiO2过渡层</li>
</ol>
</li>
<li>随着MOS栅长的缩短，为了保持栅控能力，抑制短沟道效应，必须加大单位面积的栅电容Cox。</li>
<li>一方面可以减小栅介质的厚度。栅长缩短到45nm，对应的SiO2栅厚度需要降低到接近1nm，这么薄的栅介质将引起两方面的问题：

<ol>
<li>1nm的势垒宽度已接近产生明显量子遂穿的宽度</li>
<li>1nm的栅介质很难阻止掺杂多晶硅中的掺杂原子向沟道内的扩散，尤其是B原子</li>
</ol>
</li>
<li>另一方面可以增大栅介质的介电常数。使得较大物理厚度的High-k栅介质与较薄的SiO2有相同的等效电容</li>
<li>多晶硅栅带来的问题

<ol>
<li>对于22nm技术时代，其EOT为0.5nm，对应的HfO2栅介质2nm，不足以阻挡多晶硅栅中的杂质（尤其是B）向沟道内扩散</li>
<li>参杂多晶硅是半导体，在一定的偏压下会出现界面载流子耗尽，额外引进一个等效厚度0.1~0.5nm的空间电离层，增大栅介质的等效厚度</li>
</ol>
</li>
<li>22nm一下技术代通常采用金属或金属硅化物，取代参杂多晶硅，作为栅极材料。</li>
<li>金属栅的优点：

<ol>
<li>无耗尽层的问题</li>
<li>无B穿通的问题</li>
<li>更低的串联电阻</li>
<li>抑制短沟道效应</li>
</ol>
</li>
<li>金属栅的缺点

<ol>
<li>NMOS和PMOS器件采用相同材料的金属栅，则器件的Vth（开启电压）不可能做小；</li>
<li>NMOS和PMOS器件采用不同材料的金属栅，则制造工艺复杂</li>
</ol>
</li>
</ol>


<h2>多晶硅薄膜的淀积</h2>

<ol>
<li>多晶硅薄膜的性质与用途

<ol>
<li>多晶硅薄膜是由无数微小晶粒组成的薄膜，晶粒大小与制备工艺有关，在晶粒与晶粒之间是晶界。晶界原子排列无序，含大量悬挂键以及高密度缺陷。硅多晶的结构特点造成它有一些与单晶不同的特性</li>
<li>杂质扩散系数大：晶界处>>晶粒内部</li>
<li>杂质在晶粒内部与晶界处分凝，分凝系数小于1，且随温度而变化，高温时晶粒内杂质在低温时运动到晶界处，而高温时又返回晶粒内部</li>
<li>特点：多晶硅有良好的高温工艺兼容性，与热生长SiO2有很好的接触性能，保形性良好，应力小</li>
<li>用途

<ol>
<li>MOS器件的栅电极及多层互连布线</li>
<li>自对准工艺中的硅删</li>
<li>在SRAM中用于制作高值负载电阻</li>
<li>MEMS器件中，制作压学传感器的应变电阻</li>
</ol>
</li>
</ol>
</li>
<li>LPCVD-Poly Si

<ol>
<li>源：硅烷</li>
<li>质量：淀积温度，淀积速率，总压力，硅烷分压，以及随后的热处理过程</li>
<li>可以在多晶硅生长同时进行原位掺杂</li>
</ol>
</li>
</ol>


<h2>CVD金属</h2>

<ol>
<li>钨机器化学气相淀积

<ol>
<li>用途：作导电填充物&ndash;插塞（plug）</li>
<li>作局部互连材料&ndash;W的导电率低，只用作短程互连线</li>
<li>特性：体电阻较小，热稳定性较高，但是超过400℃时，钨膜会被空气中的氧所氧化，较低的应力，良好的抗电迁移能力和抗腐蚀性</li>
</ol>
</li>
<li>LPCVD-W工艺

<ol>
<li>源：WF6</li>
</ol>
</li>
</ol>


<h2>金属化合物CVD</h2>

<ol>
<li>LPCVD-WSix

<ol>
<li>用途：在多晶硅/难熔金属硅化物的存储器芯片中被用作字线和位线，WSix也可作为覆盖式钨的附着层</li>
</ol>
</li>
<li>CVD-TiN

<ol>
<li>源：TiCl4</li>
<li>特性：TiN热稳定性好，基面结合强度高，导电性能好，杂质在TiN中的扩散激活能很高</li>
<li>用途：在多层互联系统中作为扩散阻挡层和（或）附着层使用</li>
</ol>
</li>
</ol>


<h2>MOCVD</h2>

<p>MOCVD常用来淀积三五族和二六族化合物薄膜</p>

<h2>能够生长单原子层的工艺</h2>

<p>MBE和ALD</p>

<h2>物理气相淀积PVD</h2>

<ol>
<li>PVD是利用某种物理过程实现物质转移，将原子或分子由源（或者靶）气相转移到硅衬底表面形成薄膜的过程</li>
<li>工艺特点：相对于CVD而言，工艺温度低，衬底在室温~几百℃；工艺原理简单，能用于制备各种薄膜。但是，所制备薄膜的台阶覆盖特性，附着性，致密性都不如CVD薄膜</li>
<li>用途：主要用于金属类薄膜，以及其他用CVD工艺难以淀积薄膜的制备。如金属电极，互联系统中的附着层、阻挡层合金以及金属硅化物薄膜的制备</li>
<li>分类：

<ol>
<li>真空蒸镀：在高真空室内加热原材料使之气化，源气相转移到达衬底，在产地表面凝结形成薄膜。有电阻蒸镀，电子束蒸镀，激光蒸镀</li>
<li>溅射：在一定真空度下，使气体等离子化，其中的离子轰击靶阴极，移出靶原子等粒子气相转移到达衬底，在衬底表面淀积成膜。有直流溅射、射频溅射、磁控溅射等</li>
</ol>
</li>
</ol>


<h2>真空蒸镀（普适性更好，无论什么材料都能用蒸镀工艺制备）</h2>

<ol>
<li>蒸镀指在高真空度下，加热源使其蒸发，蒸汽分子流射到衬底表面，凝结形成薄膜的工艺。可以将蒸镀分解为三个过程：

<ol>
<li>蒸发过程</li>
<li>气相质量输运过程</li>
<li>淀积成膜过程：吸附->成核->连片->生长</li>
</ol>
</li>
<li>台阶覆盖特性的改善方法

<ol>
<li>衬底加热，温度应依据所淀积薄膜的材料特性来综合考虑</li>
<li>衬底旋转，除了可以改善因到达角不同带来的台阶阴影区的薄膜覆盖问题之外，还可以改善淀积薄膜厚度的均匀性</li>
</ol>
</li>
<li>蒸发速率的控制

<ol>
<li>提高蒸发速率，能提高所淀积薄膜的纯度和与衬底的结合力，以及表面质量。蒸发速率过快，蒸汽原子碰撞会加剧，动能降低，甚至会引起蒸汽原子结团后再淀积，这将导致出现薄膜表面不平坦等质量问题</li>
</ol>
</li>
<li>蒸镀工艺，要求蒸镀室为高中空度的原因：

<ol>
<li>为了满足蒸发分子或原子平均自由程大于放源坩埚到衬底的距离</li>
<li>为了薄膜纯净（避免被泄露的O2，H2O污染）</li>
<li>为了避免蒸发分子或原子在气相被氧化</li>
</ol>
</li>
<li>气相金属源的获得

<ol>
<li>对于易熔金属，采用热蒸发</li>
<li>对于难熔金属，采用电子束</li>
</ol>
</li>
<li>膜厚较难控制，因为气体压强受温度影响很敏感</li>
<li>阴影效应，由于蒸发出的原子投影距离远，在衬底表面没有迁移或者反映</li>
</ol>


<h2>溅射</h2>

<ol>
<li>溅射工艺是利用等离子体中的离子对阴极靶轰击，导致靶原子等颗粒物飞溅，落到衬底表面淀积成膜的一种薄膜制备工艺</li>
<li>离子对靶的轰击

<ol>
<li>离子对处于负电位的靶轰击，使靶材料原子或者分子及其原子团从靶表面飞溅出来的过程。</li>
<li>能量在10eV~10KeV时，有中性离子逸出，不同材料的靶，溅射阈值能量不同</li>
</ol>
</li>
<li>靶原子气相运输

<ol>
<li>较低真空度下，靶原子在到达衬底表面前会与其他离子发生多次散射，衬底表面某点所到达的靶原子数与改点的到达角有关。高真空度下，气相运输轨迹是直线，衬底表面某点所到达的靶原子数是受遮蔽效应限制</li>
</ol>
</li>
<li>淀积成膜

<ol>
<li>到达衬底的靶原子在衬底表面先成核再成膜的过程</li>
<li>溅射离子与靶原子间有较大的能量传递，逸出原子携带的动量较高，在10~50eV之间。因此，原子在衬底的迁移能力、再发射能力都强，成膜的台阶覆盖性和附着力都较好</li>
</ol>
</li>
<li>溅射薄膜的质量及改善方法

<ol>
<li>薄膜的保形性覆盖特性较好</li>
<li>薄膜附着性较好</li>
<li>薄膜致密性较好，针孔少</li>
<li>淀积速率较慢，膜厚可控性和重复性较好</li>
<li>薄膜纯度较高，不存在蒸镀时无法避免的坩埚污染现象</li>
<li>淀积过程中对衬底辐射造成的缺陷远少于电子束蒸镀</li>
<li>在制备特殊材质薄膜上电子束蒸镀更有优势</li>
</ol>
</li>
<li>保形覆盖特性的改善

<ol>
<li>尽量提高衬底温度：以增强衬底所吸附的溅射粒子表面扩散迁移率，同时也要考虑温升后多晶态晶粒也随之长大，使得薄膜表面变粗糙</li>
<li>在衬底上加射频偏压：这使得衬底被高能离子轰击，有助于溅射粒子的再发射淀积，可在一定程度上改善保形覆盖特性</li>
<li>准直溅射技术：在衬底正上方插入准直器，只有速度方向接近于垂直衬底表面的溅射原子才能通过准直器上的孔，到达衬底表面，淀积在接触孔的底部</li>
</ol>
</li>
<li>特点：

<ol>
<li>常使用惰性气体的等离子体来轰击靶原子</li>
<li>靶源的面积大于衬底的面积能够改善均匀性和台阶覆盖性</li>
<li>靶和衬底之间的距离只有几个厘米</li>
<li>低的真空度，因为需要等离子体气体的存在</li>
<li>溅射到衬底的原子有足够的能量能够在产地表面迁移，改善台阶覆盖特性</li>
<li>便于控制薄膜厚度</li>
<li>成本较蒸发高</li>
</ol>
</li>
</ol>


<h2>PVD金属及化合物薄膜</h2>

<ol>
<li>铝及铝合金薄膜淀积

<ol>
<li>1um厚铝膜的电阻率约为3uΩ·cm，被用于器件内电极和互连布线的导电层</li>
<li>作内电极时，为与衬底硅形成良好的欧姆接触，通常淀积后在500℃左右退火，退火过程中有“尖楔”现象出现（界面中的Si向铝中扩散，而留下的位置又被铝填充），尖楔现象会引起pn结的穿通。可以用含硅1%的硅铝合金作为内电极</li>
<li>铝膜的抗电迁移特性差，在铝硅中再掺入2%左右的铜可以改善</li>
<li>制备：

<ol>
<li>真空镀铝

<ol>
<li>钨丝电阻加热器或石墨坩埚装铝电子束加热</li>
<li>方法简单，但钨丝加热器会引入杂质，衬底附着和台阶覆盖特性也较差</li>
</ol>
</li>
<li>磁控溅射铝及铝合金

<ol>
<li>薄膜附着力、台阶覆盖特性，以及膜厚可控性较好</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>铜及其阻挡层薄膜的淀积

<ol>
<li>Cu电阻率只有Al的40%~45%，抗电迁移性比铝能高两个数量级。早起IC不用铜作互连布线的原因：

<ol>
<li>中毒现象：Cu在Si和SiO2中都是快扩散杂质，在较低温度就能扩散进Si，会改变硅衬底的电学特性</li>
<li>工艺性差：Cu与Si、SiO2粘附性不好，图形刻蚀难
<img src="http://i.imgur.com/olKx6jF.png" alt="铜互连技术" /></li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>化学气相淀积与外延</h2>

<ol>
<li>化学气相淀积（CVD）是把构成薄膜物质的气态反应剂或液态反应剂的蒸汽以合理的流速引入反应室，在衬底表面发生化学反应，淀积成膜的工艺方法</li>
<li>淀积薄膜是非晶或多晶态，衬底不要求是单晶，只要是具有一定平整度，能经受淀积温度即可</li>
<li>CVD工艺主要用于制备SiO2，Si2N4等介质薄膜，poly-Si等半导体薄膜，另外，也用于制备金属化系统中常用的钨、金属硅化物等薄膜</li>
<li>CVD工艺制备的薄膜具有较好的性质，如附着性好，保形覆盖能力较高</li>
<li>不同CVD方法制备的薄膜，性质不同，用途也不同：

<ol>
<li>低温工艺制备的薄膜质地较疏松、密度低，抗腐蚀性较差，如低温SixNy用作保护膜</li>
<li>中温工艺薄膜密度高，抗腐蚀性好。如中温Si3N4用作腐蚀掩膜</li>
</ol>
</li>
<li>CVD与VPE相似，也可分为气相质量输运和表面化学反应两过程</li>
<li>CVD工艺衬底温度较外延工艺低、淀积速率快，而且衬底表面可以不是单晶；表面反应生成的薄膜原子在衬底上聚集成核，再连接成片、被覆盖成膜，没有外延的规则排列过程或排列不完全，所以，淀积薄膜是非晶或多晶态</li>
</ol>


<h2>CVD工艺反应剂气体分子到达衬底表面特殊位置的机制有：</h2>

<p><strong>扩散，再发射，表面迁移</strong></p>

<h2>金属化</h2>

<ol>
<li>多层金属化的数量达到10层</li>
<li>传统上金属互联电流密度达到10<sup>5A</sup>/cm2</li>
<li>金属互联引入了寄生电阻和电容，造成了RC delay，制约芯片的速度</li>
</ol>


<h2>金属膜的用途</h2>

<ol>
<li>互连金属：W、Al、Cu，W通常用作第一层金属，因为W耐高温，可以PVD</li>
<li>硅化物：TiSi2，CoSi2，NiSi，电导率没有金属好，在器件内部作为删极材料以降低电阻率</li>
<li>阻挡层：TiN，TaN</li>
</ol>


<h2>金属膜淀积方法</h2>

<ol>
<li>蒸发，台阶覆盖性差，间隙填充不好，膜厚难以控制</li>
<li>溅射，淀积Al非常常用，是个物理过程</li>
<li>金属氧化物CVD（MoCVD），台阶覆盖性好，最常用来淀积钨塞，现在也用来淀积Cu的仔层</li>
<li>铜的电镀，在大马士革工艺中淀积金属铜，衬底作为负极放入电解液中，铜作为阳极</li>
</ol>


<h2>金属铝的特性</h2>

<ol>
<li>优点：

<ol>
<li>低电阻率</li>
<li>易于淀积和刻蚀</li>
<li>与Si/SiO2的粘附性较好</li>
<li>与Si工艺兼容性好，价格便宜</li>
<li>与p+Si，n+Si或者Ploy-Si能形成欧姆接触</li>
</ol>
</li>
<li>缺点

<ol>
<li>抗电迁移性差</li>
<li>有尖楔现象</li>
<li>台阶覆盖性较差</li>
<li>耐腐蚀、稳定性较差</li>
</ol>
</li>
<li>Al/Si接触

<ol>
<li>只有跟重掺杂的n或者p型Si才能形成欧姆接触</li>
<li>为了形成好的接触，需要合金化</li>
<li>通常在400~450℃，在合成气体（H2/N2）中退火</li>
<li>在界面处消耗SiO2形成合金</li>
</ol>
</li>
<li>工艺

<ol>
<li>电子书蒸镀，磁控溅射，退火来提高粘附性和减小与SI的接触电阻</li>
</ol>
</li>
</ol>


<h2>Al金属化过程中的尖楔现象</h2>

<ol>
<li>硅在Al中有一定的固溶度，如果Si与Al接触，Si在界面处缓慢溶解到Al中，Al然后回填形成了Al的尖刺</li>
<li>解决方法：

<ol>
<li>在Al中掺入2%的Si形成Al/Si合金</li>
<li>使用金属阻挡层（TiN，TaN）</li>
<li>VLSI中需要金属阻挡层的保护，从而减少电子迁移率和应力迁移</li>
</ol>
</li>
</ol>


<h2>电迁移（不是电子的迁移，而是原子的迁移）</h2>

<ol>
<li>在大电流密度作用下，导电电子碰撞原子，动量转移，金属离子获得能量而迁移，引起金属线的空洞和小丘</li>
<li>当处于大电流密度以及高温时，电迁移更显著</li>
<li>解决方法：

<ol>
<li>在Al中掺入1~2%的Si和4%Cu，这些杂质在铝中的晶粒间界分凝，可降低铝原子在晶粒简介的扩散系数，来减少电迁移</li>
<li>用金属阻挡层包围Al线</li>
<li>采用电子束蒸镀比磁控溅射更能提高抗电迁移能力</li>
</ol>
</li>
</ol>


<h2>多层金属互联</h2>

<ol>
<li>大约需要10层金属互联</li>
<li>每一层都需要做平坦化工艺</li>
<li>需要刻蚀过孔，淀积金属塞</li>
<li>需要淀积金属层间介质（ILD），最常用的方法就是PECVD TEOS氧化膜</li>
<li>淀积low-k介质可以降低层间的电容</li>
</ol>


<h2>平坦化</h2>

<ol>
<li>局部平坦化使用回刻，比如金属钨塞</li>
<li>全局平坦化使用化学机械抛光CMP，其中使用的研磨液包括刻蚀的化学剂和粗糙的SiO2颗粒,刻蚀速率取决于旋转速度和施加的压力</li>
</ol>


<h2>金属钨塞的制备</h2>

<ol>
<li>LPCVD W</li>
<li>RIE的方式回刻，不需要掩膜</li>
</ol>


<h2>铜互联</h2>

<ol>
<li>铜的优点：

<ol>
<li>低电阻率</li>
<li>能抵抗电迁移</li>
<li>成本低</li>
</ol>
</li>
<li>铜互联的挑战:

<ol>
<li>其卤化物不易挥发，难以干法刻蚀，因此采用CMP来替代</li>
<li>和金属层间介质有粘附性问题，需要粘接层</li>
<li>在Si和介质中容易扩散造成污染，需要阻挡层</li>
<li>Cu的淀积很困难</li>
<li>双大马士革工艺制备Cu/low-k工艺</li>
</ol>
</li>
<li>对于Al/SiO2体系，0.25微米及以下技术代互联延迟已经超过门延迟，因此需要引入比Al电阻率更低的金属\比SiO2介电常数低的层间材料</li>
<li>对于Cu/low-k系统，0.13微米及以下技术代互联延迟也超过了门延迟，使得互联延迟成为了现代集成电路速度的“瓶颈”</li>
<li>铜互联的布局：下面几层的互联用很细的线条，上面几层的互联尽可能用比较宽的线条，比较厚的金属，以减小RC延迟</li>
</ol>


<h2>大马士革工艺（Damascene）</h2>

<ol>
<li>为什么需要用大马士革工艺

<ol>
<li>Al方便使用干法刻蚀加工，Cu无法干法刻蚀</li>
</ol>
</li>
<li>工艺流程

<ol>
<li>PECVD 层间介质（做通孔用）+氮化硅(etch stop layer)+层间介质（刻槽使用）</li>
<li>根据铜走线刻槽</li>
<li>利用氮化硅作掩蔽，刻相应的孔</li>
<li>溅射金属阻挡层（TaN），阻挡Cu扩散</li>
<li>电镀金属Cu</li>
<li>CMP抛光
<img src="http://i.imgur.com/DQA98JU.png" alt="大马士革工艺" /></li>
</ol>
</li>
</ol>


<h2>高深宽比的通孔的金属淀积</h2>

<ol>
<li>IMP（Ionized metel plasma）淀积，将溅射的原子离化后引导入深孔中</li>
<li>CVD的方式淀积金属，因为CVD有更好的保形性，比如金属W的回刻</li>
</ol>


<h2>刻蚀小的通孔</h2>

<ol>
<li>刻蚀速率需要特殊校准</li>
<li>刻蚀终点很难检测，因此要求大的over etch</li>
<li>选择比要高</li>
</ol>


<h2>硅化物</h2>

<ol>
<li>Si和金属会结合形成具有金属和半导体特征的混合物，如硅化物，TiSi2，WSi2</li>
<li>硅化物的电阻率相对较低，但比金属高，可以降低源漏端浅结的串联电阻，降低内部互连的多晶硅的电阻</li>
<li>硅化物的形成：在高温下，金属和硅的固相化学反应</li>
</ol>


<h2>自对准硅化物（Salicide）</h2>

<ol>
<li>理想的MOS器件应具备哪些结构和电学参数要求

<ol>
<li>源-栅，漏-栅之间的距离很近，减小沟道串联电阻</li>
<li>源-栅，漏-栅之间需要一个隔离层</li>
<li>源漏需要有良好的欧姆接触（硅化物），栅上需要低的串联电阻</li>
<li>漏端需要合理的参杂分布以舒缓漏端电场</li>
</ol>
</li>
<li>为了优化器件的漏端串联电阻，需要一个与栅自对准的复杂的参杂分布</li>
<li>为了优化器件的漏端电场分布，也需要一个与栅自对准的复杂的参杂分布</li>
<li>过程：

<ol>
<li>源漏离子注入后，淀积一层SiO2</li>
<li>RIE刻蚀，栅极形成侧墙（Stringer效应）</li>
<li>淀积金属，高温热退火</li>
<li>选择性地刻蚀金属材料，源漏栅都留下了一层硅化物薄膜</li>
</ol>
</li>
<li>自对准硅化物工艺中，源漏和栅极同时生长出一层硅化物薄膜，以一种自对准的方式</li>
<li>热退火的要求非常苛刻，会消耗一定的Si</li>
<li>栅极两侧的侧墙保证了源漏的化学反应的独自进行，并保证了源漏的深掺杂远离栅极</li>
<li>两方面的自对准

<ol>
<li>掺杂与栅</li>
<li>硅化物在源、漏、栅上，STI和spacer上没有</li>
</ol>
</li>
<li>为什么要用栅自对准结构？

<ol>
<li>漏端串联电阻优化</li>
<li>漏端电场优化</li>
</ol>
</li>
<li>栅掩蔽注入掺杂实现自对准的作用

<ol>
<li>掺杂分布与栅的位置自然对准，不存在套版偏差</li>
</ol>
</li>
<li>硅化物自对准的作用

<ol>
<li>减小源漏接触电阻</li>
<li>减小栅极串联电阻
<img src="http://i.imgur.com/avHEO8z.png" alt="Salicide后的CMOS器件" /></li>
</ol>
</li>
</ol>


<h2>金属阻挡层材料</h2>

<ol>
<li>Al：Ti，TiN，淀积方法：IMP</li>
<li>Cu：Ta，TaN，淀积方法：IMP</li>
</ol>


<h2>金属化材料分类</h2>

<ol>
<li>互连材料：指将同一芯片内的各个独立的元器件连接成为具有一定功能的电路模块</li>
<li>接触材料：指直接与半导体材料接触的材料以及提供与外部相连的连接点</li>
<li>MOSFET栅电极材料：作为MOSFET器件的一个组成部分，对器件的性能起着重要作用</li>
</ol>


<h2>集成电路对互联布线有以下要求</h2>

<ol>
<li>布线材料有低的电阻率和良好的稳定性</li>
<li>布线应具有强的抗电迁移能力</li>
<li>布线材料可被精细刻蚀，并具有抗环境侵蚀的能力</li>
<li>布线材料易于淀积成膜，粘附性要好，台阶覆盖性要好，并有良好的可焊性</li>
</ol>


<h2>PN结隔离特点、用途</h2>

<ol>
<li>工艺成熟，方法简单，成品率高，实现了平面隔离</li>
<li>PN结有反向漏电流现象，反向漏电受温度、辐射等外部环境影响大</li>
<li>密度低，有寄生电容，器件速度做不快</li>
<li>当隔离很深的器件时，需要深的PN结，因此掺杂的时候需要很长的推进时间</li>
<li>横向扩散严重，降低了器件密度</li>
<li>用途

<ol>
<li>BJT器件的PN结隔离

<ol>
<li>会带来寄生的MOSFET（金属上的电压使得npn反型，形成了MOSFET）</li>
<li>反向电压增大导致耗尽区长大，本体穿通。为了避免耗尽区的靠近相连，使用guard ring保护</li>
</ol>
</li>
<li>Well-in CMOS

<ol>
<li>寄生的NPNP结构（由NMOS的有源区、P衬底、N阱、PMOS的有源区构成）会带来闩锁效应（当其中一个三极管正偏时，就会构成正反馈形成闩锁），在闩锁情况下，器件在电源和地之间形成短路，造成大电流</li>
</ol>
</li>
</ol>
</li>
<li>注意事项

<ol>
<li>避免反向电压击穿，和严重的漏电流</li>
<li>避免反型带来的寄生MOSFET</li>
<li>避免闩锁效应</li>
</ol>
</li>
</ol>


<h2>浅槽隔离</h2>

<ol>
<li>LOCOS的问题

<ol>
<li>鸟嘴问题：氧化时的横向扩展；氧化层的厚度500nm左右，扩展的尺寸也是这个量级，但目前22nmCMOS器件整个有源区的尺寸也仅仅在100nm量级。鸟嘴属于无用的过渡区，对提高集成电路的集成度极其不利</li>
<li>不平坦的问题：有250nm左右的隆起</li>
<li>应力的问题，鸟嘴处的应力过大</li>
<li>对刻蚀要求高

<ol>
<li>侧壁光滑</li>
<li>夹角不大于85℃</li>
</ol>
</li>
<li>沟道处的杂质在氧化过程中重分布</li>
<li>器件边缘会有寄生晶体管</li>
</ol>
</li>
<li>回刻LOCOS工艺，方法简单，通过回刻除去部分场氧化层，使表面平坦并恢复部分被鸟嘴占去的有源区。有源区的边缘应力过于集中，造成晶格缺陷，进一步在边缘区产生大的漏电流</li>
<li>STI（Shallow Trench Insulation with CMP）

<ol>
<li>在硅片上淀积一层pad oxide（垫氧层），用来舒缓应力</li>
<li>淀积氮化硅层，作为硬掩膜</li>
<li>光刻定义需要隔离的区域</li>
<li>利用硬掩膜刻蚀底下硅的浅槽</li>
<li>离子注入，做STI隔离的高参杂层（Channel stop implant）</li>
<li>热氧化的方法在槽的底部生长一层很薄的氧化层，光滑且阻挡效果好</li>
<li>用PECVD TEOS淀积比较厚的介质</li>
<li>用CMP的方法把多余的介质去除掉（此时氮化硅作为CMP的截止层）</li>
<li>湿法刻蚀（热磷酸）去除氮化硅</li>
</ol>
</li>
<li>STI的优点

<ol>
<li>有效的隔离，并且很紧凑</li>
</ol>
</li>
<li>STI注意事项

<ol>
<li>氧化物回填的过程中需要避免中间形成空洞，常使用高密度的等离子体CVD工艺</li>
<li>沟槽侧壁因为干法刻蚀而粗糙，需要先使用liner oxidation来光滑</li>
<li>沟槽底部拐角处的介质很容易被击穿，造成大的漏电流，因此需要对拐角处做圆角处理</li>
</ol>
</li>
<li>CMOS器件为什么还需要隔离：第一层布线的时候可能会引起下面半导体表面反型，从而使得器件和相邻器件之间的井有可能穿通</li>
</ol>


<h2>器件隔离的要求</h2>

<ol>
<li>工艺简单，成本低，良率高</li>
<li>占用面积小，从而提高器件密度</li>
<li>不影响表面形貌，台阶覆盖性要求好</li>
<li>有效并且可靠，相邻器件必须被有效隔离，并且能够承受较高的击穿电压，带来更少的寄生电容（寄生电容影响器件速度）</li>
</ol>


<h2>常用的隔离方案：PN结，LOCOS，STI，SOI</h2>

<h2>Channel stop implant作用</h2>

<blockquote><p>提高场区寄生MOSFET的阈值电压</p></blockquote>

<h2>SOI</h2>

<ol>
<li>是一种特殊的衬底，在氧化硅上有一层薄的单晶硅</li>
<li>将不需要的Si刻蚀就能实现完美的隔离效果，寄生电容小，器件密度可以做的非常高，消除了闩锁效应</li>
<li>价格昂贵</li>
<li>器件特性会有轻微差异，原因是浮体效应</li>
<li>制备SOI的技术

<ol>
<li>SIMOX（通过离子注入氧离子来分离）

<ol>
<li>超高剂量的氧离子被注入到衬底</li>
<li>高温热退火修复上层硅片的损伤</li>
<li>未被破坏的表面单晶硅层作为仔层外延生长一层单晶硅</li>
<li>缺点：会破坏上层单晶硅</li>
</ol>
</li>
<li>Smart Cut

<ol>
<li>需要两个单晶硅衬底A和B，A衬底叫做seed wafer，B衬底叫做handle wafer</li>
<li>将A衬底氧化，形成BOX（buried oxide）</li>
<li>离子注入H+离子到氧化后的A衬底中</li>
<li>A衬底翻过来和B衬底粘合在一起（A的氧化层和B的Si粘合起来）</li>
<li>高温热退火，由于SiO2中的H+的存在使得A衬底部分松动脱落</li>
<li>CMP平坦化，减小上层硅的厚度</li>
<li>缺点：上层硅的厚度难以控制</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>典型的CMOS制造工艺流程</h2>

<ol>
<li>Front-end process，用来制造CMOS器件</li>
<li>Back-end process，用来制造器件之间的互连线</li>
</ol>


<h2>工艺集成中的一些原则</h2>

<ol>
<li>后续工艺不能影响已形成材料和掺杂结构的稳定，所以原则上讲后续工艺的温度要低于前面工艺</li>
<li>前面工艺的掺杂要尽可能采用扩散系数小的参杂元素</li>
<li>前面工艺要尽可能采用稳定的材料结构</li>
<li>要注意控制整个工艺集成过程的thermal budget，对于前歩工艺形成的掺杂结构，要把后步工艺对其杂质再分布的影响也考虑在内</li>
<li>要避免引入Na/K/Pt/Au等快扩散元素和重金属元素，实在不可避免时候（例如Cu作为互连材料），要注意设置阻挡层</li>
</ol>


<h2>CMOS集成电路的工艺集成</h2>

<p><img src="http://i.imgur.com/swGgvvs.png" alt="CMOS集成电路工艺集成" />
1. CMOS IC的基本工艺模块
    1. 阱，在衬底上形成的、参杂类型与硅衬底相反的区域
    2. 栅电极，双掺杂多晶硅栅工艺保持对称性
    3. 源漏结构，轻掺杂（LDD：Low Doping Drain）；源漏扩展结构（S/D Extension）；晕环（Halo）或袋状（Pocket）结构
    4. 自对准和接触，自对准指利用单一掩膜版在硅片上形成多层自对准结构；利用硅化物（TiSi2，CoSi2，NiSi2，WSi2）形成良好的欧姆接触，以减少串联电阻
2. 一般CMOS工艺采用100晶向的硅
<img src="http://i.imgur.com/IBB3aJj.png" alt="CMOS加工步骤" />
3. CMOS加工步骤
    1. 加工器件之间隔离所需要的STI（Shallow Trench Lsolation），目的是定义有源区（MOS器件工作的区域）
    2. 利用高能离子注入，分别为PMOS和NMOS器件制造p阱和n阱（Twin-well Implants），目的是使器件具有预期的阈值电压，同时抑制可能的穿通效应。做完N阱和P阱之后，需要对沟道进行掺杂，掺杂元素能够与需要的器件的阈值电压相匹配，同时整个沟道尽量不向下扩展（否则容易引起器件的穿通）。因此沟道掺杂包括：防穿通注入，调整阈值电压注入
    3. 制备超薄栅介质和光刻刻蚀多晶硅栅电极，工艺要求最高（光刻时候线条非常细，如22纳米工艺的栅宽只有22纳米，栅的厚度有几百个纳米，而且将来需要很陡直的刻蚀，并且能够停在几纳米的栅介质上）
    4. 利用栅掩蔽形成自对准的源漏轻掺杂区（LDD Implants），也叫源漏延伸（extension）区。为了进一步优化栅下沟道区的杂质分布，分别用光刻胶保护住PMOS区域和NMOS区域，采用大角度倾斜注入的办法分别对PMOS和NMOS栅的侧下方进行N型杂质和P型杂质的补充掺杂，目的是优化器件的串联电阻和防穿通性能
    5. 形成栅两侧的Si3N4 spacer层（Sidewall Spacer），首先淀积各向同性的氮化硅，然后RIE各向异性刻蚀，把栅和源漏表面的氮化硅刻蚀掉，保留栅侧面的氮化硅。Spacer层起到栅和源漏接触之间的绝缘
    6. 利用带Spacer层的栅作为掩蔽，来注入形成自对准的源漏接触掺杂区（S/D Implants）
    7. 制备自对准硅化物（如TiSi2），形成欧姆接触（Contact Formation）
    8. 形成多层金属互联
    9. 制作钝化层
    10. I/O引出Pad
<img src="http://i.imgur.com/7HcTYkt.png" alt="Halo注入" />
<img src="http://i.imgur.com/62NsBsK.png" alt="形成多层金属互联" /></p>

<h2>双极性集成电路的工艺集成</h2>

<p><img src="http://i.imgur.com/P2fWqyU.png" alt="双极集成电路" />
1. 优势：高速，驱动能力强
2. 缺点：功耗大，集成度差
3. 工艺
    1. 制作埋层
    2. 生长n型外延层
    3. 形成横向氧化物隔离区
    4. 形成基区
    5. 形成接触孔
    6. 形成发射区
    7. 金属化
    8. 合金化
    9. 形成钝化层</p>

<h2>CMOS scaling中的若干问题</h2>

<ol>
<li>特征尺寸不断缩小的背后，伴随着新材料、新结构、新工艺不断的引入。

<ol>
<li>180nm：Saclicide中硅化物材料用CoSi2替代TiSi2</li>
<li>130nm：采用Cu布线替代Al布线</li>
<li>90nm：引入应变Si沟道；更多的采用NiSi；在Cu布线中引入Low-k介质</li>
<li>45nm：引入High-k栅介质；光刻版引入DFM（Design for manufacture）</li>
<li>32nm：引入浸润式光刻（Immersion）</li>
<li>22nm：光刻采用双曝光技术（DPT）；金属栅</li>
<li>14-16nm：放弃一直沿用的“平面器件结构”，引入FinFET（multi-gate）结构器件</li>
</ol>
</li>
<li>Gate-last技术：为了避免源漏自对准注入之后的高温退火对金属栅和high-k介质的影响，采用先制备一个替代栅用于形成自对准源漏，之后再填充介质、CMP露出替代栅，腐蚀掉替代栅，并替换成金属栅
<img src="http://i.imgur.com/z313zxt.png" alt="FinFET器件结构" /></li>
<li>平面结构MOS器件，栅控是在沟道一侧完成的，而FinFET的栅控是两侧同时进行的，这样在同样Cox下，它的栅控能力得到很大的改进</li>
<li>为什么14-16nm工艺代需要采用FinFET器件结构

<ol>
<li>对于20-22nm技术代，栅介质的EOT要降到0.4nm左右，即使采用HfO2高k介质，其物理厚度也仅1.6nm，已经接近了量子遂穿的极限，栅介质EOT的压力使得16nm以后需采用FinFET（multi-gate）器件结构</li>
</ol>
</li>
<li>进一步Scaling Down的主要挑战

<ol>
<li>目前无法批量实现亚14nm的光刻分辨率：电子束光刻的速度太慢，无法满足量产，EUV光刻技术迟迟不能取得突破</li>
<li>随着尺寸缩小，沟道迁移率急剧下降，需要引进新的高迁移率沟道材料：在Si衬底上外延新材料已经相应的栅和源漏优化都是繁重的工作</li>
<li>需要采用更新的器件结构，一方面适应进一步提高器件栅控能力的要求，另一方面适应进一步降低器件电路工作电压的要求</li>
</ol>
</li>
<li>可能的新沟道材料

<ol>
<li>NMOS器件沟道用化合物材料，如InAs</li>
<li>PMOS器件沟道用Ge材料</li>
</ol>
</li>
</ol>


<h2>基本的CMOS工艺</h2>

<ol>
<li>N阱离子注入</li>
<li>同时进行推进和氧化</li>
<li>去除氮化硅保护膜</li>
<li>制作AA区和LOCOS隔离</li>
<li>针对阈值电压调节的离子注入</li>
<li>栅极氧化以多晶硅栅制备</li>
<li>源漏分别做离子注入</li>
<li>ILD淀积保护膜，打通孔</li>
<li>布第一层金属，钝化膜</li>
</ol>


<h2>闩锁效应</h2>

<ol>
<li>闩锁效应是由NMOS的有源区、P衬底、N阱、PMOS的有源区构成的n-p-n-p结构产生的，当其中一个三极管正偏时，就会构成正反馈形成闩锁。</li>
<li>MOS工艺含有寄生的双极型晶体管。在CMOS工艺下，阱与衬底结合会导致寄生的n-p-n-p结构。这些结构会导致VDD和VSS线的短路，从而通常会破坏芯片，或者引起系统错误。</li>
<li>避免闩锁的方法就是要减小衬底和N阱的寄生电阻，使寄生的三极管不会处于正偏状态</li>
<li>防御措施：

<ol>
<li>在输入端和输出端加钳位电路，使输入和输出不超过不超过规定电压</li>
<li>芯片的电源输入端加去耦电路，防止VDD端出现瞬间的高压</li>
<li>在VDD和外电源之间加限流电阻，即使有大的电流也不让它进去</li>
</ol>
</li>
</ol>


<h2>双阱工艺（Twin-Well）</h2>

<ol>
<li>传统的单阱工艺，器件部分需要8~10个Mask</li>
<li>现代的双阱工艺，器件部分需要9~10个Mask

<ol>
<li>N阱掩膜</li>
<li>P阱掩膜</li>
<li>有源区掩膜</li>
<li>p场注入掩膜</li>
<li>耗尽型n管掩膜</li>
<li>多晶硅栅掩膜</li>
<li>n+源漏注入掩膜</li>
<li>p+源漏注入掩膜</li>
<li>接触孔掩膜</li>
</ol>
</li>
<li>双阱cmos工艺采用p型硅晶圆片作为衬底，在衬底上做出N阱，用于制作PMOS晶体管，在衬底上做出p阱，用于制作nMOS晶体管。</li>
<li>相比单阱工艺，双阱工艺的优势：NMOS和PMOS能够单独做优化。但是双阱工艺占用面积更大，工艺更复杂</li>
</ol>


<h2>传统NPN BJT工艺流程（6~7个Mask）</h2>

<ol>
<li>埋层注入（n+），需要掩膜</li>
<li>n-Si外延层生长</li>
<li>氧化与guard ring隔离，需要掩膜</li>
<li>基区离子注入，需要掩膜</li>
<li>发射极和集电极离子注入，需要掩膜</li>
<li>形成基区，发射区，集电区的接触孔，金属的图形转移，需要掩膜</li>
<li>制作钝化层，需要掩膜</li>
<li>金属化，需要掩膜</li>
</ol>


<h2>自对准BJT工艺</h2>

<p><img src="http://i.imgur.com/ua0pGfz.png" alt="高性能BJT结构" />
<img src="http://i.imgur.com/rG85e9z.png" alt="自对准BJT工艺" />
1. 特点：
    1. 利用多晶硅做发射极，提高了器件性能
    2. 埋层集电极
    3. 自对准多晶硅基极
    4. STI/LOCOS隔离
    5. 需要10~11层的Mask
    6. 器件密度不如CMOS，成本比CMOS高
2. 主要用途：
    1. 射频器件，工作频率可以做到10~30GHz
    2. 大驱动能力的模拟器件
3. 工艺
    1. P-硅衬底上制作埋层集电极
    2. n-Si外延层生长
    3. LOCOS隔离
    4. 生长一层薄的氧化层，有源区图形化
    5. 淀积P+多晶硅，然后在上面淀积一层LTO
    6. 刻蚀，暴露有源区
    7. 制作侧墙spacer（先LTO在回刻）
    8. 淀积n+多晶硅，图形化后作为发射极
    9. 热退火，将重掺杂的n多晶硅和p多晶硅中的杂质扩散到衬底中形成发射区与基区</p>

<h2>BiCMOS工艺（BJT+CMOS）</h2>

<ol>
<li>最复杂的工艺技术，不是市场主流，制约该工艺的瓶颈是BJT</li>
<li>需要约15层的Mask来制作器件</li>
<li>集成了CMOS低功耗的特点与BJT高速的特点</li>
<li>随着CMOS器件尺寸逐步减小，BiCMOS工艺的优势越来越弱</li>
</ol>


<h2>Device Scaling要求</h2>

<ol>
<li>沟道表面有一定的势垒，减小漏电流</li>
<li>更好的栅控能力（比如使用Multi-gate工艺）</li>
<li>方案：

<ol>
<li>增加Cox（降低tox或者使用high-k介质材料）</li>
<li>浅结（降低源漏对沟道的影响，增加栅对沟道的影响）</li>
<li>增加沟道参杂</li>
</ol>
</li>
<li>问题

<ol>
<li>沟道的载流子散射增加了，降低了迁移率</li>
<li>可靠性降低了，器件变小，电场增加了，更容易击穿，可以通过降低电压来维持稳定性</li>
<li>浅结带来的源漏的寄生电阻的增加</li>
</ol>
</li>
</ol>


<h2>短沟道器件结构</h2>

<p><img src="http://i.imgur.com/7aAjDdU.png" alt="短沟道器件结构" />
1. 为了抑制段沟道效应，采用了很多手段来优化栅极，源漏以及沟道的组成
    1. 栅极材料的选择
    2. 沟道掺杂表面浓度低，底下浓度高
    3. halo-implant来避免沟道底部的本体穿通（阻挡S/D对沟道的影响，通过大角度的围绕着沟道的离子注入）
    4. 浅的源漏延伸
        1. 浅结
        2. 掺杂浓度低
        3. 降低了S/D串联电阻
        4. LDD降低了耗尽区的电场强度，减少了热载流子影响，优化了源漏电场分布</p>

<h2>倒退阱（Retro-grade Well）</h2>

<ol>
<li>一般的，沟道表面参杂浓度会更高，但是在倒退阱中，表面掺杂浓度低于沟道参杂浓度</li>
<li>这样会提高载流子迁移率，增加对闩锁效应和本体穿通的体抗力</li>
<li>制备手段

<ol>
<li>高能量的深离子注入</li>
<li>epi-wafer上的外延生长</li>
</ol>
</li>
</ol>


<h2>栅介质材料</h2>

<ol>
<li>high-k介质材料通常使用的淀积工艺：ALD和MOCVD</li>
<li>通常high-k材料与Si的界面接触特性不好</li>
<li>High-k与金属的兼容性不好</li>
<li>High-k的热稳定性不好</li>
<li>要求high-k介质薄膜很薄</li>
</ol>


<h2>N+多晶硅栅与N+/P+多晶硅栅</h2>

<ol>
<li>N+多晶硅栅

<ol>
<li>使用广泛，因为工艺简单</li>
<li>在淀积多晶硅栅的同时原位重掺杂P元素</li>
<li>PMOSFETs需要阈值电压调节注入</li>
<li>问题（主要原因在于n+与n和n+与p的功函数差很大）：

<ol>
<li>大的漏电流</li>
<li>严重的本体穿通问题</li>
</ol>
</li>
</ol>
</li>
<li>P+/N+多晶硅栅

<ol>
<li>NMOS用N+多晶硅，PMOS用P+多晶硅</li>
<li>降低了漏电流和本体穿通的几率</li>
<li>对短沟道器件很有必要</li>
<li>源漏离子注入的同时可以进行多晶硅参杂，可以实现对称的沟道表面</li>
<li>问题

<ol>
<li>硼渗透问题，解决方法：多晶硅分层，SiO2中掺N</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>金属栅与High-k</h2>

<ol>
<li>多晶硅与high-k介质兼容性不好的原因：

<ol>
<li>多晶硅栅的电势降落导致EOT增大</li>
<li>多晶硅与high-k界面的不稳定性</li>
</ol>
</li>
<li>双金属栅工艺

<ol>
<li>为了NMOS与PMOS的阈值电压对称，需要使用不同功函数的金属</li>
<li>MOS晶体管自对准工艺需要改进，变成：Gate-last 工艺</li>
</ol>
</li>
<li>金属栅工艺流程
<img src="http://i.imgur.com/1cYBrSt.png" alt="金属栅制备流程1" />
<img src="http://i.imgur.com/h0K4joj.png" alt="金属栅制备流程2" />

<ol>
<li>标准的STI隔离，双阱和沟道的掺杂</li>
<li>ALD一层high-k介质膜</li>
<li>LPCVD多晶硅牺牲层，并在两侧形成侧墙</li>
<li>源漏掺杂，并未PMOS的源漏外延生长SiGe层（给Si沟道引入压应力，空穴迁移率增加）

<ol>
<li>用应力的方式增强沟道迁移率，提高驱动电流，降低漏电流</li>
<li>SiGe外延属于异质外延，造成晶格错位</li>
<li>另外一种引入应力的方式是在NMOS外面包一层Si3N4，给沟道带来张应力，电子迁移率增加</li>
</ol>
</li>
<li>CVD淀积氧化层，接着CMP平坦化</li>
<li>将多晶硅牺牲层刻蚀掉</li>
<li>选择性淀积PMOS的第一层金属（与P-si有小的功函数差）</li>
<li>淀积NMOS的第一层金属（与N-si有小的功函数差）</li>
<li>填充Al，然后平坦化</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cortex-M0]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/06/cortex-m0/"/>
    <updated>2015-10-06T12:23:50+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/06/cortex-m0</id>
    <content type="html"><![CDATA[<h2>ARM体系变种</h2>

<ol>
<li>M变种：

<ol>
<li>长乘法操作：32位整数乘以32位整数，生成64位整数</li>
<li>长乘加操作：32位整数乘以32位整数，加上32位整数，生成64位整数</li>
</ol>
</li>
<li>T变种：

<ol>
<li>Thumb指令集是ARM指令集的一个子集重新编码而成的，它使ARM更加高效地进行运作</li>
</ol>
</li>
<li>E变种：

<ol>
<li>增加了新的16位数据乘法与乘加操作指令</li>
<li>实现饱和的带符号数的加减法操作指令</li>
<li>进行双字数据操作的指令，包含LDRD、STDR、MCRR\MRRC</li>
<li>cache预取指令PLD</li>
</ol>
</li>
<li>J变种：

<ol>
<li>Jazelle技术：将Java代码运行速度提高了8倍，功耗降低了80%</li>
</ol>
</li>
<li>SIMD变种：

<ol>
<li>可同时进行两个16位操作数或者4个8位操作数的运算</li>
<li>用户可以定义饱和运算模式</li>
<li>32位乘以32位的小数MAC</li>
<li>音频\视频处理性能提高了4倍</li>
<li>提供小数算数运算</li>
<li>两套16位操作数的乘加\乘减运算</li>
</ol>
</li>
</ol>


<h2>ARM处理器系列</h2>

<ol>
<li>ARM7系列

<ol>
<li>小型、快速、低能耗、集成式的RISC芯片</li>
<li>冯诺依曼体系结构</li>
<li>三级流水线制</li>
<li>优秀的调试机制</li>
</ol>
</li>
<li>ARM9、ARM9E系列

<ol>
<li>哈佛体系结构：这种体系结构是一种将程序指令存储和数据存储分开的存储器结构，是一种并行体系结构</li>
<li>支持32位的ARM指令和16位Thumb指令</li>
<li>支持一般的操作系统</li>
<li>五级流水处理及分离的Cache结构</li>
<li>ARM9E内核在ARM9内核的基础上增加了紧密耦合存储器的TCM及DSP部分</li>
</ol>
</li>
<li>ARM10E系列

<ol>
<li>支持AMBA总线接口（包含AHB，ASB总线）</li>
<li>六级流水线制</li>
<li>包含DSP指令集</li>
<li>可选浮点协处理器</li>
<li>统一的数据cache和指令cache</li>
<li>能够支持多种商用操作系统</li>
</ol>
</li>
<li>ARM11系列(ARM V6结构)

<ol>
<li>针对媒体处理的SIMD</li>
<li>用以提高安全性能的TrustZone技术</li>
<li>智能能源管理IEM</li>
<li>系统多处理技术</li>
</ol>
</li>
<li>SecurCore系列

<ol>
<li>采用软内核技术</li>
<li>提供面前智能卡和低成本的存储保护单元</li>
<li>可集成用户自己的安全特性和其他处理器</li>
<li>极具安全性</li>
</ol>
</li>
<li>Cortex系列处理器

<ol>
<li>ARM公司在经典处理器ARM11以后的产品改用Cortex命名，并分成A、R和M三类，旨在为各种不同的市场提供服务</li>
<li>A系列面向尖端的基于虚拟内存的操作系统和用户应用</li>
<li>R系列针对实时系统</li>
<li>M系列针对成本和功耗敏感的MCU和终端应用</li>
</ol>
</li>
</ol>


<h2>Cortex-M0/M0+</h2>

<ol>
<li>CortexM0/M0+均是ARMv6M架构,均支持Thumb指令集，支持NVIC和WIC，但不支持Thumb2指令集，其中M0是三级流水线架构，M0+是二级流水线架构</li>
<li>CortexM3，CortexM4均是ARMv7M架构，均支持Thumb，Thumb2指令集，支持NVIC和WIC；CortexA5，CortexA8，CortexA9均是ARMv7A架构</li>
<li>存储器模型：<img src="http://i.imgur.com/KKgz65f.png" alt="ARM CortexM存储器模型" />

<ol>
<li>4GB可寻址线性空间</li>
<li>标准实现，适用于所有Cortex-M系列</li>
<li>无须paging和banking</li>
<li>软件访问可访问性</li>
</ol>
</li>
<li>两种工作模式

<ol>
<li>Thread模式</li>
<li>Handler模式</li>
</ol>
</li>
<li>异常模型

<ol>
<li>异常发生->加载向量列表->异常处理->返回</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+寄存器</h2>

<ol>
<li>32位位宽寄存器：

<ol>
<li>13个通用寄存器：

<ol>
<li>R0-R7（Low registers）</li>
<li>R8-R12(High registers)</li>
</ol>
</li>
<li>3个特殊用处寄存器

<ol>
<li>SP-R13，初始值：0x00000000</li>
<li>LR-R14</li>
<li>PC-R15，初始值0x00000004,Bit[0]为1，表示当前为Thumb代码</li>
</ol>
</li>
<li>特殊寄存器

<ol>
<li>PSR（Program Status Register）</li>
<li>PRIMASK（Interrupt mask register），仅有Bit[0],值为1表示关闭所有中断，只有NMI和硬件错误才能被响应，缺省值为0</li>
<li>CONTROL（control register），只有Bit[0]（定义权限级别，0表示特权级线程模式，1表示普通线程模式，所有的Handler模式都是特权级模式）和Bit[1]（选择当前使用哪个栈指针，0表示选择主栈指针MSP，1表示选择进程栈指针PSP）</li>
</ol>
</li>
</ol>
</li>
<li>寄存器使用方法

<ol>
<li>R0-R3：传递函数参数，返回函数结果，因此也称为a1-a4；也可用于程序内部保存临时变量</li>
<li>R4-R11：保存程序内部的变量值，因此又称为v1-v8，其中r9是个平台相关的寄存器，需要半导体厂商自己定义</li>
<li>R12-R15：专门用途寄存器，R12-IP</li>
</ol>
</li>
<li>程序状态寄存器PSR

<ol>
<li>APSR(Application Program Status Register)，包括Negative，Zero，Carry和Overflow的标志位</li>
<li>IPSR(Interrupt Program Status Register)，包括Exception number(前6位)</li>
<li>EPSR(Execution Program Status Register)，包括Thumb code is executed的指示位</li>
<li>程序状态寄存器的访问指令：MSR和MRS</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+指令集</h2>

<ol>
<li>每条Thumb指令有相同处理器模型所对应的32位ARM指令，比如可以将Thumb指令ADD Rd，#immed_8转换为ARM指令ADD Rd，Rd，#immed_8</li>
<li>Thumb的56条指令分类：

<ol>
<li>存储器访问指令

<ol>
<li>ADR:Generate PC-relative address</li>
<li>LDM:Load Multiple registers</li>
<li>LDR{type}:Load Register using immediate offset</li>
<li>LDR{type}:Load Register using register offset</li>
<li>LDR:Load Register from PC-relative address</li>
<li>POP:Pop register from stack</li>
<li>PUSH:Push registers onto stack</li>
<li>STM:Store Multiple registers</li>
<li>STR{type}:Store Register using immediate offset</li>
<li>STR{type}:Store Register using register offset</li>
</ol>
</li>
<li>数据处理指令</li>
<li>分支和控制指令

<ol>
<li>B{cc}:Branch {conditionally},如果使用了条件执行，那么跳转范围在-256~254字节内；如果没有使用条件执行，那么跳转范围在±1M内</li>
<li>BL:Branch with Link,跳转范围±16MB</li>
<li>BLX:Branch indirect with Link</li>
<li>BX:Branch indirect</li>
</ol>
</li>
<li>杂项指令

<ol>
<li>MRS:Move from special register to register</li>
<li>MSR:Move from register to special register</li>
<li>CPSID:Change Processor State,Disable Interrupts,C语言操作函数:void __disable_irq(void);</li>
<li>CPSIE:Change Processor State,Enable Interrupts,C语言操作函数：void __enable_irq(void);</li>
<li>WFE:Wait For Event,C语言操作函数：void __WFE(void);</li>
<li>WFI:Wait For Interrupt,C语言操作函数：void __WFI(void);</li>
<li>NOP:No Operation,C语言操作函数：void __NOP(void);</li>
<li>SVC:Supervisor Call</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+外设</h2>

<ol>
<li>外设的映射

<ol>
<li>Private Peripheral Bus（PPB）的映射(0xE0000000-0xE00FFFFF)</li>
<li>SysTick:24位计数器，扩展的NVIC特性</li>
<li>NVIC：中断设置与配置</li>
<li>SCB:提供系统实现和系统控制；包括配置、控制和上报系统异常</li>
<li>MPU（Memory Protection Unit）</li>
</ol>
</li>
<li>NVIC接口API：

<ol>
<li>void NVIC_EnableIRQ(IRQn_t IRQn);</li>
<li>void NVIC_DisableIRQ(IRQn_t IRQn);</li>
<li>uint32_t NVIC_GetPendingIRQ(IRQn_t IRQn);</li>
<li>void NVIC_SetPendingIRQ(IRQn_t IRQn);</li>
<li>void NVIC_ClearPendingIRQ(IRQn_t IRQn);</li>
<li>void NVIC_SetPriority(IRQn_t IRQn,uint32_t priority);</li>
<li>uint32_t NVIC_GetPriority(IRQn_t IRQn);</li>
<li>void NVIC_SystemReset(void);请求一次系统复位</li>
</ol>
</li>
</ol>


<h2>ARM Cortex-M0+可执行镜像</h2>

<ol>
<li>ELF：定义了对象文件的内容和格式</li>
<li>BIN：直接的内存镜像</li>
<li>HEX：包含了目标程序镜像的存储地址</li>
<li>AXF：ARM工具链产生，BIN文件内容+调试信息</li>
</ol>


<h2>WEAK和alias属性</h2>

<ol>
<li>当两个或者两个以上行数具有相同的名字，并其中之一声明为weak属性时，则不会引发重定义错误。连接器会忽略弱属性的函数，而使用普通的函数来解析所有对这些符号的引用</li>
<li>如果普通的函数不可用时，连接器会使用weak属性的函数</li>
<li>alias属性：声明别名，当weak和alias属性连用时，可以声明弱别</li>
</ol>


<h2>错误异常</h2>

<ol>
<li>优先级仅次于复位和NMI</li>
<li>引起错误异常的来源：

<ol>
<li>Memory访问异常</li>
<li>程序异常</li>
</ol>
</li>
<li>错误异常分析：<img src="http://i.imgur.com/DrQtd2F.png" alt="错误异常分析" />

<ol>
<li>当异常发生时，处理器首先会保护现场，因此可以得到当前寄存器的值，以及异常发生前被压栈的寄存器的值</li>
<li>判断PC的返回值是否合法，存储器的访问地址是否正确，栈地址是否正确以及是否出现了溢出</li>
<li>访问PSR寄存器来获取当前处理器的状态信息</li>
</ol>
</li>
</ol>


<h2>锁定</h2>

<ol>
<li>锁定（Lockup）的发生：

<ol>
<li>在处理NMI或者HardFault时产生错误异常</li>
<li>异常处理返回，当PSP出栈时，系统总线错误</li>
</ol>
</li>
<li>锁定的退出：

<ol>
<li>复位</li>
<li>Debugger</li>
</ol>
</li>
<li>锁定的预防：

<ol>
<li>尽量缩短NMI和HardFault异常的处理时间</li>
<li>在进入HardFault异常处理前，添加汇编代码，检查SP指针</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wizwiki_W7500]]></title>
    <link href="http://suda-morris.github.io/blog/2015/10/04/wizwiki-w7500/"/>
    <updated>2015-10-04T22:51:33+08:00</updated>
    <id>http://suda-morris.github.io/blog/2015/10/04/wizwiki-w7500</id>
    <content type="html"><![CDATA[<h2>WIZwiki-W7500平台介绍</h2>

<ol>
<li>W7500单芯片解决方案：ARM Cortex-M0，48MHz，128KB Flash，16KB RAM，硬件TCP/IP内核，32KB TCP/IP专属RAM，MII接口，8个socket</li>
<li>程序下载方法：

<ol>
<li>CMSIS-DAP USB下载</li>
<li>利用串口的ISP固件下载方式(按住boot键不放，按一下sw键进入boot模式)</li>
</ol>
</li>
<li>SWD(Serial Wire Debug)调试</li>
<li>2路SPI接口，2路I2C接口，3路UART接口，8路ADC(12bit，1Msps)，6路DMA控制器，1个32位的RNG（随机数生成器）</li>
<li>外部PHY芯片：IP101GA

<ol>
<li>支持自动MDI / MDIX功能以简化网络的安装以及降低系统维护成本，即自动识别交叉线与直连线</li>
<li>提供媒体独立接口（MII）或简化媒体独立接口（RMII）与不同类型的10/100Mbps的媒体访问控制器（MAC）连接</li>
<li>支持MDC和MDIO与MAC沟通</li>
</ol>
</li>
<li>CMSIS-DAP实现芯片：LPC11U35FHI33/501

<ol>
<li>CMSIS-DAP功能：

<ol>
<li>通过USB烧写固件到W7500</li>
<li>利用W7500的UART1，通过USB接口与外界进行串口通讯（PC端需要安装驱动，驱动安装成功后会虚拟出串口名如：mbed Seral Port(COMn)）</li>
</ol>
</li>
</ol>
</li>
<li>开发板框图：<img src="http://i.imgur.com/YbsZrdE.png" alt="板子框图" /></li>
<li>W7500芯片框图：<img src="http://i.imgur.com/pLcN78g.png" alt="W7500芯片框图" /></li>
</ol>


<h2>MII</h2>

<ol>
<li>MII即媒体独立接口，也叫介质无关接口，它是IEEE-802.3定义的以太网行业标准，它包括一个数据接口，以及一个MAC和PHY之间的管理接口,MAC与PHY间的管理接口一般是MDIO</li>
<li>数据接口包括分别用于发送器和接收器的两条独立信道，每条信道都有自己的数据、时钟和控制信号。</li>
<li>管理接口是个双信号接口：一个是时钟信号，另一个是数据信号。通过管理接口，上层能监视和控制PHY</li>
<li>MII数据接口总共需要16个信号：
<img src="http://i.imgur.com/WkMJaE8.jpg" alt="MII接口" />

<ol>
<li>Tx_CLK/Rx_CLK：分别是Tx和Rx的时钟信号。均由PHY驱动</li>
<li>TxD[0···3]/RxD[0···3]：分别是Tx和Rx的数据传输线。TxD是控制器驱动，RxD是PHY驱动</li>
<li>Tx_EN/Rx_DV：分别是Tx和Rx的开关。这两根线都是PHY驱动。只有在Tx_EN有效时，TxD才会被PHY接收；只有在Rx_DV有效时，RxD才会被控制器接收</li>
<li>Tx_ER/Rx_ER：分别是Tx和Rx的报错线。这两根线都是PHY驱动。即使是在Tx_EN或Rx_DV期间，只要此两根线有效，则出错的那个周期所传数据无效。10Mb以太网传输时，ER信号不影响正常传输，若不使用ER线，需将其接地</li>
<li>CRS/COL：监听介质是否空闲/监听是否有冲突发生。这两根线都是由PHY驱动，并且只在半双工模式下有效</li>
</ol>
</li>
<li>MII接口：MDC和MDIO。通过它，控制芯片可以访问PHY的寄存器(100M物理层芯片中介绍的寄存器组，但不仅限于100M物理层芯片，10M物理层芯片也可以拥有这些寄存器)，并通过这些寄存器来对物理层芯片进行控制和管理

<ol>
<li>MDC：管理接口时钟。它是由控制器驱动，与TX_CLK和RX_CLK无任何关系</li>
<li>MDIO：用来传送MAC层的控制信息和物理层的状态信息。它是一根双向的数据线。因MDIO在某个时钟周期内会空闲，呈高阻状态，故使用时须将其<strong>上拉</strong></li>
</ol>
</li>
<li>事实上，一个控制器，可以通过Management Interface来管理32个PHY。即，MDC和MDIO是可以复用的。</li>
<li>MAC主要是通过MDIO（以MDC为时钟）来读写PHY的寄存器，MDIO上数据帧的格式如下：
<img src="http://i.imgur.com/BTLzrtr.jpg" alt="MDIO上数据帧的格式" /></li>
<li>数据开始前，会发32个1，然后数据开始时先发送一个0，然后恢复到1；接下来两位，10表示读，01表示写；紧接着的5为是PHY地址；下面5位是寄存器地址；接下来两位表示状态转换域，若为读操作，则第一比特时MDIO为高阻态，第二比特时由物理层芯片使MDIO置“0”。若为写操作，则MDIO仍由MAC层芯片控制，其连续输出“10”两个比特。;接下来是16位的数据；空闲时线上为高阻</li>
<li>以前的10M的MAC层芯片和物理层芯片之间传送数据是通过一根数据线来进行的，其时钟是10M，在100M中，如果也用一根数据线来传送的话，时钟需要100M，这会带来一些问题，所以定义了MII接口，它是用4根数据线来传送数据的，这样在传送100M数据时，时钟就会由100M降低为25M，而在传送10M数据时，时钟会降低到2.5M，这样就实现了10M和100M的兼容。</li>
<li>MII接口的MAC模式定义：
<img src="http://i.imgur.com/e0vGKku.gif" alt="MII接口MAC模式" /></li>
<li>MII接口PHY模式定义：
<img src="http://i.imgur.com/wB70rjr.gif" alt="MII接口PHY模式" /></li>
<li>在MII接口的连线中，如果TX_ER信号线没有用到，必须将它下拉接地。</li>
<li>RXD_DV同步于RX_CLK，被PHY驱动，它的作用如同于发送通道中的TX_EN，不同的是在时序上稍有一点差别：为了让数据能够成功被RS接收，要求RXD_DV有效的时间必须覆盖整个FRAME的过程</li>
<li>MDC：管理接口的时钟，它是一个非周期信号，信号的最小周期（实际是正电平时间和负电平时间之和）为400ns，最小正电平时间和负电平时间为160ns，最大的正负电平时间无限制。它与TX_CLK和RX_CLK无任何关系。</li>
<li>MDIO是一根双向的数据线。用来传送MAC层的控制信息和物理层的状态信息。MDIO数据与MDC时钟同步，在MDC上升沿有效。</li>
<li>MDIO数据帧的时序关系：
<img src="http://i.imgur.com/S4p240T.gif" alt="MDIO数据帧的时序关系" /></li>
<li>MII接口也有一些不足之处，主要是其接口信号线很多，发送和接收和指示接口有14根数据线(不包括MDIO接口的信号线，因为其被所有MII接口所共享)，当交换芯片的端口数据较多时，会造成芯片的管脚数目很多的问题，这给芯片的设计和单板的设计都带来了一定的问题。为了解决这些问题，人们设计了两种新的MII接口，它们是RMII接口(Reduced MII接口)和SMII接口(StreamMII接口)。这两种接口都减少了MII接口的数据线，不过它们一般只用在以太网交换机的交换MAC芯片和多口物理层芯片中，而很少用于单口的MAC层芯片和物理层芯片中。RMII接口和SMII接口都可以用于10M以太网和100M以太网，但不可能用于1000M以太网，因为此时时钟频率太高，不可能实现。</li>
</ol>


<h2>中断和事件</h2>

<ol>
<li>W7500包含26路中断请求IRQ，一个非屏蔽中断NMI，一个事件信号</li>
<li>W7500可以处理内部事件以唤醒内核（WFE），唤醒事件可以通过如下方式产生：

<ol>
<li>DMA进程完成之后</li>
</ol>
</li>
</ol>


<h2>供电</h2>

<ol>
<li>W7500内部嵌入一个稳压器来提供内部1.5V的电压，稳压器没有掉电模式或者休眠模式</li>
<li>ADC参考电压和VDD相同</li>
<li>W7500在系统或电源复位后会处于工作模式，当CPU停止工作时可以采用两种低功耗模式(W7500没有掉电模式)：休眠模式(Sleep)和深度休眠(Deep Sleep)</li>
<li>休眠模式仅仅关闭了CPU时钟，总线时钟依旧开启，深度休眠模式中总线时钟和存储器时钟都被关闭</li>
</ol>


<h2>TOE</h2>

<ol>
<li>TCP/IP卸载引擎(TOE)是一个嵌入式全硬件TCP/IP以太网控制器，它可以提供更简洁的嵌入式网络接入方案。TOE提供WOL(网络唤醒)功能可以大大降低系统功耗</li>
<li>TOE框图：
<img src="http://i.imgur.com/Mvcx1hV.png" alt="TOE区域框图" /></li>
<li>NCONFLR（网络配置锁存寄存器）用来锁定和解锁对网络配置寄存器(SIR,SUBR,GAR和SHAR)的访问。当LOCK处于ON，受保护的寄存器无法进行配置，在这种情况下，写入NCONFLR寄存器的值是0x01ACCE55，当LOCK处于OFF，受保护的寄存器可以进行配置，这是该寄存器的值为非0x01ACCE55的其他任意值。</li>
<li>TCKCNTR(Ticker计数寄存器)，用于向TOE内部定时器提供100us的Ticker计数。Ticker计数器单元是HCLK</li>
</ol>


<h2>启动顺序</h2>

<ol>
<li>W7500有三种不同的启动模式，可以通过BOOT引脚和TEST引脚选定。TEST=0，BOOT=0，在主Flash存储器中执行用户代码；TEST=0，BOOT=1，W7500支持ISP功能以便于用串口控制flash</li>
</ol>


<h2>存储器</h2>

<ol>
<li>Flash存储器由长度为32为宽的存储单元构成，可以用于存储代码或者数据</li>
<li>存储器的构成基于一个主Flash存储器块，包含256字节的512扇区，或者4KB的32个块。块和扇区停工读/写保护</li>
</ol>


<h2>时钟复位发生器CRG</h2>

<ol>
<li>CRG包括PLL和POR</li>
<li>三种类型的复位：

<ol>
<li>外部复位，上电复位，系统复位</li>
<li>系统复位是当下面的情况发生时产生复位：

<ol>
<li>看门狗事件</li>
<li>重映射之后</li>
<li>软件复位(在Cortex-M0的SYSRESETREQ为)</li>
</ol>
</li>
</ol>
</li>
<li>两种时钟源可以用来驱动系统时钟：

<ol>
<li>外部振荡器时钟(8MHz~24MHz)(OCLK)</li>
<li>内部8MHz RC振荡器(RCLK)</li>
</ol>
</li>
<li>RNGCLK只有一个源(pll输出)并且没有预分频器</li>
<li>CRG框图：<img src="http://i.imgur.com/xZTW330.png" alt="CRG框图" /></li>
<li>监视时钟源：

<ol>
<li>监视引脚：PA_02</li>
<li>配置寄存器：MONCLK_SSR</li>
</ol>
</li>
</ol>


<h2>随机数发生器RNG</h2>

<ol>
<li>RNG是一个32位随机数发生器，当上电复位时，RNG会产生一个上电随机数，RNG可以通过软件来运行/停止。RNG的初始值和多项式值可以通过软件来更新</li>
</ol>


<h2>外部中断</h2>

<ol>
<li>不管任何功能引脚功能设置，功能引脚都可以被用作一个外部中断源</li>
<li>外部中断控制器的中断极性分为上升沿和下降沿</li>
</ol>


<h2>Pad控制器</h2>

<ol>
<li>W7500具有数字I/O功能引脚和数字/模拟多路复用I/O功能引脚，功能引脚的可控性特性包括上拉，下拉，驱动强度，输入开启和CMOS/Schmitt触发输入缓存</li>
</ol>


<h2>GPIO</h2>

<ol>
<li>屏蔽寄存器可将端口位视为整体而其他位不变</li>
<li>访问屏蔽功能允许一位或者多位在单向传输过程中读或写，这避免了基于软件的读-修改-写操作的非线程安全问题。有了访问屏蔽操作，16-bit I/O被分成两半，低字节和高字节，这个位被定义为两个数组，每一个包含256字节</li>
</ol>


<h2>UART</h2>

<ol>
<li>发送的数据存储在一个32字节的FIFO中，将需要发送的数据写入发送FIFO中，如果UART被启用，它会按照UARTxLCR_H只是的参数开始发送数据帧。数据会持续发送，直到发送FIFO为空。当有数据被写入发送FIFO或当前处于发送的过程中时，UARTxFR的BUSY位会保持为“1”，表示FIFO中有数据。</li>
<li>接收的数据存储在一个32字节的FIFO里面。当接收到一个起始位，它开始运行，并对UART模式中计数器的第8个周期进行采样。如果UARTRXD为“1”，证实接收到了有效的停止位。当一个完整的字符数据被接收到，数据会被存储在接收FIFO中。错误位会被存储在UARTxCR的【10：8】位置，溢出的被存储在UARTxCR的【11】位</li>
<li>更改UART控制寄存器的步骤：

<ol>
<li>禁用UART</li>
<li>等待接收到或者发送完最后的字符</li>
<li>设置行控制寄存器中FEN位为0，从而刷新发送FIFO</li>
<li>更改UARTCR寄存器</li>
<li>使能UART</li>
</ol>
</li>
<li>W7500有个Simple Uart，其实就是UART2，用来ISP烧写程序的，一般用户不直接拿来使用</li>
</ol>


<h2>uDMAC</h2>

<ol>
<li>共6个通道，每个通道用于管理来自某个或者多个外设的内存访问请求</li>
<li>不要给一个第优先级的 通道分配大不要给一个低优先级的通道分配大的R_power值，因为直到重仲裁之前来自控制器高优先级的请求都会被阻止</li>
<li>当N>2<sup>R</sup>，并且不是2<sup>R</sup>的整数倍时，控制器总是会执行2<sup>R</sup>的传输序列，直到N&lt;2<sup>R</sup>时再传输，控制器会在DMA周期的末尾，再执行剩余N次传输</li>
<li>DMA周期类型：

<ol>
<li>Invalid</li>
<li>Basic</li>
<li>Auto-request</li>
<li>ping-pong</li>
</ol>
</li>
<li>Ping-pong cycle

<ol>
<li>DMA控制器轮流切换主、副两个数据通道，直到接收到一个无效的数据结构或者是circle_type被设置成了basic模式，或者是控制器停止了该通道的工作</li>
<li>当DMA使用其中一个通道进行数据传输时候，处理器可以重新配置另外一个通道的参数</li>
</ol>
</li>
</ol>


<h2>SSP</h2>

<ol>
<li>SSP接口可以同具有以下接口的主句或者从机进行通讯

<ol>
<li>摩托罗拉SPI接口</li>
<li>TI的同步串行接口</li>
<li>国家半导体的Microware接口</li>
</ol>
</li>
<li>SSP接口可作为主机或者从机接口，支持2MHz甚至更高的位速率</li>
<li>PrimeCell SSP复位之后默认是禁用状态，需要按照以下步骤进行配置：

<ol>
<li>更改SSP控制器SSPCR0和SSPCR1来配置SSP接口外设的主从工作模式以及工作的协议标准：Motorola SPI，Texas Instruments SSP，National Semiconductor</li>
<li>通过更改时钟预分频寄存器SSPCRSR来将外部SSPCLK时钟进行分频，从而可以更改位速率</li>
</ol>
</li>
<li>有两种方法可以启动PrimeCell SSP：

<ol>
<li>激活发送FIFO：Prime Cell SSP禁用时，可以通过写入8个16位值发送FIFO</li>
<li>通过发送FIFO服务请求到CPU中断</li>
</ol>
</li>
<li>在从机模式的操作中，为了确保正确的操作，SSPCLK必须必预期的SSPCLKIN最快频率快12倍；在主机模式的操作中，为了确保正确的操作，SSPCLK必须为预期的SSPCLKOUT最快频率的2倍。</li>
<li>SSPCLK的最低频率可以通过下列公式计算，两个条件必须同时被满足：

<ol>
<li>FSSPCLK(min) >= 2 x FSSPCLKOUT(max), for master mode</li>
<li>FSSPCLK(min) >= 12 x FSSPCLKIN(max), for slave mode.</li>
</ol>
</li>
<li>SSPCLK的最高频率可以通过下列公式计算，两个条件必须被同时满足：

<ol>
<li>FSSPCLK(max) &lt;= 254 x 256 x FSSPCLKOUT(min), for master mode</li>
<li>FSSPCLK(max) &lt;= 254 x 256 x FSSPCLKIN(min), for slave mode.</li>
</ol>
</li>
<li>SSPCR0寄存器被用来：

<ol>
<li>编写穿行时钟速率</li>
<li>在三个协议模式中进行选择</li>
<li>选择合适的数据长度</li>
</ol>
</li>
<li>SSPCR1寄存器被用来：

<ol>
<li>选择主/从模式</li>
<li>启用loopback回环测试功能</li>
<li>启用PrimeCell SSP外设</li>
</ol>
</li>
<li>位速率的产生

<ol>
<li>串行位速率通过将输入时钟SSPCLK分频获得。首先，使用范围在2~254的偶数分频值CPSDVSR对输入时钟进行分频，CPSDVSR的值在SSPCPSR寄存器中设置。然后再使用1~256的其中一个值（即1+SCR）对时钟进一步分频T，此处SCR在SSI控制SSPCR0寄存器中设置。</li>
</ol>
</li>
<li>帧格式：根据所设置的数据大小，每个数据帧的长度均在4~16位之间，并且从最高有效位MSB开始发送。

<ol>
<li>德州仪器（TI）同步串行的帧格式

<ol>
<li>在该模式中，任何时候当SSP空闲时，SSPCLKOUT和SSPFSSOUT被强制为低电平，发送数据线SSPTx为三态。一旦发送FIFO的底部入口包含数据，SSPFSSOUT就会变为高电平并持续一个SSPCLKOUT周期。要发送的值也从发送FIFO传输到发送逻辑的穿行移位寄存器中</li>
</ol>
</li>
<li>Motorola SPI的帧格式

<ol>
<li>4线接口，其中SSPFSSOUT信号用作从机选择。Motorola SPI格式的主要特性为：SSPCLKOUT信号的不活动状态和相位均通过SSPSCR0控制寄存器中的SPO和SPH来设置。</li>
<li>SPO，时钟极性位。当SPO时钟极性控制位为低时，它在SSPCLKOUT管脚上产生稳定的低电平值。如果SPO位为高，则在没有进行数据传输的情况下，在SSPCLKPUT管脚上产生一个稳定的高电平值。</li>
<li>SPH，相位控制位。SPH相位控制位用来选择捕获数据的时钟边沿并允许边沿改变状态。SPH在第一个传输位上的影响最大，因为它可以在第一个数据捕获边沿之前允许或不允许一次时钟转换。当SPH相位控制位为低时，在第一个时钟边沿转换时捕获数据。如果SPH位为高，则在第二个时钟边沿转换时捕获数据</li>
</ol>
</li>
<li>National Semiconductor帧格式

<ol>
<li>National Semiconductor格式与SPI格式非常相似，不同的是其采用的是使用主-从消息传递技术的半双工模式而非全双工模式。</li>
<li>此穿行传输都由PrimeCell SSP向片外从器件发送8位控制字开始。在此传输过程中，PrimeCell SSP不会接收到输入的数据，在消息发送完毕后，片外从机对消息进行译码，并在PrimeCell SSP将8位控制消息的最后一位发送完成之后等待一个串行时钟周期，之后从机以请求的数据来响应。</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>I2C</h2>

<ol>
<li>支持标准模式100Kbps和高速模式400Kbps</li>
<li>SDA是双向的串行数据线，SCL是双向的串行时钟线。总线空闲时，这两根线都为高。每次操作都是9位，包括8个数据位和1个应答位，并且发送数据前必须先传输MSB</li>
<li>数据有效性：在时钟的高电平周期期间，SDA线上的数据必须保持稳定，SDA线上的数据仅可在时钟SCL为低电平时改变。</li>
<li>所有总线传输都带有所需的应答时钟周期，该时钟周期由主机产生。在相应周期内，发送器不能执行下一操作</li>
<li>I2C开始条件和结束条件

<ol>
<li>当SCL为高电平时，SDA线上由高到低的跳变被定义为开始条件，由低到高的跳变被定义为结束条件</li>
<li>开始条件和结束条件总是由主机产生</li>
<li>I2C总线在结束条件之后一段时间重新被释放。如果使用重新开始条件替代结束条件的话，I2C将会保持占用状态</li>
</ol>
</li>
<li>放到SDA线上的每个数据字节应该都是8位，每个字节之后跟随一个应答位。</li>
<li>7位地址之后的第8位是数据方向位（R/W）,0代表写操作，1代表读操作</li>
<li>每个字节之后都有一个应答位，应答位可以使接收者在成功接收到本字节之后，告诉发送者此数据已经被成功接收，可以发送下个字节。主机产生所有的时钟脉冲，包括应答位(第9位)的时钟脉冲</li>
</ol>

]]></content>
  </entry>
  
</feed>
