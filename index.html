
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>WenRis Blog</title>
	<meta name="author" content="suda-morris">

	
	<meta name="description" content="WenRis Blog">
	<meta name="keywords" content="C/C++,Python,Lua">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="WenRis Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">WenRis Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.baidu.com" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:suda-morris.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/Morris1106com" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/suda-morris" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.baidu.com" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:suda-morris.github.io">
	</form>
</nav>

</header>
	
		
	

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/06/14/optical-network/">
		
			Optical-network</a>
	</h2>
	<div class="entry-content">
		<h2>引论</h2>

<ol>
<li>公共交换电话网络（PSTN），一旦连接建立，它将对终端用户提供固定带宽的稳定连接，通常是4kHz左右。在运营商的中心局将这个电路转换成64kb/s数字电路。PSTN是一种电路交换网络。电路交换的问题是在处理突发数据流的时候它的效率不高。</li>
<li>快速业务恢复利用带宽冗余来实现，网络中的一半带宽作为冗余就是为了这一目的而预留的</li>
<li>光纤是一种非常细的圆柱形玻璃波导，其中包括两个组成部分：内部的纤芯材料和外包层材料。光纤提供了比铜电缆高得多的带宽，并且不易受各种电子干扰及其他不良干扰的影响。</li>
<li>光网络发展到现在可以分成两代。

<ol>
<li>第一代光网络

<ol>
<li>光基本上用来传输，只不过是提供容量而已。与同轴电缆相比，光纤具有更低的传输误码率和更高的传输容量。</li>
<li>例子：SONET（同步光纤网络），SDH（同步数字体系）</li>
</ol>
</li>
<li>第二代光网络

<ol>
<li>在光层中具有路由、交换及智能功能</li>
<li>主要特点是，一旦光路建立，这类业务对经过该光路传输的实际数据是透明的</li>
</ol>
</li>
</ol>
</li>
<li>复用技术,可以提高传输容量

<ol>
<li>OTDM（光时分复用）。形式可以是固定的或者是统计的。</li>
<li>WDM（波分复用）</li>
</ol>
</li>
<li>波长路由光网络的关键网络单元是OLT（光线路终端）、OADM（光插/分复用器）和光交叉连接（OXC）节点

<ol>
<li>OLT能将多个波长复用到一芯光纤和将一芯光纤中的一组波长分离到不同的光纤</li>
<li>OADM接收多波长信号，并选择其中部分波长下路，同时让其他波长直通。它还将一些本地波长有选择地加入到这些直通的波长中，共同组成输出信号。有波长转换功能</li>
<li>OXC有大量的端口，并且能将波长从一个输入端口交换至另一个端口。有波长转换功能</li>
</ol>
</li>
<li>网络的透明性优点

<ol>
<li>可以利用单一的基础设施来提供不同的业务</li>
<li>虽然网络中采用的协议或比特率改变了，但基础设施是不会过时的。整个网络中配置的设备无须进行彻底的改个仍可支持新的协议或新的比特率</li>
</ol>
</li>
<li>全光网络的数据从源节点到宿节点都是在光域传输，沿途不进行任何光电转换。这样的网络是完全透明的</li>
<li>目前限制光分组交换的因素是：缺乏用于缓冲的光随机存储器</li>
<li>光缓冲器是利用一定长度的光纤来制作，且只是一些简单的延迟线</li>
<li>再生器：将光信号转换为电信号，再重发一个原始信号的最新副本作为新的光信号</li>
<li>影响光网络发展的障碍与解决方案

<ol>
<li>模间色散：在多模光纤内脉冲能量通过不同的模式传输，而每个不同的模式具有不同的传输速度，因此不同模式到达光纤末端的时间略有不同，这就导致脉冲离散。这种由于不同模式的不同速度产生的特定的色散称为模间色散。

<ol>
<li>单模光纤有较小的纤芯直径，可以集中光信号的所有能量以单一模式在光纤中传输，有效地消除了模间色散</li>
</ol>
</li>
<li>传输损耗

<ol>
<li>改变波段，1.55um比1.3um有更低的传输损耗</li>
</ol>
</li>
<li>色度色散：光信号或脉冲的能量有一个有限的带宽，脉冲的不同频率分量以不同的速度传播，这种效应再一次在输出端导致脉冲离散。脉冲的频谱越宽，色散越严重，在光线中，该种色散取决于信号的波长

<ol>
<li>设计色散位移光纤，使得在1.55um波段具有零色散值</li>
<li>使用窄光谱宽度的DFB（分布式反馈）激光器，DFB激光器是一种SLM（单纵模）激光器</li>
</ol>
</li>
<li>FWM（四波混频）：三个不同波长的光信号在光纤中相互作用，产生了一个可能与这些光信号波长重叠的第四个光信号</li>
</ol>
</li>
<li>EDFA（掺铒光纤放大器）主要包含了一条掺有稀土元素铒的光纤，通常是几米到几十米长

<ol>
<li>由泵浦源将光纤中的铒原子从基态跃迁到更高能级的激发态。输入信号中的光子又触发这些原子使之回到它的基态。在此过程中，每个原子发射出一个光子，因此输入信号光子出发了额外光子的发射，从而导致了光放大。由于铒元素的独有性质，铒原子态的能级差恰好与光纤1.5um低损耗波段一致。</li>
<li>EDFA的一个主要优点是可以同时放大许多波长的信号这使得除了可以用提高传输比他率的方法外，还可以采用另外一种方式提高系统的容量，即波分复用（WDM）方法。</li>
<li>由于EDFA的使用，信号不再是每个40~80km再生一次，由于色度色散引起的脉冲离散现象越来越严重

<ol>
<li>带外调制器的DFB激光器（使用外部器件使激光器的输出光接通或断开）</li>
<li>开发色散补偿器</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>传输基础知识</h2>

<ol>
<li>光纤中的光速接近2X10<sup>8m</sup>/s</li>
<li>光纤通信中使用的中心波长在0.8um、1.3um和1.55um左右（因为硅基光纤的三个低损耗窗口在红外波段的0.8um、1.3um和1.55um处）</li>
<li>信道间距是WDM系统中两个波长之间或频率之间的间距。在波长1.55um时，0.8nm波长间距相应于100GHz的频率间距</li>
<li>比特率与可用带宽之比称为频谱效率，光通信系统中常见的频谱效率越0.4bit/s/Hz</li>
<li>现在WDM系统中主要使用1.55um波长区域的主要原因有两个：

<ol>
<li>在该波长区域光纤中的固有损耗是最低的</li>
<li>在该波长区域有性能优良的光放大器</li>
</ol>
</li>
<li>单模光纤中传输的光波的偏振态代表垂直于波传播方向的平面上光波电场矢量的指向。</li>
<li>啁啾是这样一种现象，即传送脉冲的载波频率会随时间改变，由此引起了发射频谱的增宽</li>
</ol>


<h2>元器件</h2>

<ol>
<li>耦合器：用来在光网络中合束和分束信号

<ol>
<li>耦合器的耦合比可以做成与波长无关也可以做成与波长有关</li>
<li>一个耦合器能将输入信号平均分配到两个输出端口，只要调节耦合长度。这样的耦合器称为3dB耦合器。对于3dB耦合器，虽然两个输出端口的电场具有同样的大小，但是他们之间存在π/2的相位移</li>
</ol>
</li>
<li>隔离器：只允许一个方向的广播通过它传输，在另一个方向上阻止所有光波传输

<ol>
<li>被用于光放大器和激光器的输出处，防止反射波进入这些器件</li>
<li>插入损耗：前向传输的损耗，其值应尽可能小</li>
<li>隔离度：逆向传输损耗，其值应尽可能大</li>
</ol>
</li>
<li>环形器：与隔离器类似，但是有多个端口

<ol>
<li>用于构建光上下路元件</li>
<li>隔离器和环形器的物理原理是<strong>光的偏振</strong></li>
</ol>
</li>
<li>光滤波器

<ol>
<li>两种典型应用：

<ol>
<li>在WDM系统中波长复用和解复用，这类器件称为复用器/解复用器</li>
<li>在光放大器中提供增益均衡和滤除噪声</li>
</ol>
</li>
<li>解复用器和复用器能够级联，以实现静态的波长交叉互连（WXC）</li>
<li>将光开关同复用器和解复用器组合起来能够构成动态WXC</li>
<li>研究的所有滤波器和复用器都利用了光波之间的干涉特性，此外，某些滤波器，如光栅，利用了衍射特性</li>
<li>光纤布拉格光栅是单信道滤波器，需要串联多个滤波器才能解复用所有的信道。</li>
</ol>
</li>
<li>光栅

<ol>
<li>光栅用来表示这样一类器件，他们的原理涉及从同一光源发出的带有不同相对位移的许多光信号之间的干涉</li>
<li>实际使用的大部分光栅是反射光栅，因为他们比较容易制造</li>
<li>布拉格光栅

<ol>
<li>传输介质中任何周期扰动都可以用作布拉格光栅。这一扰动通常是介质折射率的周期变化。</li>
<li>如果几个波长信号发送至光纤布拉格光栅，则布拉格波长被反射而其余的波长信号将通过光栅</li>
</ol>
</li>
<li>光纤光栅是一种全光器件，利用某种光纤的光敏特性可以在光纤中写入光栅。用锗掺杂使得通常的二氧化硅光纤变得对光极端敏感。将这种光纤暴露在紫外光下将引起光纤纤芯内部折射率的变化。因此，将此种光纤的纤芯暴露在两束相干紫外线光束下就能在光纤上写入光栅</li>
<li>短周期光栅也称为布拉格光栅，它的周期与波长可比较，典型值为0.5um。其应用有：

<ol>
<li>滤波器</li>
<li>光上下路元件</li>
<li>色散补偿</li>
</ol>
</li>
<li>长周期光纤光栅主要被应用在掺铒光纤放大器中作为滤波器，以补偿放大器增益谱的不平坦</li>
</ol>
</li>
<li>法布里-珀罗滤波器

<ol>
<li>由两个相互平行放置的具有高反射率的反射镜所形成的腔组成。</li>
<li>薄膜谐振多腔滤波器（TFMF）由两个或多个腔组成，它们用反射介质薄膜层分开</li>
</ol>
</li>
<li>阵列波导光栅（AWG），已商用

<ol>
<li>它由波导阵列互连的两个多端口耦合器组成。其中同意信号分成多路，然后经历不同量的相移后再加在一起。</li>
<li>典型应用：

<ol>
<li>NX1波长复用器和1XN波长解复用器</li>
</ol>
</li>
<li>相比多个级联的MZI（马赫-曾德尔干涉仪），AWG具有较低损耗和较平的通带，并且容易在集成光学基质上实现</li>
</ol>
</li>
<li>声光可调谐滤波器（AOTF）

<ol>
<li>基本原理是，声波被用来在波导上形成布拉格光栅，然后光栅被用来选择波长。</li>
</ol>
</li>
<li>多信道数复用器结构

<ol>
<li>串联结构

<ol>
<li>每一级滤波器解复用一个波长并让其余的波长通过。优点是允许采用“按需付费”的方式</li>
<li>串联结构只能用于解复用信道数相对较少的情况，而不能用于处理大量信道数。这是因为解复用器的插入损耗几乎线性地随着被解复用的信道数增加而增加，而且基于波长被解复用的次序，不同信道的插入损耗也不同</li>
</ol>
</li>
<li>单级结构

<ol>
<li>所有波长在单级中一起被解复用，比如AWG</li>
<li>具有相对较低的损耗和更好的损耗一致性</li>
<li>能够被解复用的信道数收到单个器件可处理的最大信道数限制</li>
</ol>
</li>
<li>多级波带解复用结构

<ol>
<li>将所有波长分成波带，解复用分成两级进行</li>
<li>缺点是，需要在波带之间留一个“保护”间隔，这一保护间隔使得第一级滤波器设计成能够提供足够的串扰抑制，而且保持低插入损耗</li>
</ol>
</li>
<li>多级间插结构

<ol>
<li>相比多级波带解复用结构，这种方法的解复用器的最后一级可以有比信道宽度宽的多的带宽，另外一个优点就是，在规划信道时不需要保护间隔</li>
</ol>
</li>
</ol>
</li>
<li>EDFA（掺铒光纤放大器）增益平坦化的措施

<ol>
<li>采用掺铒氟玻璃光纤代替硅光纤</li>
<li>在放大器中使用滤波器，降低某些波段的高增益峰值</li>
<li>多级设计

<ol>
<li>前级提供高增益和低噪声，次级提供高的输出功率</li>
</ol>
</li>
</ol>
</li>
<li>拉曼放大器可以放大任意波长，而EDFA只能在C波段和L波段处提供增益。</li>
<li>激光器

<ol>
<li>激光器本质上是包围在反射腔中的一个光放大器，使它经过正反馈产生振荡。半导体激光器采用半导体作为增益介质，而典型的光纤激光器使用掺铒光纤作为增益介质。</li>
</ol>
</li>
<li>直接调制的缺点是所产生的脉冲带有相当大的啁啾，因此在高速色散有限的通信系统中应该采用外调制器</li>
<li>光开关

<ol>
<li>如果开关的一个未被使用的输入端口能够连接到任意一个未被使用的输出端口，则这一开关是无阻塞的。</li>
<li>如果任一未被使用的输入端口能够连接到任一未被使用的输出端口，并且不需要任一现有的连接被重新路由，则称开关是广义无阻塞的</li>
<li>如果一个无阻塞开关可能需要对某些连接进行重路由以达到无阻塞特性，则被说成是可重构无阻塞开关。</li>
</ol>
</li>
<li>波长变换器

<ol>
<li>有四种实现波长变换的基本方法：

<ol>
<li>电光方法，光转换成电信号，接着再生，然后用一个不同波长的激光器再发送出去，通常这是一种可变输入、固定输出的变换器</li>
<li>光选通方法，利用半导体光放大器中的交叉增益调制实现波长变换</li>
<li>干涉仪方法</li>
<li>四波混频方法</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>光层中的客户层</h2>

<ol>
<li>当今骨干网中占支配地位的客户层是SONET/SDH、以太网和光传送网（OTN），这些协议相应于OSI体制中的物理层。

<ol>
<li>SONET/SDH特别适合支持恒定比特率（CBR）的连接，并且应用时分复用技术将这些连接信号复用到更高速率的光连接。SONET/SDH的一个重要的性质是它可提供高可靠性的载波分级业务</li>
<li>OTN网是基于SONET/SDH的概念构建的，已经将它设计成可以携带所有形式的数据流量，包括SONET/SDH流量</li>
<li>以太网支持所有实际的通信媒质，包括双绞线、无线和光缆。以太网跨越了数据链路层和物理层</li>
</ol>
</li>
<li>IP网采用无连接路由，其仅仅依据分组的宿地址转发分组。多协议标签交换（MPLS）的采用增强了IP网，这一协议是一个面向连接的路由机制。在面向连接的路由中，分主流被组成大的业务流，并且对每个大业务流选择路由。大业务流用标签识别，这些标签由分组携带，以识别它们的流</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-06-14T21:58:00+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/26/how-to-write-english-papper/">
		
			How to Write English Papper</a>
	</h2>
	<div class="entry-content">
		<h2>英语论文写作要点</h2>

<ol>
<li>读者希望在句子的开始看到熟悉的信息，事实上科技论文通常会包含很多新术语，所以一个容易理解的句子应该从读者熟悉的信息开始而以新信息结束，并在他们之间平滑过渡。</li>
<li>不管什么时候，每当你开始写新句，你应该问问自己，这些词前面有没有被提过。一定要把提到过的放前面，没提过的放后面。</li>
<li>读者想在主语之后立刻看到行为动词，如果动词和主语之间相隔太远，阅读就会被寻找动词打断。<strong>短的主语紧跟着动词加上长的宾语效果会更好</strong></li>
<li>读者期望每句只有一个重点，这个重点通常在句尾。<strong>把最好的，最重要的，和想要读者记住的东西放在句尾</strong></li>
<li>每个段落都应该只讲一个故事，在这一段里表达多个观点会使读者很难知道该记住什么，这段想表达什么。<strong>一段的第一句要告诉读者这一段讲什么的，一段的最后一句应该是这段的结论或者告诉读者下一段是什么</strong></li>
<li>对于表格来说，读者熟悉的信息应该出现在左边而新的信息出现在右边。做表格的另一个规则是把最好的留在最后，也就是最能使人感兴趣的结果应该放在最右边一列或在最后一行，因为这些地方是读者结束阅读并能留下印象的地方</li>
<li>对于图，我们至少应该对所有的标签使用大的黑体Helvetica字体，只画出重要的区域。精良不用彩色就能使曲线达到最大的区分</li>
<li><strong>只提出一个中心命题</strong>，论文里的观点太多，不但不好写，问题也容易多，读者也不易记住你要说什么</li>
<li>在这个中心命题的基础上，用一个迷人（但绝不能夸张）的标题来吸引审稿人的兴趣。审稿人只审批感兴趣的论文</li>
<li>合理解释每一个参数，合理说明每一个步骤</li>
<li>问问自己是否提供了足够重复你工作的所有细节，审稿人越容易再现你的工作，他就越可能接受你的文章</li>
<li>必须有说服力，尽量做彻底而不是半成品的工作</li>
<li>引用所有重要的研究工作，特别是经典力作。</li>
</ol>


<h2>文章的结构</h2>

<ol>
<li>典型的科学论文包括标题，摘要，方法、实验步骤，结果，讨论，感谢和参考文献</li>
<li>结果是对科研事实的描述，而讨论是对结果的解释及说明它的意义，而不是重复结果的描述</li>
<li>建议从方法和结果部分开始写，因为你对方法和结果最熟悉，此外只有更好地理解方法和结果，才能确定中心命题</li>
<li>中心命题和标题都确定了以后，就该写引言了。第一件该做的事就是围绕中心命题来收集所有相关文献。搜索并研究所有最近和相关的文章，确认你有所有最新的论文。引用所有重要的文章，如果你不引用别人得到文献，别人也不会引用你的</li>
<li>引言的第一句最难写，因为它决定了你整个引言的走向。一个办法是把第一句和文章的标题连起来。在第一段以最基本和常见的术语来定义标题里用的一些术语。从这个术语，引入研究的领域和它的重要性。第二段应该对这个研究领域做一个鉴定性的论述。如果中心命题是关于解决一个问题的方法，这一段就应该指出这个当前研究中现存未解决的问题。描述解决这个问题的难度或挑战。第三段引入你提出的办法和它大致会带来什么效果。</li>
<li>讨论部分。可用于讨论的内容有：参数改变对结果的影响，与其他研究相比还有待解决的问题，将来或正在进行的工作</li>
<li>整片文章写完了，该写摘要了。典型的摘要包括课题领域的重要性（回到标题），要研究的问题，你方法的独特性，结果的意义和影响</li>
</ol>


<h2>构思与撰文</h2>

<ol>
<li>Introduction

<ol>
<li>在叙述前人成果之后，用However来引导不足，提出一种新方法或新方向</li>
<li>提出自己的观点：We aim to//This paper reports on//This paper provides results//This paper extends the method//This paper focus on//The purpose of this paper is to//Furthermore,Moreover,In addition,we will also discuss</li>
<li>圈定自己的研究范围：introduction的另一个作用就是告诉读者你文章的主要研究内容。在前言的结尾就必须明确提出本文研究的范围：

<ol>
<li>时间尺度</li>
<li>研究区域</li>
</ol>
</li>
<li>最后的圆场：在前言的最后，还可以总结性的提出“这一研究对其他研究有什么帮助”，或者说further studies on&hellip;will be summarized in our next study (or elsewhere)</li>
</ol>
</li>
<li>Discussion

<ol>
<li>怎样提出观点

<ol>
<li>如果观点不是这篇文章最新提出的，通常要用We confirm that&hellip;</li>
<li>对于自己很自信的观点，可以用We believe that&hellip;</li>
<li>通常，由数据推断出一定的结论，用Results indicate,infer，suggest，imply that&hellip;</li>
<li>在极其特别时才可用We put forward(discover,observe)&hellip;&hellip;for the first time来强调自己的创新</li>
<li>如果自己对所提出的观点不完全肯定，可用We tentatively put forward(interrprete this to&hellip;)Or The results may due to attributed to resulted from&hellip;&hellip;</li>
</ol>
</li>
<li>连接词与逻辑

<ol>
<li>注意句子上下连贯，不能让句子独立。常见的连接词有：However，also，in addition，consequently，afterwards，moreover，Furthermore，further，althogh，unlike，in contrast，similarly，unfortunately，alternatively，parallel results，in order to，despite，for example，compared with，other results，thus，therefore</li>
<li>表示时间顺序：then，afterwards</li>
<li>表示两种对立的观点：AA put forward that&hellip;In contrast,BB believe或者Unlike AA,BB suggest</li>
<li>表示因果或者前后关系：Consequently，therefore，as a result</li>
<li>表明递进关系可用furthermore，further，moreover，in addition</li>
</ol>
</li>
<li>注意段落布局的整体逻辑。我们经常要叙述一个问题的几个方面，这种情况下，一定要注意逻辑结构。第一段要明确告诉读者你要讨论几个部分

<ol>
<li>Therefore，there are three aspects of this problem have to be addressed. The first question involves&hellip;The second problem relates to&hellip;The third aspect deals with&hellip;</li>
</ol>
</li>
<li>讨论部分包括什么内容

<ol>
<li>主要数据及其特征的总结</li>
<li>主要结论及与前人观点的对比</li>
<li>本文的不足。所谓不足，包络以下内容：

<ol>
<li>研究的问题有点片面，讨论时一定要说：If should be noted that this study has examined only&hellip;We concentrate on only&hellip;We have to point out that we do not&hellip;Some limitation of this study are</li>
<li>结论有些不足：The results do not imply&hellip;The results can not be used do determine（or be taken as evidence of）&hellip;Unfortunately,we can not determine this data&hellip;Our results are lack of&hellip;但是指出这些不足后，一定要马上再次加强本文的重要性以及可能采取的手段来解决这些不足，为别人或者自己的下一步研究打下伏笔，如：Not withstanding its limitation,this study does suggest&hellip;However,these problems could be solved if we consider&hellip;&hellip;Despite its preliminary character,this study can clearly indicate</li>
</ol>
</li>
<li>为了使文章清楚，第一次提出概念时，最好以括弧给出比较详细解释</li>
<li>绝对不能全面否定前人的成果，即使在你看来前人的结论完全不对。可以婉转地提出：Their studies may be more reasonable if they had&hellip;considered this situation或者Their results could be better convinced if they&hellip;</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>撰写外刊论文的体会</h2>

<ol>
<li>Introduction是外刊文章最难写的部分之一（另外就是Discussion）。要写好Introduction，最重要的是要保持鲜明的层次感和极强的逻辑性

<ol>
<li>阐述自己研究领域的基本内容。要尽量简洁明了，不啰嗦。</li>
<li>文献总结回顾。是Introduction的重头戏之一，要特别着重笔墨来描写。一方面要把该领域内过去和现在的状况全面概括出来，不能有丝毫的遗漏，特别是最新的进展和过去经典文献的引用。另一方面，文献引用和数据提供一定要准确，避免片面摘录部分结果而不反映文献的总体结果；</li>
<li>分析过去研究的局限性并阐明自己研究的创新点。</li>
<li>总结性描述论文的研究内容，可以分为一二三四等几个方面来描述，为Introduction做最后的收尾工作</li>
</ol>
</li>
<li>Methods部分描述论文的实验过程，这一过程的写作相对较为简单，可按照实验对象、实验设备、实验材料、实验记录、实验分析方法等来阻止行文。<strong>用过去时态</strong></li>
<li>Results的要求是翔实准确。结果提供一般是表和图。尽量使用最少的图提供最多的信息，最多不要超过8个。图片格式使用tif的比较多，不推荐使用bmp（jpg更不能用）。图和表格要放置在每一栏的顶部或者底部</li>
<li>Discussion可分为下面两个步骤来写（<strong>用现在时叙述已知或被证明的事实，用过去时描述本研究结果</strong>）：

<ol>
<li>选择要深入讨论的问题。Discussion的一个重要作用就是要突出自己研究的创新性，并体现出显著区别于他人的特点。</li>
<li>对选中的问题按照一定层次从多个角度进行讨论，说理要有根据、问题要讲清楚、讲透彻</li>
</ol>
</li>
<li>Acknowleged&amp;Reference

<ol>
<li>Ackonwledge主要分为两个，第一是表明研究的基金来源，中国一般都是Nature Science Foundation of China（NSFC，国家自然科学基金），写基金时一般要标注清楚基金号码第二是对参与人员（没有列在作者中的研究人员）和单位表示感谢，如果通过一审和最终接受发表，还要添上对editor的感谢，这是基本礼貌</li>
<li>Reference的重要在于格式。不同杂志对参考文献格式要求不一样</li>
</ol>
</li>
<li>摘要是论文要点的浓缩，应在文章各主要部分完成后再写，这样有利于文章要点的提炼。通常&lt;250字</li>
<li><strong>论文撰写时要自始至使用英语写，千万不要先写中文再翻译成英文，时态一般为过去时态</strong>。</li>
</ol>


<h2>英语学术论文写作的几个细节</h2>

<ol>
<li>时态：当提到本文、此图、此表等说明了、表达了什么时要用一般现在时，而不用一般过去时。</li>
<li>大小写：当提及具体第几章、节；图表；方程式时，首个字母通常要大写</li>
<li>research，study，investigate：research可做名词、动词，但是通常做名词使用，句中需要动词时常用study或者investigate来表达</li>
<li>increase和decrease均可做名词和动词</li>
<li>compose，consist：A is composed of B and C；A consists of B and C</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-26T15:29:37+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/22/software-defined-network/">
		
			Software Defined Network</a>
	</h2>
	<div class="entry-content">
		<h2>SDN简介</h2>

<p><img src="http://i.imgur.com/xgAZ7qZ.jpg" alt="SDN与传统网络的区别" /></p>

<ol>
<li><p>软件定义网络（SDN）是一种网络网络虚拟化技术，利用OpenFlow协议把路由器的控制平面从数据平面中分离出来，以软件方式实现。这个架构可以让网络管理员在不更动硬件设备的前提下，以中央控制方式，用程序重新规划网络，为控制网络流量提供了新的方法，也提供了核心网络及应用创新的良好平台。
<img src="http://i.imgur.com/QqFZ9Jo.jpg" alt="SDN的典型架构" /></p></li>
<li><p>SDN的典型架构共分三层</p>

<ol>
<li>应用层包括各种不同的业务和应用</li>
<li>中间控制层主要负责处理数据平面资源的编排，维护网络拓扑、状态信息等</li>
<li>基础设施层负责基于流表的数据处理、转发和状态收集。</li>
</ol>
</li>
<li>SDN本质上具有“控制和转发分离”、“设备资源虚拟化”和“通用硬件及软件可编程”三大特性。可以带来的好处有

<ol>
<li>设备硬件归一化，硬件只关注转发和存储能力，与业务特性解耦，可以采用相对廉价的商用架构来实现</li>
<li>网络的智能性全部由软件实现，网络设备的种类及功能由软件配置而定，对网络的操作控制和运行由服务器作为网络操作系统NOS来完成</li>
<li>对业务响应相对更快，可以定制各种网络参数，如路由、完全、策略、QoS、流量工程等，并实时配置到网络中，开通具体业务时间将缩短</li>
</ol>
</li>
</ol>


<h2>OpenFlow</h2>

<ol>
<li>OpenFlow是一种网络通讯协议，属于数据链路层，能够控制网络交换机或路由器的转送平面，借此改变网络数据包所走的网络路径</li>
<li>OpenFlow允许从远程控制网络交换机的数据转送表，通过新增、修改与移除数据包控制规则与行动，来改变数据包转送的路径。比起用访问控制列表（ACL）和路由协议，允许更复杂的流量管理。同时，OpenFlow允许不同应用商用一个简单，开源的协议去远程管理交换机</li>
</ol>


<h2>SDN的优势</h2>

<ol>
<li>喜欢同IT结构中的网络，根据业务需求部署上线以后，如果业务需求发生变动，重新修改响应网络设备上的配置是一件非常繁琐的事情。</li>
<li>在互联网、移动互联网瞬息万变的业务环境下，网络的高稳定与高性能还不足以满足业务需求，灵活性和敏捷性反而更为关键</li>
<li>SDN所做的事情是将网络设备上的控制权分离出来，由集中的控制器管理，无需依赖底层网络设备，屏蔽了来自底层网络设备的差异。而控制权是完全开放的，用户可以自定义任何想实现的网络路由和传输规则策略，从而更加灵活和智能</li>
<li>进行SDN改造后，无需对网络中每个节点的路由器反复进行配置，网络中的设备本身就是自动化连通的。只需要在使用时定义好简单的网络规则即可。</li>
<li>加入网络中有SIP、FTP、流媒体几种业务，网络的总带宽是一定的，那么如果某个时刻流媒体业务需要更多的带宽和流量，在传统网络中很难处理，在SDN改造后的网络中这很容易实现，SDN可以将流量整形、规整，临时让流媒体的管道更粗一些，让流媒体的带宽更大些，甚至关闭SIP和FTP的管道，待流媒体需求减少时在恢复原先的带宽占比</li>
<li>正是因为这种业务逻辑的开放性，使得网络作为“管道”的发展空间变为无限可能。如果未来云计算的业务应用模型可以简化为“云-管-端”，那么SDN就是“管”这一环的重要技术支撑</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-22T20:02:34+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/15/s3c6410/">
		
			S3C6410</a>
	</h2>
	<div class="entry-content">
		<h2>总线</h2>

<ol>
<li>总线是计算机各部件之间传送数据、地址和控制信息的公共通道，按照相对于CPU的位置可以分为：片内总线和片外总线</li>
<li>总线带宽=（总线宽度/8）*总线频率</li>
<li>ARM系列的处理器按照AMBA（Advanced Microcontroller Bus Architecture）规范设计总线，包括AHB、ASB、APB</li>
</ol>


<h2>Cache</h2>

<ol>
<li>CPU在写Cache时，如果Cache与对应内存内容同步更新，则称为通写，如果只在写入Cache的内容移出时才更新对应内存内容，则称为回写</li>
</ol>


<h2>u-boot的编译配置</h2>

<ol>
<li>执行make smdk2410_config 将u-boot顶层目录下的mkconfig脚本生成配置文件include/config.mk，内容正是根据Makefile最开发板的配置生成的

<ol>
<li>ARCH=arm</li>
<li>CPU=arm920t</li>
<li>BOARD=smdk2410</li>
<li>VENDOR=samsung</li>
<li>SOC=s3c24x0</li>
</ol>
</li>
<li>Makefile的编译选项和规则在顶层目录的config.mk文件中定义。各体系结构通用的规则直接在该文件中定义。通过ARCH、CPU、BOARD、SOC等变量为不同硬件平台定义不同选项。不同体系结构的规则分别包含在各自的lib_xxx目录下的config.mk文件中</li>
</ol>


<h2>删减u-boot文件</h2>

<ol>
<li>删除board目录下非samsung的目录

<ul>
<li>cd board/ &amp;&amp; rm -rf <code>ls | grep -v "samsung"</code></li>
</ul>
</li>
<li>删除board/samsung目录下非smdk6400的目录

<ul>
<li>cd board/samsung/ &amp;&amp; rm -rf <code>ls | grep -v "smdk6400"</code></li>
</ul>
</li>
<li>删除cpu目录下非arm920t的目录

<ul>
<li>cd cpu/ &amp;&amp; rm -rf <code>ls | grep -v "arm1176"</code></li>
</ul>
</li>
<li>删除include目录中非arm架构和非generic的汇编头文件目录

<ul>
<li>cd include/ &amp;&amp; rm -rf <code>ls | grep "asm-" | egrep -v "arm|generic"</code></li>
</ul>
</li>
<li>删除include/asm-arm目录中非s3c64xx架构的头文件目录

<ul>
<li>cd include/asm-arm/ &amp;&amp; rm -rf <code>ls | grep "arch-" | grep -v "s3c64xx"</code></li>
</ul>
</li>
<li>删除include/configs目录下非smdk6400.h的目录和文件

<ul>
<li>cd include/configs/ &amp;&amp; rm -rf <code>ls | grep -v "smdk6400.h"</code></li>
</ul>
</li>
<li>删除u-boot顶层目录下非arm架构和非generic的库目录

<ul>
<li>rm -rf <code>ls | grep "lib_" | egrep -v "arm|generic"</code></li>
</ul>
</li>
</ol>


<h2>建立suda6410配置</h2>

<ol>
<li>选择u-boot中原有的smdk6400作为suda6410的移植依据。修改顶层Makefile，检索到smdk2410_config目标所在行，添加suda6410_config目标规则
<img src="http://i.imgur.com/gnd6FyP.png" alt="修改Makefile" /></li>
<li>创建板级支持文件，将原来存放smdk6410板级相关初始化代码的文件夹复制并命名为suda6410对应功能的文件夹
<img src="http://i.imgur.com/bXKnNmi.png" alt="创建板级支持文件" /></li>
<li>修改board/samsung/suda6410/下的Makefile
<img src="http://i.imgur.com/m3EwWzx.png" alt="修改board/samsung/suda6410/下的Makefile" /></li>
<li>修改board/samsung/suda6410/下的config.mk，将原内容替换为如下代码。其中的TEXT_BASE指定最终u-boot镜像的链接基地址，LDSCRIPT则指定了连接器脚本的路径
<img src="http://i.imgur.com/F53F0Qj.png" alt="board/samsung/suda6410/config.mk" /></li>
<li>创建板级配置文件

<ul>
<li>cd include/configs/ &amp;&amp; cp smdk6400.h suda6410.h</li>
</ul>
</li>
</ol>


<h2>u-boot的环境变量</h2>

<ol>
<li>bootdelay、baudrate、netmask、ethaddr、bootfile、bootargs、bootcmd、serverip、ipaddr、stdin、stdout、stderr</li>
<li>如果在启动的时候看到u-boot打印出“Warning-bad CRC，using default environment”则说明u-boot没有在存放环境变量的固态存储器中找到有效的环境变量，只好使用编译时定义的默认环境变量。只要运行saveenv就可以把默认环境变量写入固态存储器，下次启动就不会有这个警告了。</li>
</ol>


<h2>S3C6410处理器概述</h2>

<ol>
<li>S3C6410是一个32位的RISC微处理器，采用了32位内部总线架构，内部总线由AXI（先进的可扩展接口）、AHB和APB总线组成</li>
<li>包括许多硬件外设，如一个相机接口，TFT24位真彩色液晶显示控制器，系统管理器（电源管理等），4通道UART，32通道DMA，4通道定时器，通用的I/O端口，IIS总线接口，IIC总线接口，USB主设备，USB OTG，SD主设备</li>
<li>矢量浮点型（VFP）协处理器支持</li>
<li>ARM1176JZF-S核心时钟频率最高是667MHz</li>
<li>包含3个片上PLL：APLL，MPLL和EPLL

<ol>
<li>APLL生成一个独立的ARM操作时钟</li>
<li>MPLL生成系统参考时钟</li>
<li>EPLL产生用作外设IP的时钟</li>
</ol>
</li>
</ol>


<h2>系统控制器</h2>

<p><img src="http://i.imgur.com/lmyZ0IA.png" alt="6410的结构框图" /></p>

<ol>
<li>系统控制器由时钟控制和电源管理控制两个部分组成</li>
<li>系统时钟控制

<ol>
<li>ARMCLK给CPU提供时钟</li>
<li>HCLK给AXI/AHB总线外设提供时钟</li>
<li>PCLK给APB总线外设提供时钟</li>
</ol>
</li>
<li>S3C6410有3个PLL，一个仅用于ARMCLK，一个用于HCLK和PCLK，最后一个用于外设，特别是音频相关的时钟</li>
<li>S3C6410中电源管理有四个模块组成：通用时钟门控模式，空闲模式，停止模式和睡眠模式

<ol>
<li>通用时钟门控模式用来控制内部外设时钟的开关</li>
<li>空闲模式仅中断ARMCLK到CPU</li>
<li>停止模式禁用PLL，这种情况下，电力消耗仅仅因为漏电流</li>
<li>睡眠模式断开内部电源。为了使用睡眠模式，两个独立的电源是必需的。两个电源中的一个用于唤醒逻辑提供电力，另一个提供其他内部逻辑，包括CPU</li>
</ol>
</li>
<li>ARM1176处理器是通过64位AXI总线连接到几个内存控制器上的，这样做是为了满足带宽需求。</li>
<li>多媒体协处理器分为5个电源域，包括MFC（多格式编解码器），JPEG，Camera接口，TV译码器等等。当IP没有被一个应用程序所要求时，5个电源域可以进行独立的控制，以减少不必要的电力</li>
</ol>


<p><img src="http://i.imgur.com/xErsUXB.png" alt="6410的时钟树" /></p>

<ol>
<li>S3C6410有3个PLL，分别是APLL，MPLL，和EPLL

<ol>
<li>APLL用于产生RM时钟</li>
<li>MPLL用于产生系统主时钟，用于操作AXI、AHB和APB总线</li>
<li>EPLL用于特殊用途，主要用于外设，如UART，IIS，IIC等</li>
</ol>
</li>
<li>当在AXI总线或者AHB总线上时，操作速度最大可达到133MHz，当在APB总线上时，最大的操作速度可以达到66MHz</li>
</ol>


<h2>ARM核心寄存器</h2>

<ol>
<li>ARM11有13个32位的通用寄存器R0~R12，另外有3个32位的寄存器分别是SP、LR和PC

<ol>
<li></li>
</ol>
</li>
</ol>


<h2>GPIO特性</h2>

<ol>
<li>提供内部去抖滤波器</li>
<li>8通道复用ADC，最大500k采样/s和10位的分辨率</li>
</ol>


<h2>存储器映射</h2>

<ol>
<li>S3C6410支持32位物理地址域，并且这些地址域分成两部分，一部分用于存储，另一部分用于外设</li>
<li>通过SPINE总线访问主存，主存的地址范围是从0x0000_0000~0x6FFF_FFFF。主存部分分成四个区域：引导镜像区、内部存储区、静态存储区和动态存储区

<ol>
<li>引导镜像区的地址范围是从0x0000_0000~0x07FF_FFFF，但是没有实际的映射内存。引导镜像区反映一个镜像，这个镜像指向内存的一部分区域或者静态存储区。引导镜像的开始地址是0x0000_0000</li>
<li>内部存储区用于启动代码访问内部ROM和内部SRAM，也被称作steppingstone。每块内部存储器的起始地址是确定的，内部ROM的地址范围是0x0800_0000~0x0BFF_FFFF，但是实际存储仅32KB。该区域是只读的，并且当内部ROM启动被选择时，该区域能映射到引导镜像区。内部SRAM的地址范围是0x0C00_0000~0x0FFF_FFFF，但是实际存储仅4KB。当NAND闪存启动被选择时能映射到引导镜像区。</li>
<li>静态存储区的地址范围是0x1000_0000~0x3FFF_FFFF，通过该地址区域能访问SROM、SRAM、NOR Flash、同步NOR接口设备和Steppingstone。每一块区域代表一个芯片选择。例如地址范围从0x1000_0000~0x17FF_FFFF代表Xm0CSn[0]。每个芯片选择的开始地址是固定的。NAND Flash和CF/ATAPI不能通过静态存储区访问，因此任何Xm0CSn[5:2]映射到NFCON或CFCON，相关地址区域应当被访问。一个例外，如果Xm0CSn[2]用于NAND Flash，Steppingstone映射到存储区从0x2000_0000~0x27FF_FFFF</li>
<li>动态存储区域的地址范围是0x4000_0000~0x6FFF_FFFF。DMC0有权使用地址0x4000_0000~0x4FFF_FFFF，并且DMC1有权使用地址0x5000_0000~0x6FFF_FFFF。对于每一块芯片选择的起始地址是可以进行配置的</li>
</ol>
</li>
<li>外设区域通过PERI总线被访问，它的地址范围是0x7000_0000~0x7FFF_FFFF。这个地址范围的所有的SFR能被访问。而且如果数据需要从NFCON或CFCON传输，这些数据需要通过PERI总线传输</li>
</ol>


<h2>bootloader的作用</h2>

<ol>
<li>boot的目的：跳到C语言中

<ol>
<li>关闭看门狗，中断，MMU，CACHE</li>
<li>配置系统工作时钟</li>
<li>配置SDRAM的控制器（行地址数、列地址数、多少块，周期性的充电）</li>
<li>让sp指针指向可读可写的设备区间中，满足递减栈的规则

<ol>
<li>用哪些模式，就要初始化哪些模式下的sp</li>
<li>每个模式的值不能覆盖其余模式</li>
</ol>
</li>
<li>代码搬移

<ol>
<li>执行速度问题（Nor Flash比RAM的速度慢很多），把程序从nor-flash搬移到快速的内存</li>
<li>只把存储器的一部分代码执行出来，把存储在其他位置上的代码搬移到内存上，所以要对相应存储器的控制器进行初始化</li>
</ol>
</li>
<li>bl main</li>
</ol>
</li>
<li>loader的目的

<ol>
<li>执行应用逻辑，点灯，uart，load linux kernel</li>
</ol>
</li>
</ol>


<h2>链接脚本的构成要素</h2>

<ol>
<li>哪一个.o放到代码段的起始位置</li>
<li>所有的.o放到哪个基地址上</li>
<li>代码段、数据段等等是不连续的

<ol>
<li>.text代码段</li>
<li>.rodata只读数据段</li>
<li>.data初始化数据段</li>
<li>.bss未初始化数据段</li>
</ol>
</li>
</ol>


<h2>6410的启动步骤</h2>

<p>上电后，6410会启动片内IROM中的程序(BL0，位于地址0x0800_0000~0x0BFF_FFFF，实际仅32KB)，这部分程序主要是初始化时钟，看门狗等外设，然后把SD卡或者NandFlash中的最开始4K字节的内容(BL1)加载到片内SRAM中(Stepping Stone区域，位于0x0C00_0000~0x0FFF_FFFF，实际仅用了4KB),这4K程序主要完成对SDRAM主存的配置，然后把bootloader全部的程序(BL1+BL2)加载到SDRAM中，并从Stepping Stone中跳转过去。BL2程序会把Nand Flash中的OS镜像加载到主存中，并跳转到OS的入口中运行。</p>

<h2>异常向量的地址映射</h2>

<p>根据ARM的手册，一般异常发生以后会被映射到0x0000_0000或者0xFFFF_0000，这可以使用CP15协处理器的SCTLR寄存器去配置（bit13等于0代表异常向量表位于0x0000_0000），</p>

<h2>ARM流水线技术</h2>

<ol>
<li>在ARM中，PC指针并不是指向当前正在运行的指令，而是指向当前运行的指令的地址+8（8个字节正好是两条指令，即三级流水线：取址，译码，执行）</li>
</ol>


<h2>ARM的协处理器</h2>

<ol>
<li>CP15，涉及到CACHE，MMU，中断向量等的管理</li>
<li>CP14，涉及到仿真功能，设计仿真器的时候可能需要</li>
<li>CP12-13，保留为以后使用</li>
<li>CP11一般用于双精度浮点数的计算</li>
<li>CP10用于单精度浮点数的计算</li>
<li>CP8-9，保留为以后使用</li>
<li>CP0-7，ARM公司留个各生产厂家使用</li>
</ol>


<h2>冯诺依曼体系和哈佛体系</h2>

<ol>
<li>一般单片机如MSP430，Cortex-M3等会采用哈佛体系结构，内部集成了Flash和RAM，指令和数据总线分开，虽然总线很多，但是因为在芯片内部，无伤大雅</li>
<li>ARM7，ARM11，Cortex-A8等应用处理器会采用冯诺依曼体系结构，指令和数据总线共用。冯诺依曼体系能够省去相当多的数据总线和地址总线，由于代码和数据共享一块内存，经常会造成数据冲突，速度上产生瓶颈。为了缓解这种情况，引入了CACHE的机制。</li>
<li>ARM早期采用冯诺依曼结构，到了后来CPU主频越来越快，数据吞吐量很大，冯诺依曼已经无法满足。ARM更新了设计，芯片外部还是采用冯诺依曼体系，即一块RAM既存放代码又存放数据，但是芯片内部不采用单一的CACHE，而是采用哈佛体系结构，分成DCACHE和ICACHE两块。</li>
<li>在bootloader期间，还没有严格区分代码段与数据段，代码段有可能会被缓存到DCACHE中，导致修改后的代码无法被缓存到ICACHE中，造成CACHE与主存的不一致，因此在bootloader中需要清DCACHE和ICACHE</li>
</ol>


<h2>Linux下查看二进制代码</h2>

<ol>
<li>hexdump -C file.bin | less，其中-C表示同时显示二进制和ASCII码</li>
</ol>


<h2>大端（Big Edian）与小端（Little Edian）</h2>

<ol>
<li>Intel阵营支持小端，摩托罗拉支持大端，早期的ARM公司大小端都支持，通过寄存器配置来选择</li>
<li>摩托罗拉公司的衰落，导致小端格式直接成为市场主流，ARM也放弃了对大端格式的支持</li>
<li>但是在网络协议中，一直保持着大端的数据格式，数据传输也是先传高位再传低位</li>
</ol>


<h2>u-boot/kernel中的死循环高级用法</h2>

<p>见代码如下，其中b   1b表示跳转到之前一个标号“1”处，即back，b 1f表示跳转到后面一个标号“1”处，即forward</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1:   
</span><span class='line'>  b   1b
</span><span class='line'>1:
</span><span class='line'>  b   1f
</span><span class='line'>1:
</span><span class='line'>  b   1b</span></code></pre></td></tr></table></div></figure>


<h2>VIM中跨文件的赋值粘贴</h2>

<ol>
<li>打开A文件，光标停在要开始赋值的文字那行，在命令模式下输入："+单字母的变量名+要复制的行数+yy</li>
<li>打开B文件，光标停在要粘贴的文字的那行，在命令模式下输入："+同上面的变量名+p</li>
</ol>


<h2>DDR内存基本原理</h2>

<p><img src="http://i.imgur.com/fZZiioL.png" alt="DRAM工作原理" />
<img src="http://i.imgur.com/lTlELeY.png" alt="DRAM如何读写一个字节的数据" />
<img src="http://i.imgur.com/q6lcWjG.png" alt="DDR内存条的构成" />
<img src="http://i.imgur.com/ipG0yKZ.png" alt="多个内存条并存" />
<img src="http://i.imgur.com/1F224If.png" alt="异步DRAM通信时序" />
<img src="http://i.imgur.com/3MoeCYQ.png" alt="异步DRAM与同步DRAM的时序对比" /></p>

<ol>
<li>DDR SDRAM全称Double Data Rate Synchronize Dynamic Random Access Memory

<ol>
<li>RAM中的R表示随机，意思是访问任意地址上的数据所花费的时间是一样的，区别于硬盘这类顺序访问存储器</li>
<li>SRAM中的S表示Static，静态内存。静态内存使用DQ触发器来保存一个位，一个位至少需要4~6g个晶体管</li>
<li>DRAM保存一个位只需要一个电容，由于电容值很小，会漏电，需要实时地去刷新一下（读出值，然后写回）</li>
<li>SDRAM中的S表示同步，即CPU会提供一个时钟信号与之同步</li>
</ol>
</li>
<li>Word Line也称行地址，Bit Line也称列地址，在DRAM中，每一个地址只保存1位。通过Array的形式堆叠在一起可以一次访问多个位。图中4个array组成了一个bank，8个bank拼在一起组成了一个memory device(即实际的DDR芯片)</li>
<li>DDR SDRAM会在时钟的上升和下降沿都用来读写数据，数据传输速率提高了1倍</li>
</ol>


<p><img src="http://i.imgur.com/mstLY5e.png" alt="为什么需要DQS信号" /></p>

<ol>
<li>普通的SDRAM可以在时钟上升沿把数据发送到数据总线，在时钟下降沿将数据稳定地锁存到SDRAM中，但是在DDR中，由于时钟的上升沿和下降呀都被使用，数据的稳定时刻DDR无法获知，因此引入了DQS信号来表征数据可以被锁存的稳定时刻</li>
</ol>


<p><img src="http://i.imgur.com/NQMVHpY.png" alt="DDR中的DLL机制" /></p>

<ol>
<li>DLL(Delay Lock Loop)

<ol>
<li>CLk信号在DDR芯片内部也会产生延迟</li>
<li>DLL会进一步延迟外部时钟信号，使之加上内部走线延时正好满足一个周期，这样内部时钟上升沿与外部时钟上升沿可以保持一致</li>
<li>所以DDR芯片在上电reset之后需要一段时间来完成DLL的工作</li>
</ol>
</li>
</ol>


<p><img src="http://i.imgur.com/nIZtssr.png" alt="DDR SDRAM模式寄存器MRS设定" />
<img src="http://i.imgur.com/993CUsS.png" alt="DDR读时序图" /></p>

<ol>
<li>典型的读时序过程

<ol>
<li>行激活</li>
<li>经过tRCD（Row to Column Delay）延时后可以输出列命令</li>
<li>经过tCAS（Column Access Strobe）延时后总线上开始输出数据</li>
<li>一个行操作总共花费的时间为tRAS（Row Access Strobe）</li>
<li>经过tRC（Row Precharge）时间的行预充电</li>
<li>整个过程称作一个cycle，时间为tRC（Row Cycle）</li>
</ol>
</li>
</ol>


<p><img src="http://i.imgur.com/KGr6AoR.png" alt="DDR写时序图" /></p>

<ol>
<li>典型的写时序过程

<ol>
<li>行激活</li>
<li>经过tRCD的延时后输出列命令</li>
<li>经过tCWD（Command wait delay）的延时后将数据放到总线上</li>
<li>经过tWR（Write Recovery）的延时后，DDR芯片将数据存储到了电容中</li>
<li>经过tRC（Row Precharge）时间的行预充电</li>
</ol>
</li>
</ol>


<p><img src="http://i.imgur.com/qc0yQ5k.png" alt="典型刷新时序过程" /></p>

<ol>
<li>典型的刷新时序过程

<ol>
<li>一次刷新完成两行，一次刷新花的时间tRFC（Refresh Cycle Time）</li>
<li>tREFI表示平均周期刷新时间间隔</li>
</ol>
</li>
<li>Precharge与Refresh的区别

<ol>
<li>precharge是对两根bitline预充电至VCC/2</li>
<li>refresh是每个一定的时间对电容进行充电（因为电容要漏电），间隔一般为64ms</li>
</ol>
</li>
</ol>


<h2>S3C6410的DDR控制器</h2>

<ol>
<li>DRAM控制器可以直接收一个DRAM控制器本身的指令，通过写指令到直接指令寄存器，DRAM控制器可以发送像“Precharge all”,&ldquo;Autorefresh&rdquo;,&ldquo;NOP&rdquo;,&ldquo;MRS&rdquo;(&ldquo;EMRS&rdquo;)这样的指令到SDRAM</li>
<li>在自动刷新计数器中，当刷新技术达到刷新周期的值时，控制器便会发出一个自动刷新指令对SDRAM进行周期性的刷新</li>
<li>DRAM控制器最多只能支持两个同一类型的芯片，每个芯片可分配最多256MB的地址空间。</li>
</ol>


<h2>MMU</h2>

<ol>
<li>ARMv6的MMU由协处理器CP15控制，其功能是：地址映射（VA->PA），内存访问权限控制</li>
<li>虚拟地址到物理地址的转换过程：Micro TLB->Main TLB->Page Table Walk</li>
<li>ARMv6的MMU进行地址映射时设计到两种页表，一级页表(first level page table)和二级页表(coarse page table)</li>
<li>关于映射方式有两种：段映射和页映射。段映射只用到一级页表，页映射用到一级页表和二级页表s</li>
<li>关于映射粒度：段映射的映射粒度有两种，1M section和16M supersection；页映射的映射粒度也有两种：4K small page和64K large page</li>
<li>硬件在做地址转换时，如何知道当前是什么映射方式以及映射粒度是多少呢？这些信息可以从页表的入口描述符中获得</li>
<li>一级页表总共包含4096个转换描述符，因为是通过虚拟地址的31：20位寻址的，12位能够表示的数最大是4096</li>
<li>通过虚拟地址的高12位偏移，找到页表中的对应描述符，判断描述符的最后两位，确定是什么转换，10的话表示段转换，01表示粗页(64K)转换,11表示细页(4K)转换。如果判断是段转换，将描述符的高12位取出，这个就是物理的基地址，再和虚拟地址的后20位拼接，就得到对应的物理地址。</li>
</ol>


<h2>制作uImage</h2>

<ol>
<li>工具：mkimage，位于uboot的tools文件夹下</li>
<li>命令使用：

<ol>
<li><h2>mkimage -n &lsquo;my_kernel&rsquo; -A arm -O linux -T kernel -C none -a 0x50008000 -e 0x50008040 -d zImage uImage</h2></li>
</ol>
</li>
</ol>


<h2>交叉编译器工具链使用</h2>

<ol>
<li>readelf

<ol>
<li>在操作系统基础之上的可执行文件至少包括两个部分，一个是真正的可执行代码的集合，另一个是头信息（Windows下是PE头，Linux下是ELF头），专门给操作系统看的,里面包括首先要运行的程序的入口地址（通过修改该入口地址可以制作木马）</li>
<li>arm-linux-readelf -h u-boot</li>
</ol>
</li>
<li>size

<ol>
<li>读取可执行程序的大小，包括text，data，bss等等</li>
<li>size u-boot</li>
</ol>
</li>
<li>nm

<ol>
<li>查看可执行程序的符号列表（全局标签），T代表全局函数标签，t表示静态函数标签（被static修饰），D代表全局变量标签，d代表静态变量标签（被static修饰）</li>
<li>nm u-boot</li>
</ol>
</li>
<li>strip

<ol>
<li>剔除符号列表，能够把可执行程序变小</li>
</ol>
</li>
<li>string

<ol>
<li>查看可执行程序中的常量字符串</li>
<li>string u-boot</li>
</ol>
</li>
<li>objdump

<ol>
<li>反汇编</li>
<li>objdump -D u-boot</li>
</ol>
</li>
<li>objcopy

<ol>
<li>将ELF头信息剔除，只保留可执行程序中的text，data，bss等段</li>
</ol>
</li>
<li>addr2line</li>
</ol>


<h2>为什么内核加载到内存0x50008000处，即偏移0x8000？</h2>

<ul>
<li>Linux内核在内核管理中需要建立MMU表，这个表需要在内存中预留一段空间来保存</li>
</ul>


<h2>u-boot启动linux内核的条件</h2>

<ol>
<li>需要在uboot中配置好bootargs环境变量

<ol>
<li>root=启动根文件系统在哪个设备，如ram，nfs或者flash</li>
<li>init=内核启动后第一个可执行文件init进程从哪里来</li>
<li>console=内核启动时使用哪个设备作为控制台</li>
</ol>
</li>
<li>文件系统的部署

<ol>
<li>ramdisk:内存磁盘类型的文件系统

<ul>
<li>root=/dev/ram initrd=0x21000000,8M init=/linuxrc console=ttySAC0,115200</li>
<li>测试过程中，需要先将ramdisk的内容（如initrd.img.gz）放在内存的0x21000000</li>
</ul>
</li>
<li>如何将initrd.img.gz中的内容取出来？

<ol>
<li>gunzip initrd.img.gz</li>
<li>sudo mount -t ext2 initrd.img ./swap/</li>
<li>进入swap便能获得文件系统的具体内容</li>
</ol>
</li>
<li>nfs

<ul>
<li>root=/dev/nfs nfsroot=服务器IP地址:根文件系统目录的绝对路径 ip=开发板IP地址 init=/linuxrc console=ttySAC0,115200</li>
</ul>
</li>
</ol>
</li>
</ol>


<h2>Linux系统下查看启动参数</h2>

<ul>
<li>cat /proc/cmdline</li>
</ul>


<h2>根文件系统制作</h2>

<ol>
<li>bin dev etc lib proc usr var这些都是必需的，其他的都是可选的</li>
<li>创建终端会话设备console

<ol>
<li>sudo mknod console c 5 1</li>
</ol>
</li>
<li>查看busybox的链接依赖库

<ol>
<li>arm-linux-readelf -d busybox | grep NEEDED</li>
<li>一般需要的依赖是libc.so.6和libm.so.6</li>
<li>此外还需要链接库加载器ld-linux.so.3</li>
</ol>
</li>
</ol>


<h2>busybox启动控制过程</h2>

<ol>
<li>init->inittab->/etc/init.d/rcS->/etc/init.d/S(0-9)(0-9)*->application</li>
</ol>


<h2>嵌入式常用的工具命令</h2>

<ol>
<li>设备驱动管理

<ul>
<li>fdisk fsck hwclock mkdosfs insmod rmmod lsmod mknod modprobe lsusb mdev mount unmount</li>
</ul>
</li>
<li>文本编辑处理

<ul>
<li>mkdir mkfifo ln mv cp touch rm unlink awk cat cut find vi sed wc tar grep head tail less more xargs od stat</li>
</ul>
</li>
<li>网络信息配置

<ul>
<li>udhcpc udhcpd route netstat ping ifconfig</li>
</ul>
</li>
<li>系统信息管理

<ul>
<li>chmode clear date dd df echo free ipcrm ipcs ls ps pwd top uptime kill killall reboot sleep sysctl usleep</li>
</ul>
</li>
</ol>


<h2>fstab配置文件</h2>

<ol>
<li>fstab是文件系统启动后默认要挂载的文件系统</li>
<li><code>proc        /proc   proc    defaults    0   0</code>一行配置由6个字段组成

<ol>
<li>第一个字段表示设备名称</li>
<li>第二个字段表示挂载点</li>
<li>第三个字段表示文件系统类型</li>
<li>第四个字段表示挂载选项</li>
<li>第五个字段表示备份检查，0不检查</li>
<li>第六个字段表示文件系统完整性检查，0不检查</li>
</ol>
</li>
</ol>


<h2>常用嵌入式文件系统</h2>

<ol>
<li>基于存储设备的文件系统

<ol>
<li>内存文件系统

<ol>
<li>tmpfs</li>
<li>ramdisk</li>
</ol>
</li>
<li>Flash文件系统

<ol>
<li>cramfs</li>
<li>squashfs</li>
<li>jffs/jffs2</li>
<li>yaffs/yaffs2</li>
<li>ubifs</li>
</ol>
</li>
<li>扩展SD卡文件系统

<ol>
<li>FAT32</li>
<li>ext2/ext3</li>
</ol>
</li>
<li>网络文件系统

<ol>
<li>NFS</li>
<li>Samba</li>
</ol>
</li>
</ol>
</li>
<li>基于逻辑的虚拟文件系统

<ol>
<li>进程文件系统

<ol>
<li>procfs</li>
</ol>
</li>
<li>设备文件系统

<ol>
<li>devfs（老版本内核使用）</li>
<li>sysfs</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>Nand Flash硬件特性（以K9K8G08为例）</h2>

<ol>
<li>该芯片由两个K9F4G08芯片（chip）组成，每个chip包含了4个层（plane），每层1024块（block），每块64页（page），每页（2K+64）字节</li>
<li>由于Nand Flash的工艺不能保证其存储单元在其生命周期中保持性能的可靠，因此，在其生产及使用过程中会产生坏块。

<ol>
<li>坏块的特征是：编程/擦除这个块时，会产生编程或擦除错误，并反映到状态寄存器相应位上</li>
<li>Nand Flash出错时，一般不会造成整个快或者页不能读取或全部出错，而是整个页中只有一个或者几个位出错。一般使用一种比较专用的校验-ECC</li>
<li>典型的ECC算法如Hanming码，能纠正单比特错误和检测双比特错误，而且计算速度很快，但对1比特以上的错误无法纠正，对2比特以上的错误不能保证检测。利用ECC校验需要额外的空间来存放ECC校验码</li>
<li>Nand Flash中每一个页的主数据区后都有一个称为空闲区域或者冗余区域的存储空间，在Linux驱动中，习惯称为OOB（Out Of Band）区。OOB区用来存放主数据区数据的校验值（ECC校验码），当然，除了存放ECC校验码，该区域还被用作其他用途。比如：标记是否是坏块，存储ECC数据，存储一些和文件系统相关的数据，如yaffs文件系统会在oob中，存放很多和自己文件系统相关的信息。</li>
</ol>
</li>
<li>Nand Flash以8个I/O端口多路复用的方式进行寻址。Nand Flash操作是通过向I/O端口发送相应的命令序列完成的。有的命令仅仅需要一个总线周期，如芯片复位命令、状态读写命令。其他的命令，如页的读写和块的擦除，则需要两个总线周期：一个周期用于装载，另一个周期用于执行。在页读写时，需要在相应请求命令发出后，再发出5个地址周期（2列地址和3行地址）进行寻址。在块擦除时，仅需要发出3个行地址周期。

<ol>
<li>列地址就是页内地址，由于K9K8G08页大小为2K+64字节，因此有效列地址总共12位，即A0~A11</li>
<li>行地址对应页的编号，用于确定具体那一页</li>
</ol>
</li>
<li>Nand Flash的寻址单位是页，读写以页为单位，擦除以块为单位。</li>
<li>按照页大小不同，Nand Flash可以分为大页设备和小页设备，大页设备典型大小2048字节，小页设备典型页大小为512字节。对于大页设备，通过8位I/O通常需要5个地址周期寻址，小页设备则只需要4个周期。</li>
</ol>


<h2>MTD设备概述</h2>

<ol>
<li>MTD（Memory Technology Device）是介于<strong>原始闪存设备</strong>与上层应用之间的一个抽象层，为不同类型的闪存设备提供统一的操作接口，以供上层使用。MTD设备通常包括NAND、OneNAND、NOR、AG-AND、ECC&rsquo;d NOR等</li>
<li>MTD设备具备一些独特的硬件特性，例如，MTD设备由擦除块构成，擦除快能够被写入，但是要想再次写入就必须重新擦除</li>
<li>MTD子系统不处理块设备，例如，MMC、eMMC、SD、CompactFlash等都不属于MTD，这些设备虽然多数内存存储单元都是用Nand Flash，但是他们并不是原始的闪存设备，而是通过集成在芯片内部的FTL（Flash Translation layer），使其具备块设备的特征，因此这些设备属于块设备系统，而不是MTD</li>
<li>闪存设备能够分成若干MTD分区，每一个MTD分区由一片连续的擦除块构成，因此MTD分区是建立在闪存的物理层上的。</li>
</ol>


<h2>Nand Flash控制器</h2>

<ol>
<li>在上电或系统复位之后，Nand Flash控制器自动加载4KB的启动代码。加载完成后，启动代码将在Stepping Stone中被执行。在自动导入期间，ECC是未被选中状态，因此，前8K的Nand Flash绝对不能有位错误</li>
</ol>


<h2>USB概述</h2>

<ol>
<li>Mini/Micro USB接口5根连接线中的4号引脚【ID】，用于区分是USB主控端（主机）还是USB设备端（从机）。当该引脚接地时表示是主控端，悬空时表示是设备端</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-15T21:04:55+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/study/'>study</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/05/cmsis-dap/">
		
			CMSIS-DAP</a>
	</h2>
	<div class="entry-content">
		<h2>OpenOCD使用方法</h2>

<ol>
<li>创建Openocd.cfg，输入：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$_TARGETNAME configure -event gdb-attach {
</span><span class='line'>   echo "Halting target"
</span><span class='line'>   halt
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>启动OpenOCD服务器来调试LPC11U35芯片</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo openocd -f interface/jlink.cfg -c "transport select swd" -f target/lpc11xx.cfg -f openocd.cfg </span></code></pre></td></tr></table></div></figure>


<ol>
<li>烧写需要仿真的固件</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>telnet localhost 4444
</span><span class='line'>reset halt
</span><span class='line'>flash probe 0
</span><span class='line'>flash write_image erase /home/yliu/projects/ib51822/IBDAP-FW/Firmware/IBDAP/Debug/IBDAP.bin 0x0
</span><span class='line'>reset
</span><span class='line'>exit</span></code></pre></td></tr></table></div></figure>


<ol>
<li>使用如下命令进行调试</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>target remote localhost:3333
</span><span class='line'>break IBDAP.c:103
</span><span class='line'>monitor reset halt
</span><span class='line'>monitor reset init
</span><span class='line'>continue</span></code></pre></td></tr></table></div></figure>


<h2>使用OpenOCD烧写nRF51822</h2>

<p><img src="http://i.imgur.com/3BaquhS.png" alt="OpenOCD使用实例" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-05T14:02:05+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/04/18/communication-principle/">
		
			Communication-principle</a>
	</h2>
	<div class="entry-content">
		<h2>消息</h2>

<ol>
<li>语音信号的带宽大约4KHz，图像信号的带宽大约是6MHz，音乐信号的带宽大约20KHz</li>
</ol>


<h2>信道</h2>

<ol>
<li>两个基本问题：

<ol>
<li>信号衰减：导线的电阻与长度成正比；无线电波扩散本身减弱，且被阻挡物吸收</li>
<li>加性噪声：沿途的电阻、固态器件等(包括发送器和接收器中的处理电路)引入固有的随机噪声，最基本的是热噪声</li>
</ol>
</li>
<li>其他问题：

<ol>
<li>外来干扰：其他电磁波、窜线的电信号</li>
<li>信号畸变：信道特性不理想。比如电话线中的寄生电容会使高频信号损失</li>
</ol>
</li>
<li>白高斯噪声（White Gassian Noise）：

<ol>
<li>时域上，随机性服从高斯分布</li>
<li>频域上，噪声均匀分布在所有频率上</li>
<li>功率谱密度值N0/2（物理意义：每Hz内有多少噪声）</li>
</ol>
</li>
</ol>


<h2>电磁波</h2>

<ol>
<li>电波传播主要由其频率值的大小决定。空中传播时主要有三种模式：

<ol>
<li>地波（Ground-Wave）模式：1~2MHz以下的电磁波主要按照这种模式传播，大致可以传输几十公里，主要用于调幅广播</li>
<li>天波（Sky-Wave）模式：3~30MHz的电波反射可以达到几百~1000Km远，主要用于长距离通信，大多数用于军事上</li>
<li>视线（Line-Of-Sight）模式：像广播那样作直线传播，高于30MHz，向上传播时会穿透电离层被反射回来；地面传播时，如遇到遮挡，信号会被阻断会显著衰减，用于电视广播。</li>
</ol>
</li>
</ol>


<h2>频分技术的例子：</h2>

<ol>
<li>频分复用：有线通信中多个话音“错开频率”，共用一条电线传输</li>
<li>频分多址：多个无线用户使用各自的频率，同时接入通信系统</li>
<li>频分双工：每个用户采用不同频率接收和发送，两个方向同时传输</li>
</ol>


<h2>基带与频带传输</h2>

<ol>
<li>基带信号：频谱位于零频率附近的信号</li>
<li>基带传输：保持基带形式，直接传送消息信号</li>
<li>频带信号：频谱位于某高频附近</li>
<li>频带传输：把基带的消息信号转换为频带消息来传输</li>
</ol>


<h2>模拟通信系统</h2>

<ol>
<li>调制：将基带信号变换为适当的频带信号的过程，通常用正弦波携带消息</li>
<li>解调：调制的逆过程</li>
</ol>


<h2>数字通信系统</h2>

<p><img src="http://i.imgur.com/LjU8Kz6.png" alt="数字通信系统" />
1. 格式化：规范化的数字符号序列，必要时，包括模数变化
2. 基带调制：形成合适的电信号，基带信号通常是用脉冲生成
3. 频带调制：转换为频带信号
4. 发射机：将信号送入信道
5. 同步：提供各种定时时钟，使各单元能够正确、有序地工作
6. 信源编码：实现压缩编码，把原始数字消息里面的冗余压缩掉
7. 加密：提供保密性
8. 信道编码：故意加入特殊数据位（如奇偶校验位等），仪表接收端发现和纠正错误
9. 复用：多种消息信号合并在一起
10. 多址接入：多个用户进入与公用系统
11. 频谱扩展：展宽信号频谱可增加抗干扰与保密性，也可以多址接入</p>

<h2>数字技术vs模拟技术</h2>

<ol>
<li>天生的抗噪性</li>
<li>潜在的标准性</li>
<li>便利的实现性</li>
</ol>


<h2>幅度调制&ndash;用消息去控制正弦载波的幅度变化</h2>

<p><img src="http://i.imgur.com/oWMUlEV.png" alt="常规调幅" />
1. 常规调幅（Conv.AM）
    1. m(t)是调制信号
    2. 波形特点：消息凸显在载波包络上
2. 移植载波双边带调幅（DSB-SC）
3. 单边带调幅（SSB）
4. 残留边带调幅（VSB）</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-04-18T16:40:31+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/04/18/de0-nano/">
		
			DE0-Nano</a>
	</h2>
	<div class="entry-content">
		<h2>DE0-Nano开发板简介</h2>

<p><img src="http://i.imgur.com/Gct0bL1.jpg" alt="开发板外观图" /></p>

<ol>
<li>Cyclone IV EP4CE22F17C6N FPGA

<ol>
<li>22320个逻辑资源(LEs)</li>
<li>594Kbits嵌入式内存</li>
<li>66个18X18的嵌入式乘法器</li>
<li>4个通用锁相环PLL</li>
<li>最多153个IO引脚</li>
</ol>
</li>
<li>板载烧写器与串行配置器件（EPCS）</li>
<li>板载32MB的SDRAM与2Kb的I2C EEPROM</li>
<li>板载ADI的3轴加速度传感器ADXL345，精度达到13位</li>
<li>板载12位ADC芯片：ADC128S022，采样速率：50ksps~200ksps</li>
<li></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-04-18T10:26:16+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/04/13/ieee-1588/">
		
			IEEE-1588</a>
	</h2>
	<div class="entry-content">
		<h2>概述</h2>

<ol>
<li>在分布式网络化的控制系统中，考虑到调度和控制的实时性，对时间同步的精度要求非常严格。</li>
<li>影响分布式测控系统实时性差的主要根源：

<ol>
<li>各个测控设备之间的时钟差异</li>
<li>测控数据在网络中的传输延迟</li>
</ol>
</li>
<li>网络时间协议NTP虽然通过一定的硬件配合和算法优化，可以提供系统的时钟同步性，但是只能达到毫秒级的同步精度要求</li>
<li>实现1588协议只需要在原有的网络上添加事件同步报文，这些报文占用少量的网络资源，他们只是和控制数据包或其他信息包共享网络。该协议成本低，而且独立于操作系统之外，适应性强，安装简单，无需复杂的配置工作，理论上其同步精度可以达到纳秒级。</li>
<li>IEEE 1588标准定义了一种精确时间协议PTP，该协议为分布式测控应用而设计，基于报文流加时间戳的思想，采用软、硬结合的实现方式，旨在实现亚微秒级的同步精度。协议完全兼容以太网技术，协议报文均是基于UDP/IP多播报文发送，特别适合基于局域网的分布式应用。</li>
</ol>


<h2>时间同步的概念</h2>

<ol>
<li>时间同步包括频率同步和时间同步

<ol>
<li>频率同步

<ol>
<li>是指信号之间的频率保持某种严格的特定关系，比如有效瞬间表现为同一平均速率，以此维持通信网络中所有节点以相同的速率运行</li>
<li>数字通信中传递的信号是对原始信息进行编码后得到的PCM（脉冲编码调制）离散脉冲。假如通信网中某两个节点之间的时钟频率不同，或者由于数字比特流在传输中因噪声干扰而叠加了相位漂移和抖动，便会在接收节点的缓冲存储器中产生码元的丢失或重复，最终导致比特流出现滑码。</li>
</ol>
</li>
<li>时间同步

<ol>
<li>时间同步的定义便是根据接收到的时间来调节通信网络中节点的时钟和时钟所显示的时刻。</li>
<li>时间同步和频率同步既有联系又有区别，它既调节时钟的频率同时也调节时钟的相位。由于相位和时间都是对频率的积分，所以又称时间同步为相位同步。</li>
<li>与频率同步不同的是，时间同步接受离散的时间信息，离散的调节节点时钟。</li>
<li>时间同步完成两个重要功能，即对时和守时。对时就是对表，通过不定期的对表操作，将本地节点的时刻与远端节点的标准时刻进行相位同步；守时就是频率同步，即在对表的间隙里，保证本地节点时刻与远端节点的标准时刻之间的偏差在一个允许的范围之内</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>现有的几种同步技术</h2>

<ol>
<li>GPS对时系统

<ol>
<li>GPS可以同时跟踪太空中的24颗GPS卫星，自动选择最佳星座进行定位、定时。</li>
</ol>
</li>
<li>电路仿真技术</li>
<li>同步以太网技术

<ol>
<li>以太网在物理层与SDH一样采用串行码流方式进行传送，因此响应的接收端必须提供时钟恢复业务，否则仍然会出现滑码现象。所以，以太网本身具备了传递时钟信息的功能。</li>
</ol>
</li>
<li>包时钟技术

<ol>
<li>包时钟ToP（Time over Packet），就是利用分组网络来传递时间信息。时间报文的格式可以多种多样，比如RTP、NTP、IEEE 1588，只要报文中懈怠了时间信息就可以了。</li>
<li>IEEE 1588标准又称作PTP协议，主要用于工业以太网，具有亚微秒级的时间精度，可以同时传递频率信息和相位信息</li>
</ol>
</li>
</ol>


<h2>IEEE 1588标准介绍</h2>

<ol>
<li>IEEE 1588标准的全称是《网络测量和控制系统的精确时钟同步协议》（Precision Clock Synchronization for Networked Measurement and Control Systems）,也被称作PTP协议，它在各种同步协议中的同步精度是最高的</li>
<li>IEEE 1588:2008也称为IEEE 1588第二版，其主要基于以下几个要求

<ol>
<li>实现亚微秒级的时间同步，用于均是和实际的测试与测量中</li>
<li>缩短时间报文使其等长，来满足通信网中的应用，登场保温传递时的延时变化较小</li>
<li>提供容错特性，来从网络重建和祖母时钟崩溃中快速恢复</li>
<li>能把协议映射到一些非以太网的网络中</li>
</ol>
</li>
<li>与第一版相比，第二版的改进：

<ol>
<li>报文格式。为了缩短报文长度，同步报文被分隔成Announce（声明报文）和Sync（同步报文），分别实现最佳主时钟算法和时间同步。</li>
<li>端到端透明时钟。</li>
<li>第一版中所有报文都是通过多播传递的，第二版提供了一种机制使得从时钟可与主时钟协商后在一定时间间隔内使用单播传输，这种特性广泛应用于通信中。</li>
</ol>
</li>
<li>IEEE 1588系统构成
<img src="http://i.imgur.com/yGeFBPc.png" alt="典型的PTP系统模型" /></li>
<li>IEEE 1588协议是一种说明系统中的实时PTP时钟如何相互同步的分布式协议，普通时钟和边界时钟被组织在一个主从同步层次中。PTP协议中的报文分为两类，即事件（Event）报文和一般（General）报文。

<ol>
<li>Event Messages：同步报文，延时请求，P2P延时请求，P2P延时响应。属于定时消息，发送或者接收的时刻需要打时间戳</li>
<li>General Messages：管理报文，声明报文，信令报文，跟随报文，延时响应，点延时相应跟随。不属于定时消息，不需要打时间戳</li>
</ol>
</li>
<li>PTP协议中，节点是一个包含实时时钟的设备，这个时钟可能会有多种用途，例如产生PTP报文的时间戳，或者触发由该节点管理的事件。</li>
<li>PTP协议包括两个方面：时钟同步功能和管理功能。所有的普通时钟在这两个方面的表现都相同，边界时钟的每一个端口相当于一个普通时钟。管理节点不需要实现时钟同步功能而只需要实现管理功能，除非它本身也是一个时钟节点。</li>
<li>IEEE 1588的所有时钟都是向224.0.1.129这个组播地址不停的发送网络报文的。</li>
</ol>


<h2>IEEE 1588工作机制</h2>

<ol>
<li>建立主从秩序。网络中的各个节点通过最佳主时钟算法，选举出祖母时钟、主时钟和从时钟。祖母时钟精度最高，主时钟次之，从时钟最低。</li>
<li>低等级的时钟向高等级的时钟进行同步。网络中的主从时钟通过握手机制进行同步报文的交换。</li>
</ol>


<h2>GPS</h2>

<ol>
<li>通过串口解析出来的GPS时间信息是UTC时间，UTC时间是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。UTC时间起点是1970年1月1日0时整。在IEEE1588 v2协议中，时间值的存储是以48位秒值和32位纳秒值两种形式构成的。</li>
</ol>


<h2>DP83640</h2>

<p><img src="http://i.imgur.com/DdVpWWZ.png" alt="DP83640功能框图" /></p>

<ol>
<li>全面支持IEEE 1588协议的物理层芯片，不但提供了完整的MII，还设计了12个GPIO引脚实现实时动作处理功能，其特点如下

<ol>
<li>支持IEEE 1588 v1和v2</li>
<li>支持以太网UDP/IP第四版，UDP/IP第六版和Layer2协议</li>
<li>支持高精度IEEE 1588时钟同步，时间戳最大分辨率可达8ns</li>
<li>提供12个可配置GPIO</li>
<li>频率可配置的同步时钟输出</li>
</ol>
</li>
<li>DP83640对IEEE 1588协议中对实时性要求极高的部分提供了完整的硬件支持，分别是

<ol>
<li>IEEE 1588同步时钟的产生</li>
<li>时钟同步报文的硬件标记</li>
<li>事件触发和事件捕获的时间戳标记</li>
</ol>
</li>
<li>DP83640的功能

<ol>
<li>IEEE 1588时钟输出。DP 83640可以向外部设备提供频率可调的同步时钟信号，其标称频率为250/nMHz，其中n为2~255之间的任意整数，即980.4kHz~125MHz之间的离散值</li>
<li>IEEE 1588事件触发。DP 83640可以在GPIO引脚上产生一个基于IEEE 1588时钟的触发信号，这个信号可以是一次性上升或下降沿，脉宽可调的单脉冲或者周期信号。DP 83640可以为每一个触发器指定相应的GPIO输出引脚以及触发时刻。当内部IEEE 1588时钟走时到达此值时，事件被触发。芯片最多可支持在任意GPIO引脚上发送八个触发信号。可支持在单引脚上发送多重触发信号，支持产生复杂的信号波形。此时，个触发信号通过逻辑或组合在一起产生一个联合信号。使用DP83640提供的触发功能，还可以让芯片输出一个秒脉冲信号</li>
<li>IEEE 1588时间戳标记。DP 83640可以为发生的外部事件标记时间戳。事件的监测可通过外部脉冲的上升沿或下降沿。事件时间戳标记单元可最多监测任意GPIO引脚上发生的八个外部事件。事件时间戳以单一序列的方式保存，此序列可最多保存八个时间戳信息。需要对事件时间戳做出35ns（频率125MHz的IEEE1588参考时钟的周期X3+11ns）的调整，来消除由于输入延迟和同步延迟带来的影响。</li>
<li>IEEE 1588同步报文检测。DP 83640的发送报文解析器和接收报文解析器可以自动检测节点发送和接收的符合IEEE 1588第一版和第二版所定义的同步报文，并将其时间戳信息提供给软件。</li>
</ol>
</li>
<li>所有的配置引脚（strap pin）内部都有微弱的上拉电阻或者下拉电阻，如果要改变默认配置，那么需要在该引脚外面上拉或者下拉2.2K的电阻。</li>
<li>7号引脚默认情况下是作为power-down的输入引脚，低电平有效。这等效于将BMCR寄存器中的bit11置1.将MICR寄存器的INT_OE位置1将会使器件跳出Power Down状态。</li>
<li>DP83640集成了系统诊断功能，能够评估连接的质量，检测潜在的错误</li>
<li>内部寄存器

<ol>
<li>ANAR(Auto Negotiation Advertisement Register)@04H

<ol>
<li>自动协商的能力</li>
</ol>
</li>
<li>BMCR(Basic Mode Control Register)@00H

<ol>
<li>使能、失能、重启自动协商</li>
<li>提供状态，包括：自动协商是否完成，连接对方是否发生了错误，是否建立了稳定的连接，</li>
<li>往Bit14写1开启loopback模式，开启loopback模式之前需要关闭自动协商</li>
<li>将bit11置1将使器件进入低功耗模式</li>
</ol>
</li>
<li>PHYSTS（PHY Status Register）@10H

<ol>
<li>Link Speed</li>
<li>bit3可以检测到是否开启loopback模式</li>
</ol>
</li>
<li>PHYCR（PHY Control Register）@19H

<ol>
<li>Auto-MDIX默认情况下是使能的，并能够通过该寄存器的【15：14】来重新配置</li>
<li>【6：5】设置LED的工作模式</li>
</ol>
</li>
<li>LEDCR @18H

<ol>
<li>设置LED闪烁频率</li>
</ol>
</li>
<li>MICR @11H

<ol>
<li>bit0置1将配置7号引脚作为低电平有效的中断输出</li>
<li>将INT_OE位置1，使器件退出低功耗模式</li>
<li>将bit1置1将会使能中断输出</li>
</ol>
</li>
<li>MISR @12H

<ol>
<li>低字节是各种中断的使能掩码</li>
<li>高字节是各中断的状态掩码</li>
<li>读MISR寄存器将会清除所有挂起的中断</li>
</ol>
</li>
<li>EDCR（Energy Detect Control） @1DH

<ol>
<li>是否使能Energy Detect Mode</li>
</ol>
</li>
<li>PAGESEL(Page Select Register) @13H</li>
<li></li>
</ol>
</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-04-13T23:20:07+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/03/21/latex/">
		
			Latex</a>
	</h2>
	<div class="entry-content">
		<h2>LaTeX简介</h2>

<ol>
<li>LaTeX是一种基于TeX的文档排版系统。</li>
<li>LaTeX并不是单独的程序，现在的TEX系统都是复杂的软件包，里面包含各种排版的引擎、编译脚本、格式转换工具、管理界面、配置文件、支持工具、字体以及数以千计的宏包和文档。一个TeX发行版就是把所有这样的部件都集合在一起，打包发布的软件</li>
<li>TeX是由TeX用户组发布的一个发行版，跨平台</li>
<li>LaTeX的命令以反斜线\开头，命令一般用英文单词命名，有的可以带参数。</li>
<li>严格来说，LaTeX并不是标记语言，而是主要基于字符串代换的宏语言
<img src="http://i.imgur.com/b7BVgmf.png" alt="使用各种引擎编译LaTeX文档的简要流程" /></li>
<li>导言区常用命令：

<ol>
<li>声明文章的标题:\title{An Embedded FTP Server Powered by PoE}</li>
<li>声明文章的作者:\author{morris}</li>
<li>声明写作日期:\date{\today}</li>
<li>声明参考文献的格式:\bibliographystyle{plain}</li>
</ol>
</li>
<li>以\begin{document}和\end{document}声明了一个document环境，里面是论文的正文部分，也是直接输出的部分</li>
<li>\maketitle命令实际输出论文标题</li>
<li>\tableofcontents命令输出目录</li>
<li>\section命令开始新的一节</li>
<li>使用空行分段，单个换行并不会使文字另起一段，而只是起到使源代码更易读的作用，空行只起分段作用，使用很多空行并不起任何增大间距的作用</li>
<li>短浅不用打空格，LaTeX会自动完成文字的缩进，即使手工在前面打了空格，LaTeX也会将其忽略</li>
<li>汉字后面的空格会被忽略，其他符号后面的空格则保留。单个的换行就相当于一个空格，因此源代码中大段文字可以安全地分成短行，空格只起分隔单词或符号的作用，使用很多空格并不起到任何增大字词间距的作用</li>
<li>在需要使用注脚的文字后面使用命令:\footnote{注脚内容}</li>
<li>需要强调的内容使用命令:\emph{内容}</li>
<li>命令都以反斜线\开头，后接命令名，命令名或者是一串字母，或是单个符号。命令可以带一些参数，如果命令的参数不止一个字符(不包括空格)，就必须用花括号括起来。可选参数如果出现，则使用方括号括起来。
<img src="http://i.imgur.com/t6MSwSB.png" alt="LaTeX命令的格式" /></li>
<li>引用的内容是在正文中使用quote环境得到,quote环境即以\begin{quote} 和\end{quote} 为起止位置的部分。它将环境中的内容单独分行，增加缩进和上下间距排印，以突出引用的部分。</li>
<li>文章的摘要也是在\maketitle之后用abstract环境生成的
<img src="http://i.imgur.com/eQWRnSC.png" alt="LaTeX环境的一般格式" /></li>
<li>最简单的输入公式的办法是把公式用一对美元符号$$括起来，如使用$a+b$就得到漂亮的a+b，这种夹在行文中的公式称为正文公式或行内公式。对比较长或比较重要的公式，一般则单独居中写在一行；为了方便引用，经常还给公式编号。这种公式被称为显示公式或列表公式，使用equation环境就可以方便的输入这种公式。</li>
<li>键盘上没有的符号，就需要使用一个命令来输入。例如表示角的符号就可以用\angle输入。命令的名字通常也就是符号的名字，圆周率的符号用\pi来表示</li>
<li>符号^用来引入一个上标，而_则引入一个下标，它们用起来差不多等同于一个带一个参数的命令，因此多个字符的上下标需要使用花括号分组，如$2^{10}=1024$</li>
<li>怎么输入90°，LaTeX默认的数学字体中，并没有一个专门用于表示角度的符号，自然也没有这么命令，角度的符号°是通过上标输入的：$^\circ$</li>
<li>插图功能不是由LaTeX的内核直接提供的，而是由graphicx宏包提供的。要使用graphicx宏包的插图功能，需要在源文件的导言区使用\usepackage命令引入宏包</li>
<li>引入graphicx宏包后就可以使用\includegraphics命令插图了，比如：\includegraphics[scale=0.4]{DC-DC.jpg}。插入的图形就是一个有内容的矩形盒子，在正文中和一个很大的字符没有多少区别。支持的图形格式包括PDF、PNG、JPG、EPS 等。</li>
<li>除了一些很小的标志图形，我们很少把插图直接夹在文字之中，而是使用单独的环境列出。而且很大的图形如果固定位置，会给分页造成困难。因此，通常把图形放在一个可以变动的相对位置的环境中，称为<strong>浮动体</strong>。在浮动体中还可以给图形加入说明性的标题。例如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\begin{figure}[ht]
</span><span class='line'>\centering
</span><span class='line'>\includegraphics[scale=0.6]{xiantu.pdf}
</span><span class='line'>\caption{宋赵爽在《周髀算经》注中作的弦图（仿制），该图给出了勾股定
</span><span class='line'>理的一个极具对称美的证明。}
</span><span class='line'>\label{fig:xiantu}
</span><span class='line'>\end{figure}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>在上面的代码中，figure环境有可选参数[ht]，表示浮动体可以出现在环境周围的文本所在处(here)和一页的顶部(top)，figure环境内部相当于普通的段落（默认没有缩进）；使用声明\centering表示后面的内容居中；使用caption命令给插图加上自动编号和标题</li>
<li>制作表格需要确定的是表格的行、列对齐模式和表格线，这是由tabular环境完成的：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\begin{table}[H]
</span><span class='line'>\begin{tabular}{|rrr|}
</span><span class='line'>\hline
</span><span class='line'>直角边$a$ & 直角边$b$ & 斜边$c$ \\
</span><span class='line'>\hline
</span><span class='line'>3 & 4 & 5 \\
</span><span class='line'>5 & 12 & 13 \\
</span><span class='line'>\hline
</span><span class='line'>\end{tabular}%
</span><span class='line'>\qquad
</span><span class='line'>($a^2 + b^2 = c^2$)
</span><span class='line'>\end{table}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>tabular环境中有一个参数，里面声明了表格中列的模式，在前面的表格中，|rrr|表示表格有3列，都是右对齐，在第一列和第三列后面各有一条垂直的表格线。在tabular环境内部，行与行之间用命令\隔开，每行内部的表项则用符号&amp;隔开。表格中的横线则是用命令\hline产生的。表格与插图一样，都是一个比较大的盒子，一般也放在浮动环境中，即table环境</li>
<li>使用\bibliographystyle{plain}声明了参考文献的格式，用\bibliography{math}命令打印参考文献列表。实际上这只是BibTeX处理文献的一个空架子，还需要定义“参考文献数据库”。BibTeX使用的参考文献数据库其实就是个后缀为.bib的文件。BibTeX数据库经常不需要我们自己录入，而可以从相关学科的网站直接下载或是从其他类型的文献数据库转换得到。定义好参考数据库后在正文中使用\cite命令选择需要LaTeX列出的文献。</li>
<li>引用不仅限于参考文献，图表、公式的编号，只要事先设定了标签，同样可以通过辅助文件为中介引用。基本的交叉引用命令是\ref，它以标签为参数，得到被引用的编号。数学宏包amsmath就定义了\eqref命令，专门用于公式的引用，并能产生括号</li>
<li>设计页面尺寸可以使用geometry宏包：\geometry{a6paper,centering,scale=0.8}，表示页面使用A6纸大小，版心居中，长宽占页面的0.8</li>
<li>改变图标标题格式可以使用caption宏包：\usepackage[format=hang,font=small,textfont=it]{caption}表示设置图表所有标题使用悬挂对齐方式，整体用小字号，而标题文本使用斜体（对汉字来说就是楷体）</li>
<li>增加目录的项目则可以用tocbibnd宏包：\usepackage[nottoc]{tocbibind}，宏包默认会在目录中加入目录项本身、参考文献、索引等项目，这里使用nottoc选项取消了在目录中显示目录本身</li>
<li>自定义环境命令,\newenvironment有3个参数，第一个参数是环境的名字，后两个参数分别是在环境开始和末尾处的代码</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\newenvironment{myquote}
</span><span class='line'>{\begin{quote}\kaishu\zihao{-5}}
</span><span class='line'>{\end{quote}}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>自定义新的命令：\newcommand\degree{^\circ}</li>
<li>LaTeX是一种结构化的排版语言，在填写便准格式的模板时可以忽略编号、格式等许多具体细节。在文档排版中应主动追求内容与格式的分离，在document环境之内避免直接使用诸如字体字号、对齐缩进的格式控制命令，而代之以有具体意义的环境和命令，让文档变得清晰</li>
</ol>


<h2>文字与符号</h2>

<ol>
<li>LaTeX中的特殊字母
<img src="http://i.imgur.com/lWzOtlB.png" alt="LaTeX中的特殊字母及命令" /></li>
<li>LaTeX提供了babel宏包，可以方便同时访问多种语言的字母表，babel宏包可带有一个或多个语言的可选参数，支持不同的语言，如:\usepackage[greek,english]{babel},将使用英语和希腊语，其中最后一个参数的英语是默认语言，此时希腊语就可以用ASCII字符代替：\textgreek{abcd}</li>
<li>LaTeX在盘拌种会将单词中的一些字母连写为一个符号，即连字，连字的有无和多少一般是由使用的字体决定的，比如fi和fl连在了一起，有时候为了美观考虑取消连字，可以使用空的分组，比如：f{}ind</li>
<li>在每个标点之后应该加上空格，以保证正确的距离和换行</li>
<li>LaTeX中遇到单引号和双引号连续出现的情形，则在双引号和单引号之间用\隔开</li>
<li>除了在数学模式中表示减号，符号-在LaTeX正文中也有多种用途：单独使用时它是连字符，两个连用时en dash，用来表示数字范围；三个连用是em dash，即破折号</li>
<li>圣罗浩使用\ldots或者\dots命令产生，相比直接输入三个句号，它所略微拉开的间距要合理的多</li>
<li>标准键盘上不能直接录入的标点符号
<img src="http://i.imgur.com/FT4ZOtP.png" alt="标准键盘不能直接录入的标点符号" /></li>
<li>文本中的空格起分隔单词的作用，任意多个空格与一个空格的功能相同；只有字符后面的空格使有效的，每行最前面的空格会被忽略。单个换行也被看做是一个空格</li>
<li>有一种不可打断的空格，在TeX中被称为带子，用~表示，TeX禁止在这种空格之间分行，因为可以用来表示一些不宜分开的情况
<img src="http://i.imgur.com/qKvkp9w.png" alt="带子的使用" /></li>
<li>西文的逗号、句号、分号等标点后面应该加空格，这不仅能保证正确的间距，也能保证正确的换行。这是因为，标点后如果没有空格，就不能换行。</li>
<li>空行，即用连续两个换行表示分段，段与段之间会自动得到合适的缩进，任意多个空行与一个空行的效果相同</li>
<li>除了分段，也可以让LaTeX直接另起一行，并不分段。\命令直接另起一行，上一行保持原来的样子，\命令可以带一个可选的长度参数，表示换行后增加的额外垂直间距，例如\[2cm]。\linebreak则指定一行的断点，上一行仍按完整一行散开对齐</li>
<li>特殊符号
<img src="http://i.imgur.com/T5X1sug.png" alt="正文中常用的特殊符号" /></li>
<li>LaTeX的基本工具宏包textcomp就定义了大量用于文本的符号，例如欧元符号\texteuro，千分符\textperthousand等。tipa宏包提供了国际音标字体的访问</li>
<li>预定义命令的字体族有3种：罗马字体族、无衬底字体族和打字机字体族，其命令为：
<img src="http://i.imgur.com/uiy67RS.png" alt="预定义命令的字体族" /></li>
<li>预定义命令的字体形状有4种：直立形状、意大利形状、倾斜形状、小型大写形状，其命令为：
<img src="http://i.imgur.com/NPpS0NK.png" alt="预定义命令的字体形状" /></li>
<li>预定义命令的字体系列有中等和加宽加粗两类
<img src="http://i.imgur.com/kIXpFT7.png" alt="预定义命令的字体系列" /></li>
<li>对于中文字体，一般只是用不同字体族进行区分。xeCJK和CJK宏包机制下，中文字体的选择命令和西文字体是分离，选择中文字体族使用\CJKfamily</li>
<li>中文的字体族，根据不同的系统和使用方式有不同，在ctex宏包及文档下有一些预定义
<img src="http://i.imgur.com/eBwRbYt.png" alt="ctex宏包提供的简化中文字体命令" /></li>
<li>字体命令：

<ol>
<li>\emph表示强调，用于把直立体改为意大利体，把意大利体改为直立体</li>
<li>\underline可以给文字或公式加下划线</li>
</ol>
</li>
<li>基本的LaTeX提供了10个简单的生命是命令调整文字的大小
<img src="http://i.imgur.com/QXMMMsV.png" alt="声明式命令调整文字大小" /></li>
<li>中文字号可以使用ctex宏包或者ctexart等文档类提供的\zihao命令设置
<img src="http://i.imgur.com/H0dDab2.png" alt="中文字号" /></li>
<li>LaTeX中的行距是与字号直接相关的，在设置字号的时候，同时也就设置了基本行距为文字大小的1.2倍</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-03-21T11:09:15+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/03/09/fieldbus/">
		
			FieldBus</a>
	</h2>
	<div class="entry-content">
		<h2>485总线</h2>

<ol>
<li>485，一般称作RS485/EIA-485，是隶属于OSI模型物理层的电气特性规定为2线，半双工，多点通信的标准。它的电气特性和RS-232不一样，用缆线两端的电压差值来表示传递信号。</li>
<li>RS485仅仅规定了接收端和发送端的电气特性，没有规定或推荐任何数据协议，常用的协议是ModBus</li>
<li>RS485的特点：

<ol>
<li>接口电平低，不易损坏芯片。RS485的电气特性：逻辑“1”以两线间的电压差为+(2~6)V表示；逻辑“0”以两线间的电压差为-(2~6)V表示。接口信号电平比RS232降低了，不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL电路连接</li>
<li>传输速率高。10米时，RS485的数据最高传输速率可达35Mbps，在1200时传输速率可达100Kbps</li>
<li>抗干扰能力强。RS485接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力增强，即抗噪声干扰性好</li>
<li>传输距离远，支持节点多。RS485总线最长可以传输1200m以上(速率≤100Kbps)，一般足底啊支持32个节点，如果使用特制的485芯片，可以达到128个或者256个节点，足底啊可以支持到400个节点</li>
</ol>
</li>
<li>RS485推荐使用在点对点网络中，线型，总线型，不能是星型，环形网络。理想情况下RS485需要2个终端匹配电阻，其阻止要求等于传输电缆的特性阻抗，一般为200Ω。没有特性阻抗的话，当左右的设备都静止或者没有能量的时候就会产生噪声，而且线移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据信号的边缘，导致数据传输出错。</li>
<li>推荐的连接方式如下，如果需要添加匹配电阻，一般在总线的起止端加入，也就是主机和设备4上面各加要给120Ω的匹配电阻
<img src="http://i.imgur.com/RlEPFc5.png" alt="RS485连接" /></li>
<li></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-03-09T11:46:13+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts/2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    suda-morris

Powered by Octopress-WenRis Group
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>