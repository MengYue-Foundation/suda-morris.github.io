
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>WenRis Blog</title>
	<meta name="author" content="suda-morris">

	
	<meta name="description" content="WenRis Blog">
	<meta name="keywords" content="C/C++,Python,Lua">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="WenRis Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">WenRis Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.baidu.com" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:suda-morris.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/Morris1106com" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/suda-morris" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.baidu.com" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:suda-morris.github.io">
	</form>
</nav>

</header>
	
		
	

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/26/how-to-write-english-papper/">
		
			How to Write English Papper</a>
	</h2>
	<div class="entry-content">
		<h2>英语论文写作要点</h2>

<ol>
<li>读者希望在句子的开始看到熟悉的信息，事实上科技论文通常会包含很多新术语，所以一个容易理解的句子应该从读者熟悉的信息开始而以新信息结束，并在他们之间平滑过渡。</li>
<li>不管什么时候，每当你开始写新句，你应该问问自己，这些词前面有没有被提过。一定要把提到过的放前面，没提过的放后面。</li>
<li>读者想在主语之后立刻看到行为动词，如果动词和主语之间相隔太远，阅读就会被寻找动词打断。<strong>短的主语紧跟着动词加上长的宾语效果会更好</strong></li>
<li>读者期望每句只有一个重点，这个重点通常在句尾。<strong>把最好的，最重要的，和想要读者记住的东西放在句尾</strong></li>
<li>每个段落都应该只讲一个故事，在这一段里表达多个观点会使读者很难知道该记住什么，这段想表达什么。<strong>一段的第一句要告诉读者这一段讲什么的，一段的最后一句应该是这段的结论或者告诉读者下一段是什么</strong></li>
<li>对于表格来说，读者熟悉的信息应该出现在左边而新的信息出现在右边。做表格的另一个规则是把最好的留在最后，也就是最能使人感兴趣的结果应该放在最右边一列或在最后一行，因为这些地方是读者结束阅读并能留下印象的地方</li>
<li>对于图，我们至少应该对所有的标签使用大的黑体Helvetica字体，只画出重要的区域。精良不用彩色就能使曲线达到最大的区分</li>
<li><strong>只提出一个中心命题</strong>，论文里的观点太多，不但不好写，问题也容易多，读者也不易记住你要说什么</li>
<li>在这个中心命题的基础上，用一个迷人（但绝不能夸张）的标题来吸引审稿人的兴趣。审稿人只审批感兴趣的论文</li>
<li>合理解释每一个参数，合理说明每一个步骤</li>
<li>问问自己是否提供了足够重复你工作的所有细节，审稿人越容易再现你的工作，他就越可能接受你的文章</li>
<li>必须有说服力，尽量做彻底而不是半成品的工作</li>
<li>引用所有重要的研究工作，特别是经典力作。</li>
</ol>


<h2>文章的结构</h2>

<ol>
<li>典型的科学论文包括标题，摘要，方法、实验步骤，结果，讨论，感谢和参考文献</li>
<li>结果是对科研事实的描述，而讨论是对结果的解释及说明它的意义，而不是重复结果的描述</li>
<li>建议从方法和结果部分开始写，因为你对方法和结果最熟悉，此外只有更好地理解方法和结果，才能确定中心命题</li>
<li>中心命题和标题都确定了以后，就该写引言了。第一件该做的事就是围绕中心命题来收集所有相关文献。搜索并研究所有最近和相关的文章，确认你有所有最新的论文。引用所有重要的文章，如果你不引用别人得到文献，别人也不会引用你的</li>
<li>引言的第一句最难写，因为它决定了你整个引言的走向。一个办法是把第一句和文章的标题连起来。在第一段以最基本和常见的术语来定义标题里用的一些术语。从这个术语，引入研究的领域和它的重要性。第二段应该对这个研究领域做一个鉴定性的论述。如果中心命题是关于解决一个问题的方法，这一段就应该指出这个当前研究中现存未解决的问题。描述解决这个问题的难度或挑战。第三段引入你提出的办法和它大致会带来什么效果。</li>
<li>讨论部分。可用于讨论的内容有：参数改变对结果的影响，与其他研究相比还有待解决的问题，将来或正在进行的工作</li>
<li>整片文章写完了，该写摘要了。典型的摘要包括课题领域的重要性（回到标题），要研究的问题，你方法的独特性，结果的意义和影响</li>
</ol>


<h2>构思与撰文</h2>

<ol>
<li>Introduction

<ol>
<li>在叙述前人成果之后，用However来引导不足，提出一种新方法或新方向</li>
<li>提出自己的观点：We aim to//This paper reports on//This paper provides results//This paper extends the method//This paper focus on//The purpose of this paper is to//Furthermore,Moreover,In addition,we will also discuss</li>
<li>圈定自己的研究范围：introduction的另一个作用就是告诉读者你文章的主要研究内容。在前言的结尾就必须明确提出本文研究的范围：

<ol>
<li>时间尺度</li>
<li>研究区域</li>
</ol>
</li>
<li>最后的圆场：在前言的最后，还可以总结性的提出“这一研究对其他研究有什么帮助”，或者说further studies on&hellip;will be summarized in our next study (or elsewhere)</li>
</ol>
</li>
<li>Discussion

<ol>
<li>怎样提出观点

<ol>
<li>如果观点不是这篇文章最新提出的，通常要用We confirm that&hellip;</li>
<li>对于自己很自信的观点，可以用We believe that&hellip;</li>
<li>通常，由数据推断出一定的结论，用Results indicate,infer，suggest，imply that&hellip;</li>
<li>在极其特别时才可用We put forward(discover,observe)&hellip;&hellip;for the first time来强调自己的创新</li>
<li>如果自己对所提出的观点不完全肯定，可用We tentatively put forward(interrprete this to&hellip;)Or The results may due to attributed to resulted from&hellip;&hellip;</li>
</ol>
</li>
<li>连接词与逻辑

<ol>
<li>注意句子上下连贯，不能让句子独立。常见的连接词有：However，also，in addition，consequently，afterwards，moreover，Furthermore，further，althogh，unlike，in contrast，similarly，unfortunately，alternatively，parallel results，in order to，despite，for example，compared with，other results，thus，therefore</li>
<li>表示时间顺序：then，afterwards</li>
<li>表示两种对立的观点：AA put forward that&hellip;In contrast,BB believe或者Unlike AA,BB suggest</li>
<li>表示因果或者前后关系：Consequently，therefore，as a result</li>
<li>表明递进关系可用furthermore，further，moreover，in addition</li>
</ol>
</li>
<li>注意段落布局的整体逻辑。我们经常要叙述一个问题的几个方面，这种情况下，一定要注意逻辑结构。第一段要明确告诉读者你要讨论几个部分

<ol>
<li>Therefore，there are three aspects of this problem have to be addressed. The first question involves&hellip;The second problem relates to&hellip;The third aspect deals with&hellip;</li>
</ol>
</li>
<li>讨论部分包括什么内容

<ol>
<li>主要数据及其特征的总结</li>
<li>主要结论及与前人观点的对比</li>
<li>本文的不足。所谓不足，包络以下内容：

<ol>
<li>研究的问题有点片面，讨论时一定要说：If should be noted that this study has examined only&hellip;We concentrate on only&hellip;We have to point out that we do not&hellip;Some limitation of this study are</li>
<li>结论有些不足：The results do not imply&hellip;The results can not be used do determine（or be taken as evidence of）&hellip;Unfortunately,we can not determine this data&hellip;Our results are lack of&hellip;但是指出这些不足后，一定要马上再次加强本文的重要性以及可能采取的手段来解决这些不足，为别人或者自己的下一步研究打下伏笔，如：Not withstanding its limitation,this study does suggest&hellip;However,these problems could be solved if we consider&hellip;&hellip;Despite its preliminary character,this study can clearly indicate</li>
</ol>
</li>
<li>为了使文章清楚，第一次提出概念时，最好以括弧给出比较详细解释</li>
<li>绝对不能全面否定前人的成果，即使在你看来前人的结论完全不对。可以婉转地提出：Their studies may be more reasonable if they had&hellip;considered this situation或者Their results could be better convinced if they&hellip;</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>撰写外刊论文的体会</h2>

<ol>
<li>Introduction是外刊文章最难写的部分之一（另外就是Discussion）。要写好Introduction，最重要的是要保持鲜明的层次感和极强的逻辑性

<ol>
<li>阐述自己研究领域的基本内容。要尽量简洁明了，不啰嗦。</li>
<li>文献总结回顾。是Introduction的重头戏之一，要特别着重笔墨来描写。一方面要把该领域内过去和现在的状况全面概括出来，不能有丝毫的遗漏，特别是最新的进展和过去经典文献的引用。另一方面，文献引用和数据提供一定要准确，避免片面摘录部分结果而不反映文献的总体结果；</li>
<li>分析过去研究的局限性并阐明自己研究的创新点。</li>
<li>总结性描述论文的研究内容，可以分为一二三四等几个方面来描述，为Introduction做最后的收尾工作</li>
</ol>
</li>
<li>Methods部分描述论文的实验过程，这一过程的写作相对较为简单，可按照实验对象、实验设备、实验材料、实验记录、实验分析方法等来阻止行文。<strong>用过去时态</strong></li>
<li>Results的要求是翔实准确。结果提供一般是表和图。尽量使用最少的图提供最多的信息，最多不要超过8个。图片格式使用tif的比较多，不推荐使用bmp（jpg更不能用）。图和表格要放置在每一栏的顶部或者底部</li>
<li>Discussion可分为下面两个步骤来写（<strong>用现在时叙述已知或被证明的事实，用过去时描述本研究结果</strong>）：

<ol>
<li>选择要深入讨论的问题。Discussion的一个重要作用就是要突出自己研究的创新性，并体现出显著区别于他人的特点。</li>
<li>对选中的问题按照一定层次从多个角度进行讨论，说理要有根据、问题要讲清楚、讲透彻</li>
</ol>
</li>
<li>Acknowleged&amp;Reference

<ol>
<li>Ackonwledge主要分为两个，第一是表明研究的基金来源，中国一般都是Nature Science Foundation of China（NSFC，国家自然科学基金），写基金时一般要标注清楚基金号码第二是对参与人员（没有列在作者中的研究人员）和单位表示感谢，如果通过一审和最终接受发表，还要添上对editor的感谢，这是基本礼貌</li>
<li>Reference的重要在于格式。不同杂志对参考文献格式要求不一样</li>
</ol>
</li>
<li>摘要是论文要点的浓缩，应在文章各主要部分完成后再写，这样有利于文章要点的提炼。通常&lt;250字</li>
<li><strong>论文撰写时要自始至使用英语写，千万不要先写中文再翻译成英文，时态一般为过去时态</strong>。</li>
</ol>


<h2>英语学术论文写作的几个细节</h2>

<ol>
<li>时态：当提到本文、此图、此表等说明了、表达了什么时要用一般现在时，而不用一般过去时。</li>
<li>大小写：当提及具体第几章、节；图表；方程式时，首个字母通常要大写</li>
<li>research，study，investigate：research可做名词、动词，但是通常做名词使用，句中需要动词时常用study或者investigate来表达</li>
<li>increase和decrease均可做名词和动词</li>
<li>compose，consist：A is composed of B and C；A consists of B and C</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-26T15:29:37+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/22/software-defined-network/">
		
			Software Defined Network</a>
	</h2>
	<div class="entry-content">
		<h2>SDN简介</h2>

<p><img src="http://i.imgur.com/xgAZ7qZ.jpg" alt="SDN与传统网络的区别" /></p>

<ol>
<li><p>软件定义网络（SDN）是一种网络网络虚拟化技术，利用OpenFlow协议把路由器的控制平面从数据平面中分离出来，以软件方式实现。这个架构可以让网络管理员在不更动硬件设备的前提下，以中央控制方式，用程序重新规划网络，为控制网络流量提供了新的方法，也提供了核心网络及应用创新的良好平台。
<img src="http://i.imgur.com/QqFZ9Jo.jpg" alt="SDN的典型架构" /></p></li>
<li><p>SDN的典型架构共分三层</p>

<ol>
<li>应用层包括各种不同的业务和应用</li>
<li>中间控制层主要负责处理数据平面资源的编排，维护网络拓扑、状态信息等</li>
<li>基础设施层负责基于流表的数据处理、转发和状态收集。</li>
</ol>
</li>
<li>SDN本质上具有“控制和转发分离”、“设备资源虚拟化”和“通用硬件及软件可编程”三大特性。可以带来的好处有

<ol>
<li>设备硬件归一化，硬件只关注转发和存储能力，与业务特性解耦，可以采用相对廉价的商用架构来实现</li>
<li>网络的智能性全部由软件实现，网络设备的种类及功能由软件配置而定，对网络的操作控制和运行由服务器作为网络操作系统NOS来完成</li>
<li>对业务响应相对更快，可以定制各种网络参数，如路由、完全、策略、QoS、流量工程等，并实时配置到网络中，开通具体业务时间将缩短</li>
</ol>
</li>
</ol>


<h2>OpenFlow</h2>

<ol>
<li>OpenFlow是一种网络通讯协议，属于数据链路层，能够控制网络交换机或路由器的转送平面，借此改变网络数据包所走的网络路径</li>
<li>OpenFlow允许从远程控制网络交换机的数据转送表，通过新增、修改与移除数据包控制规则与行动，来改变数据包转送的路径。比起用访问控制列表（ACL）和路由协议，允许更复杂的流量管理。同时，OpenFlow允许不同应用商用一个简单，开源的协议去远程管理交换机</li>
</ol>


<h2>SDN的优势</h2>

<ol>
<li>喜欢同IT结构中的网络，根据业务需求部署上线以后，如果业务需求发生变动，重新修改响应网络设备上的配置是一件非常繁琐的事情。</li>
<li>在互联网、移动互联网瞬息万变的业务环境下，网络的高稳定与高性能还不足以满足业务需求，灵活性和敏捷性反而更为关键</li>
<li>SDN所做的事情是将网络设备上的控制权分离出来，由集中的控制器管理，无需依赖底层网络设备，屏蔽了来自底层网络设备的差异。而控制权是完全开放的，用户可以自定义任何想实现的网络路由和传输规则策略，从而更加灵活和智能</li>
<li>进行SDN改造后，无需对网络中每个节点的路由器反复进行配置，网络中的设备本身就是自动化连通的。只需要在使用时定义好简单的网络规则即可。</li>
<li>加入网络中有SIP、FTP、流媒体几种业务，网络的总带宽是一定的，那么如果某个时刻流媒体业务需要更多的带宽和流量，在传统网络中很难处理，在SDN改造后的网络中这很容易实现，SDN可以将流量整形、规整，临时让流媒体的管道更粗一些，让流媒体的带宽更大些，甚至关闭SIP和FTP的管道，待流媒体需求减少时在恢复原先的带宽占比</li>
<li>正是因为这种业务逻辑的开放性，使得网络作为“管道”的发展空间变为无限可能。如果未来云计算的业务应用模型可以简化为“云-管-端”，那么SDN就是“管”这一环的重要技术支撑</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-22T20:02:34+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/15/s3c6410/">
		
			S3C6410</a>
	</h2>
	<div class="entry-content">
		<h2>S3C6410处理器概述</h2>

<ol>
<li>S3C6410是一个32位的RISC微处理器，采用了32位内部总线架构，内部总线由AXI（先进的可扩展接口）、AHB和APB总线组成</li>
<li>包括许多硬件外设，如一个相机接口，TFT24位真彩色液晶显示控制器，系统管理器（电源管理等），4通道UART，32通道DMA，4通道定时器，通用的I/O端口，IIS总线接口，IIC总线接口，USB主设备，USB OTG，SD主设备</li>
<li>矢量浮点型（VFP）协处理器支持</li>
<li>ARM1176JZF-S核心时钟频率最高是667MHz</li>
<li>包含3个片上PLL：APLL，MPLL和EPLL

<ol>
<li>APLL生成一个独立的ARM操作时钟</li>
<li>MPLL生成系统参考时钟</li>
<li>EPLL产生用作外设IP的时钟</li>
</ol>
</li>
</ol>


<h2>系统控制器</h2>

<p><img src="http://i.imgur.com/lmyZ0IA.png" alt="6410的结构框图" /></p>

<ol>
<li>系统控制器由时钟控制和电源管理控制两个部分组成</li>
<li>系统时钟控制

<ol>
<li>ARMCLK给CPU提供时钟</li>
<li>HCLK给AXI/AHB总线外设提供时钟</li>
<li>PCLK给APB总线外设提供时钟</li>
</ol>
</li>
<li>S3C6410有3个PLL，一个仅用于ARMCLK，一个用于HCLK和PCLK，最后一个用于外设，特别是音频相关的时钟</li>
<li>S3C6410中电源管理有四个模块组成：通用时钟门控模式，空闲模式，停止模式和睡眠模式

<ol>
<li>通用时钟门控模式用来控制内部外设时钟的开关</li>
<li>空闲模式仅中断ARMCLK到CPU</li>
<li>停止模式禁用PLL，这种情况下，电力消耗仅仅因为漏电流</li>
<li>睡眠模式断开内部电源。为了使用睡眠模式，两个独立的电源是必需的。两个电源中的一个用于唤醒逻辑提供电力，另一个提供其他内部逻辑，包括CPU</li>
</ol>
</li>
<li>ARM1176处理器是通过64位AXI总线连接到几个内存控制器上的，这样做是为了满足带宽需求。</li>
<li>多媒体协处理器分为5个电源域，包括MFC（多格式编解码器），JPEG，Camera接口，TV译码器等等。当IP没有被一个应用程序所要求时，5个电源域可以进行独立的控制，以减少不必要的电力</li>
</ol>


<p><img src="http://i.imgur.com/xErsUXB.png" alt="6410的时钟树" /></p>

<ol>
<li>S3C6410有3个PLL，分别是APLL，MPLL，和EPLL

<ol>
<li>APLL用于产生RM时钟</li>
<li>MPLL用于产生系统主时钟，用于操作AXI、AHB和APB总线</li>
<li>EPLL用于特殊用途，主要用于外设，如UART，IIS，IIC等</li>
</ol>
</li>
<li>当在AXI总线或者AHB总线上时，操作速度最大可达到133MHz，当在APB总线上时，最大的操作速度可以达到66MHz</li>
</ol>


<h2>ARM核心寄存器</h2>

<ol>
<li>ARM11有13个32位的通用寄存器R0~R12，另外有3个32位的寄存器分别是SP、LR和PC

<ol>
<li></li>
</ol>
</li>
</ol>


<h2>GPIO特性</h2>

<ol>
<li>提供内部去抖滤波器</li>
<li>8通道复用ADC，最大500k采样/s和10位的分辨率</li>
</ol>


<h2>存储器映射</h2>

<ol>
<li>S3C6410支持32位物理地址域，并且这些地址域分成两部分，一部分用于存储，另一部分用于外设</li>
<li>通过SPINE总线访问主存，主存的地址范围是从0x0000_0000~0x6FFF_FFFF。主存部分分成四个区域：引导镜像区、内部存储区、静态存储区和动态存储区

<ol>
<li>引导镜像区的地址范围是从0x0000_0000~0x07FF_FFFF，但是没有实际的映射内存。引导镜像区反映一个镜像，这个镜像指向内存的一部分区域或者静态存储区。引导镜像的开始地址是0x0000_0000</li>
<li>内部存储区用于启动代码访问内部ROM和内部SRAM，也被称作steppingstone。每块内部存储器的起始地址是确定的，内部ROM的地址范围是0x0800_0000~0x0BFF_FFFF，但是实际存储仅32KB。该区域是只读的，并且当内部ROM启动被选择时，该区域能映射到引导镜像区。内部SRAM的地址范围是0x0C00_0000~0x0FFF_FFFF，但是实际存储仅4KB。当NAND闪存启动被选择时能映射到引导镜像区。</li>
<li>静态存储区的地址范围是0x1000_0000~0x3FFF_FFFF，通过该地址区域能访问SROM、SRAM、NOR Flash、同步NOR接口设备和Steppingstone。每一块区域代表一个芯片选择。例如地址范围从0x1000_0000~0x17FF_FFFF代表Xm0CSn[0]。每个芯片选择的开始地址是固定的。NAND Flash和CF/ATAPI不能通过静态存储区访问，因此任何Xm0CSn[5:2]映射到NFCON或CFCON，相关地址区域应当被访问。一个例外，如果Xm0CSn[2]用于NAND Flash，Steppingstone映射到存储区从0x2000_0000~0x27FF_FFFF</li>
<li>动态存储区域的地址范围是0x4000_0000~0x6FFF_FFFF。DMC0有权使用地址0x4000_0000~0x4FFF_FFFF，并且DMC1有权使用地址0x5000_0000~0x6FFF_FFFF。对于每一块芯片选择的起始地址是可以进行配置的</li>
</ol>
</li>
<li>外设区域通过PERI总线被访问，它的地址范围是0x7000_0000~0x7FFF_FFFF。这个地址范围的所有的SFR能被访问。而且如果数据需要从NFCON或CFCON传输，这些数据需要通过PERI总线传输</li>
</ol>


<h2>bootloader的作用</h2>

<ol>
<li>boot的目的：跳到C语言中

<ol>
<li>关闭看门狗，中断，MMU，CACHE</li>
<li>配置系统工作时钟</li>
<li>配置SDRAM的控制器（行地址数、列地址数、多少块，周期性的充电）</li>
<li>让sp指针指向可读可写的设备区间中，满足递减栈的规则

<ol>
<li>用哪些模式，就要初始化哪些模式下的sp</li>
<li>每个模式的值不能覆盖其余模式</li>
</ol>
</li>
<li>代码搬移

<ol>
<li>执行速度问题（Nor Flash比RAM的速度慢很多），把程序从nor-flash搬移到快速的内存</li>
<li>只把存储器的一部分代码执行出来，把存储在其他位置上的代码搬移到内存上，所以要对相应存储器的控制器进行初始化</li>
</ol>
</li>
<li>bl main</li>
</ol>
</li>
<li>loader的目的

<ol>
<li>执行应用逻辑，点灯，uart，load linux kernel</li>
</ol>
</li>
</ol>


<h2>链接脚本的构成要素</h2>

<ol>
<li>哪一个.o放到代码段的起始位置</li>
<li>所有的.o放到哪个基地址上</li>
<li>代码段、数据段等等是不连续的

<ol>
<li>.text代码段</li>
<li>.rodata只读数据段</li>
<li>.data初始化数据段</li>
<li>.bss未初始化数据段</li>
</ol>
</li>
</ol>


<h2>6410的启动步骤</h2>

<p>上电后，6410会启动片内IROM中的程序(BL0，位于地址0x0800_0000~0x0BFF_FFFF，实际仅32KB)，这部分程序主要是初始化时钟，看门狗等外设，然后把SD卡或者NandFlash中的最开始4K字节的内容(BL1)加载到片内SRAM中(Stepping Stone区域，位于0x0C00_0000~0x0FFF_FFFF，实际仅用了4KB),这4K程序主要完成对SDRAM主存的配置，然后把bootloader全部的程序(BL1+BL2)加载到SDRAM中，并从Stepping Stone中跳转过去。BL2程序会把Nand Flash中的OS镜像加载到主存中，并跳转到OS的入口中运行。</p>

<h2>异常向量的地址映射</h2>

<p>根据ARM的手册，一般异常发生以后会被映射到0x0000_0000或者0xFFFF_0000，这可以使用CP15协处理器的SCTLR寄存器去配置（bit13等于0代表异常向量表位于0x0000_0000），</p>

<h2>ARM流水线技术</h2>

<ol>
<li>在ARM中，PC指针并不是指向当前正在运行的指令，而是指向当前运行的指令的地址+8（8个字节正好是两条指令，即三级流水线：取址，译码，执行）</li>
</ol>


<h2>ARM的协处理器</h2>

<ol>
<li>CP15，涉及到CACHE，MMU，中断向量等的管理</li>
<li>CP14，涉及到仿真功能，设计仿真器的时候可能需要</li>
<li>CP12-13，保留为以后使用</li>
<li>CP11一般用于双精度浮点数的计算</li>
<li>CP10用于单精度浮点数的计算</li>
<li>CP8-9，保留为以后使用</li>
<li>CP0-7，ARM公司留个各生产厂家使用</li>
</ol>


<h2>冯诺依曼体系和哈佛体系</h2>

<ol>
<li>一般单片机如MSP430，Cortex-M3等会采用哈佛体系结构，内部集成了Flash和RAM，指令和数据总线分开，虽然总线很多，但是因为在芯片内部，无伤大雅</li>
<li>ARM7，ARM11，Cortex-A8等应用处理器会采用冯诺依曼体系结构，指令和数据总线共用。冯诺依曼体系能够省去相当多的数据总线和地址总线，由于代码和数据共享一块内存，经常会造成数据冲突，速度上产生瓶颈。为了缓解这种情况，引入了CACHE的机制。</li>
<li>ARM早期采用冯诺依曼结构，到了后来CPU主频越来越快，数据吞吐量很大，冯诺依曼已经无法满足。ARM更新了设计，芯片外部还是采用冯诺依曼体系，即一块RAM既存放代码又存放数据，但是芯片内部不采用单一的CACHE，而是采用哈佛体系结构，分成DCACHE和ICACHE两块。</li>
<li>在bootloader期间，还没有严格区分代码段与数据段，代码段有可能会被缓存到DCACHE中，导致修改后的代码无法被缓存到ICACHE中，造成CACHE与主存的不一致，因此在bootloader中需要清DCACHE和ICACHE</li>
</ol>


<h2>Linux下查看二进制代码</h2>

<ol>
<li>hexdump -C file.bin | less，其中-C表示同时显示二进制和ASCII码</li>
</ol>


<h2>大端（Big Edian）与小端（Little Edian）</h2>

<ol>
<li>Intel阵营支持小端，摩托罗拉支持大端，早期的ARM公司大小端都支持，通过寄存器配置来选择</li>
<li>摩托罗拉公司的衰落，导致小端格式直接成为市场主流，ARM也放弃了对大端格式的支持</li>
<li>但是在网络协议中，一直保持着大端的数据格式，数据传输也是先传高位再传低位</li>
</ol>


<h2>u-boot/kernel中的死循环高级用法</h2>

<p>见代码如下，其中b   1b表示跳转到之前一个标号“1”处，即back，b 1f表示跳转到后面一个标号“1”处，即forward</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1:   
</span><span class='line'>  b   1b
</span><span class='line'>1:
</span><span class='line'>  b   1f
</span><span class='line'>1:
</span><span class='line'>  b   1b</span></code></pre></td></tr></table></div></figure>


<h2>VIM中跨文件的赋值粘贴</h2>

<ol>
<li>打开A文件，光标停在要开始赋值的文字那行，在命令模式下输入："+单字母的变量名+要复制的行数+yy</li>
<li>打开B文件，光标停在要粘贴的文字的那行，在命令模式下输入："+同上面的变量名+p</li>
</ol>


<h2>DDR内存基本原理</h2>

<p><img src="http://i.imgur.com/fZZiioL.png" alt="DRAM工作原理" />
<img src="http://i.imgur.com/lTlELeY.png" alt="DRAM如何读写一个字节的数据" />
<img src="http://i.imgur.com/q6lcWjG.png" alt="DDR内存条的构成" />
<img src="http://i.imgur.com/ipG0yKZ.png" alt="多个内存条并存" />
<img src="http://i.imgur.com/1F224If.png" alt="异步DRAM通信时序" />
<img src="http://i.imgur.com/3MoeCYQ.png" alt="异步DRAM与同步DRAM的时序对比" /></p>

<ol>
<li>DDR SDRAM全称Double Data Rate Synchronize Dynamic Random Access Memory

<ol>
<li>RAM中的R表示随机，意思是访问任意地址上的数据所花费的时间是一样的，区别于硬盘这类顺序访问存储器</li>
<li>SRAM中的S表示Static，静态内存。静态内存使用DQ触发器来保存一个位，一个位至少需要4~6g个晶体管</li>
<li>DRAM保存一个位只需要一个电容，由于电容值很小，会漏电，需要实时地去刷新一下（读出值，然后写回）</li>
<li>SDRAM中的S表示同步，即CPU会提供一个时钟信号与之同步</li>
</ol>
</li>
<li>Word Line也称行地址，Bit Line也称列地址，在DRAM中，每一个地址只保存1位。通过Array的形式堆叠在一起可以一次访问多个位。图中4个array组成了一个bank，8个bank拼在一起组成了一个memory device(即实际的DDR芯片)</li>
<li>DDR SDRAM会在时钟的上升和下降沿都用来读写数据，数据传输速率提高了1倍</li>
</ol>


<p><img src="http://i.imgur.com/mstLY5e.png" alt="为什么需要DQS信号" /></p>

<ol>
<li>普通的SDRAM可以在时钟上升沿把数据发送到数据总线，在时钟下降沿将数据稳定地锁存到SDRAM中，但是在DDR中，由于时钟的上升沿和下降呀都被使用，数据的稳定时刻DDR无法获知，因此引入了DQS信号来表征数据可以被锁存的稳定时刻</li>
</ol>


<p><img src="http://i.imgur.com/NQMVHpY.png" alt="DDR中的DLL机制" /></p>

<ol>
<li>DLL(Delay Lock Loop)

<ol>
<li>CLk信号在DDR芯片内部也会产生延迟</li>
<li>DLL会进一步延迟外部时钟信号，使之加上内部走线延时正好满足一个周期，这样内部时钟上升沿与外部时钟上升沿可以保持一致</li>
<li>所以DDR芯片在上电reset之后需要一段时间来完成DLL的工作</li>
</ol>
</li>
</ol>


<p><img src="http://i.imgur.com/nIZtssr.png" alt="DDR SDRAM模式寄存器MRS设定" />
<img src="http://i.imgur.com/993CUsS.png" alt="DDR读时序图" /></p>

<ol>
<li>典型的读时序过程

<ol>
<li>行激活</li>
<li>经过tRCD（Row to Column Delay）延时后可以输出列命令</li>
<li>经过tCAS（Column Access Strobe）延时后总线上开始输出数据</li>
<li>一个行操作总共花费的时间为tRAS（Row Access Strobe）</li>
<li>经过tRC（Row Precharge）时间的行预充电</li>
<li>整个过程称作一个cycle，时间为tRC（Row Cycle）</li>
</ol>
</li>
</ol>


<p><img src="http://i.imgur.com/KGr6AoR.png" alt="DDR写时序图" /></p>

<ol>
<li>典型的写时序过程

<ol>
<li>行激活</li>
<li>经过tRCD的延时后输出列命令</li>
<li>经过tCWD（Command wait delay）的延时后将数据放到总线上</li>
<li>经过tWR（Write Recovery）的延时后，DDR芯片将数据存储到了电容中</li>
<li>经过tRC（Row Precharge）时间的行预充电</li>
</ol>
</li>
</ol>


<p><img src="http://i.imgur.com/qc0yQ5k.png" alt="典型刷新时序过程" /></p>

<ol>
<li>典型的刷新时序过程

<ol>
<li>一次刷新完成两行，一次刷新花的时间tRFC（Refresh Cycle Time）</li>
<li>tREFI表示平均周期刷新时间间隔</li>
</ol>
</li>
<li>Precharge与Refresh的区别

<ol>
<li>precharge是对两根bitline预充电至VCC/2</li>
<li>refresh是每个一定的时间对电容进行充电（因为电容要漏电），间隔一般为64ms</li>
</ol>
</li>
</ol>


<h2>S3C6410的DDR控制器</h2>

<ol>
<li>DRAM控制器可以直接收一个DRAM控制器本身的指令，通过写指令到直接指令寄存器，DRAM控制器可以发送像“Precharge all”,&ldquo;Autorefresh&rdquo;,&ldquo;NOP&rdquo;,&ldquo;MRS&rdquo;(&ldquo;EMRS&rdquo;)这样的指令到SDRAM</li>
<li>在自动刷新计数器中，当刷新技术达到刷新周期的值时，控制器便会发出一个自动刷新指令对SDRAM进行周期性的刷新</li>
<li>DRAM控制器最多只能支持两个同一类型的芯片，每个芯片可分配最多256MB的地址空间。</li>
</ol>


<h2>MMU</h2>

<ol>
<li>ARMv6的MMU由协处理器CP15控制，其功能是：地址映射（VA->PA），内存访问权限控制</li>
<li>虚拟地址到物理地址的转换过程：Micro TLB->Main TLB->Page Table Walk</li>
<li>ARMv6的MMU进行地址映射时设计到两种页表，一级页表(first level page table)和二级页表(coarse page table)</li>
<li>关于映射方式有两种：段映射和页映射。段映射只用到一级页表，页映射用到一级页表和二级页表</li>
<li>关于映射粒度：段映射的映射粒度有两种，1M section和16M supersection；页映射的映射粒度也有两种：4K small page和64K large page</li>
<li>硬件在做地址转换时，如何知道当前是什么映射方式以及映射粒度是多少呢？这些信息可以从页表的入口描述符中获得</li>
<li>一级页表总共包含4096个转换描述符，因为是通过虚拟地址的31：20位寻址的，12位能够表示的数最大是4096</li>
<li>通过虚拟地址的高12位偏移，找到页表中的对应描述符，判断描述符的最后两位，确定是什么转换，10的话表示段转换，01表示粗页(64K)转换,11表示细页(4K)转换。如果判断是段转换，将描述符的高12位取出，这个就是物理的基地址，再和虚拟地址的后20位拼接，就得到对应的物理地址。</li>
</ol>


<h2>制作uImage</h2>

<ol>
<li>工具：mkimage，位于uboot的tools文件夹下</li>
<li>命令使用：

<ol>
<li><h2>mkimage -n &lsquo;my_kernel&rsquo; -A arm -O linux -T kernel -C none -a 0x50008000 -e 0x30008040 -d zImage uImage</h2></li>
</ol>
</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-15T21:04:55+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/study/'>study</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/05/05/cmsis-dap/">
		
			CMSIS-DAP</a>
	</h2>
	<div class="entry-content">
		<h2>OpenOCD使用方法</h2>

<ol>
<li>创建Openocd.cfg，输入：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$_TARGETNAME configure -event gdb-attach {
</span><span class='line'>   echo "Halting target"
</span><span class='line'>   halt
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>启动OpenOCD服务器来调试LPC11U35芯片</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo openocd -f interface/jlink.cfg -c "transport select swd" -f target/lpc11xx.cfg -f openocd.cfg </span></code></pre></td></tr></table></div></figure>


<ol>
<li>烧写需要仿真的固件</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>telnet localhost 4444
</span><span class='line'>reset halt
</span><span class='line'>flash probe 0
</span><span class='line'>flash write_image erase /home/yliu/projects/ib51822/IBDAP-FW/Firmware/IBDAP/Debug/IBDAP.bin 0x0
</span><span class='line'>reset
</span><span class='line'>exit</span></code></pre></td></tr></table></div></figure>


<ol>
<li>使用如下命令进行调试</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>target remote localhost:3333
</span><span class='line'>break IBDAP.c:103
</span><span class='line'>monitor reset halt
</span><span class='line'>monitor reset init
</span><span class='line'>continue</span></code></pre></td></tr></table></div></figure>


<h2>使用OpenOCD烧写nRF51822</h2>

<p><img src="http://i.imgur.com/3BaquhS.png" alt="OpenOCD使用实例" /></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-05-05T14:02:05+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/04/18/communication-principle/">
		
			Communication-principle</a>
	</h2>
	<div class="entry-content">
		<h2>消息</h2>

<ol>
<li>语音信号的带宽大约4KHz，图像信号的带宽大约是6MHz，音乐信号的带宽大约20KHz</li>
</ol>


<h2>信道</h2>

<ol>
<li>两个基本问题：

<ol>
<li>信号衰减：导线的电阻与长度成正比；无线电波扩散本身减弱，且被阻挡物吸收</li>
<li>加性噪声：沿途的电阻、固态器件等(包括发送器和接收器中的处理电路)引入固有的随机噪声，最基本的是热噪声</li>
</ol>
</li>
<li>其他问题：

<ol>
<li>外来干扰：其他电磁波、窜线的电信号</li>
<li>信号畸变：信道特性不理想。比如电话线中的寄生电容会使高频信号损失</li>
</ol>
</li>
<li>白高斯噪声（White Gassian Noise）：

<ol>
<li>时域上，随机性服从高斯分布</li>
<li>频域上，噪声均匀分布在所有频率上</li>
<li>功率谱密度值N0/2（物理意义：每Hz内有多少噪声）</li>
</ol>
</li>
</ol>


<h2>电磁波</h2>

<ol>
<li>电波传播主要由其频率值的大小决定。空中传播时主要有三种模式：

<ol>
<li>地波（Ground-Wave）模式：1~2MHz以下的电磁波主要按照这种模式传播，大致可以传输几十公里，主要用于调幅广播</li>
<li>天波（Sky-Wave）模式：3~30MHz的电波反射可以达到几百~1000Km远，主要用于长距离通信，大多数用于军事上</li>
<li>视线（Line-Of-Sight）模式：像广播那样作直线传播，高于30MHz，向上传播时会穿透电离层被反射回来；地面传播时，如遇到遮挡，信号会被阻断会显著衰减，用于电视广播。</li>
</ol>
</li>
</ol>


<h2>频分技术的例子：</h2>

<ol>
<li>频分复用：有线通信中多个话音“错开频率”，共用一条电线传输</li>
<li>频分多址：多个无线用户使用各自的频率，同时接入通信系统</li>
<li>频分双工：每个用户采用不同频率接收和发送，两个方向同时传输</li>
</ol>


<h2>基带与频带传输</h2>

<ol>
<li>基带信号：频谱位于零频率附近的信号</li>
<li>基带传输：保持基带形式，直接传送消息信号</li>
<li>频带信号：频谱位于某高频附近</li>
<li>频带传输：把基带的消息信号转换为频带消息来传输</li>
</ol>


<h2>模拟通信系统</h2>

<ol>
<li>调制：将基带信号变换为适当的频带信号的过程，通常用正弦波携带消息</li>
<li>解调：调制的逆过程</li>
</ol>


<h2>数字通信系统</h2>

<p><img src="http://i.imgur.com/LjU8Kz6.png" alt="数字通信系统" />
1. 格式化：规范化的数字符号序列，必要时，包括模数变化
2. 基带调制：形成合适的电信号，基带信号通常是用脉冲生成
3. 频带调制：转换为频带信号
4. 发射机：将信号送入信道
5. 同步：提供各种定时时钟，使各单元能够正确、有序地工作
6. 信源编码：实现压缩编码，把原始数字消息里面的冗余压缩掉
7. 加密：提供保密性
8. 信道编码：故意加入特殊数据位（如奇偶校验位等），仪表接收端发现和纠正错误
9. 复用：多种消息信号合并在一起
10. 多址接入：多个用户进入与公用系统
11. 频谱扩展：展宽信号频谱可增加抗干扰与保密性，也可以多址接入</p>

<h2>数字技术vs模拟技术</h2>

<ol>
<li>天生的抗噪性</li>
<li>潜在的标准性</li>
<li>便利的实现性</li>
</ol>


<h2>幅度调制&ndash;用消息去控制正弦载波的幅度变化</h2>

<p><img src="http://i.imgur.com/oWMUlEV.png" alt="常规调幅" />
1. 常规调幅（Conv.AM）
    1. m(t)是调制信号
    2. 波形特点：消息凸显在载波包络上
2. 移植载波双边带调幅（DSB-SC）
3. 单边带调幅（SSB）
4. 残留边带调幅（VSB）</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-04-18T16:40:31+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/04/18/de0-nano/">
		
			DE0-Nano</a>
	</h2>
	<div class="entry-content">
		<h2>DE0-Nano开发板简介</h2>

<p><img src="http://i.imgur.com/Gct0bL1.jpg" alt="开发板外观图" /></p>

<ol>
<li>Cyclone IV EP4CE22F17C6N FPGA

<ol>
<li>22320个逻辑资源(LEs)</li>
<li>594Kbits嵌入式内存</li>
<li>66个18X18的嵌入式乘法器</li>
<li>4个通用锁相环PLL</li>
<li>最多153个IO引脚</li>
</ol>
</li>
<li>板载烧写器与串行配置器件（EPCS）</li>
<li>板载32MB的SDRAM与2Kb的I2C EEPROM</li>
<li>板载ADI的3轴加速度传感器ADXL345，精度达到13位</li>
<li>板载12位ADC芯片：ADC128S022，采样速率：50ksps~200ksps</li>
<li></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-04-18T10:26:16+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/04/13/ieee-1588/">
		
			IEEE-1588</a>
	</h2>
	<div class="entry-content">
		<h2>概述</h2>

<ol>
<li>在分布式网络化的控制系统中，考虑到调度和控制的实时性，对时间同步的精度要求非常严格。</li>
<li>影响分布式测控系统实时性差的主要根源：

<ol>
<li>各个测控设备之间的时钟差异</li>
<li>测控数据在网络中的传输延迟</li>
</ol>
</li>
<li>网络时间协议NTP虽然通过一定的硬件配合和算法优化，可以提供系统的时钟同步性，但是只能达到毫秒级的同步精度要求</li>
<li>实现1588协议只需要在原有的网络上添加事件同步报文，这些报文占用少量的网络资源，他们只是和控制数据包或其他信息包共享网络。该协议成本低，而且独立于操作系统之外，适应性强，安装简单，无需复杂的配置工作，理论上其同步精度可以达到纳秒级。</li>
<li>IEEE 1588标准定义了一种精确时间协议PTP，该协议为分布式测控应用而设计，基于报文流加时间戳的思想，采用软、硬结合的实现方式，旨在实现亚微秒级的同步精度。协议完全兼容以太网技术，协议报文均是基于UDP/IP多播报文发送，特别适合基于局域网的分布式应用。</li>
</ol>


<h2>时间同步的概念</h2>

<ol>
<li>时间同步包括频率同步和时间同步

<ol>
<li>频率同步

<ol>
<li>是指信号之间的频率保持某种严格的特定关系，比如有效瞬间表现为同一平均速率，以此维持通信网络中所有节点以相同的速率运行</li>
<li>数字通信中传递的信号是对原始信息进行编码后得到的PCM（脉冲编码调制）离散脉冲。假如通信网中某两个节点之间的时钟频率不同，或者由于数字比特流在传输中因噪声干扰而叠加了相位漂移和抖动，便会在接收节点的缓冲存储器中产生码元的丢失或重复，最终导致比特流出现滑码。</li>
</ol>
</li>
<li>时间同步

<ol>
<li>时间同步的定义便是根据接收到的时间来调节通信网络中节点的时钟和时钟所显示的时刻。</li>
<li>时间同步和频率同步既有联系又有区别，它既调节时钟的频率同时也调节时钟的相位。由于相位和时间都是对频率的积分，所以又称时间同步为相位同步。</li>
<li>与频率同步不同的是，时间同步接受离散的时间信息，离散的调节节点时钟。</li>
<li>时间同步完成两个重要功能，即对时和守时。对时就是对表，通过不定期的对表操作，将本地节点的时刻与远端节点的标准时刻进行相位同步；守时就是频率同步，即在对表的间隙里，保证本地节点时刻与远端节点的标准时刻之间的偏差在一个允许的范围之内</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>现有的几种同步技术</h2>

<ol>
<li>GPS对时系统

<ol>
<li>GPS可以同时跟踪太空中的24颗GPS卫星，自动选择最佳星座进行定位、定时。</li>
</ol>
</li>
<li>电路仿真技术</li>
<li>同步以太网技术

<ol>
<li>以太网在物理层与SDH一样采用串行码流方式进行传送，因此响应的接收端必须提供时钟恢复业务，否则仍然会出现滑码现象。所以，以太网本身具备了传递时钟信息的功能。</li>
</ol>
</li>
<li>包时钟技术

<ol>
<li>包时钟ToP（Time over Packet），就是利用分组网络来传递时间信息。时间报文的格式可以多种多样，比如RTP、NTP、IEEE 1588，只要报文中懈怠了时间信息就可以了。</li>
<li>IEEE 1588标准又称作PTP协议，主要用于工业以太网，具有亚微秒级的时间精度，可以同时传递频率信息和相位信息</li>
</ol>
</li>
</ol>


<h2>IEEE 1588标准介绍</h2>

<ol>
<li>IEEE 1588标准的全称是《网络测量和控制系统的精确时钟同步协议》（Precision Clock Synchronization for Networked Measurement and Control Systems）,也被称作PTP协议，它在各种同步协议中的同步精度是最高的</li>
<li>IEEE 1588:2008也称为IEEE 1588第二版，其主要基于以下几个要求

<ol>
<li>实现亚微秒级的时间同步，用于均是和实际的测试与测量中</li>
<li>缩短时间报文使其等长，来满足通信网中的应用，登场保温传递时的延时变化较小</li>
<li>提供容错特性，来从网络重建和祖母时钟崩溃中快速恢复</li>
<li>能把协议映射到一些非以太网的网络中</li>
</ol>
</li>
<li>与第一版相比，第二版的改进：

<ol>
<li>报文格式。为了缩短报文长度，同步报文被分隔成Announce（声明报文）和Sync（同步报文），分别实现最佳主时钟算法和时间同步。</li>
<li>端到端透明时钟。</li>
<li>第一版中所有报文都是通过多播传递的，第二版提供了一种机制使得从时钟可与主时钟协商后在一定时间间隔内使用单播传输，这种特性广泛应用于通信中。</li>
</ol>
</li>
<li>IEEE 1588系统构成
<img src="http://i.imgur.com/yGeFBPc.png" alt="典型的PTP系统模型" /></li>
<li>IEEE 1588协议是一种说明系统中的实时PTP时钟如何相互同步的分布式协议，普通时钟和边界时钟被组织在一个主从同步层次中。PTP协议中的报文分为两类，即事件（Event）报文和一般（General）报文。

<ol>
<li>Event Messages：同步报文，延时请求，P2P延时请求，P2P延时响应。属于定时消息，发送或者接收的时刻需要打时间戳</li>
<li>General Messages：管理报文，声明报文，信令报文，跟随报文，延时响应，点延时相应跟随。不属于定时消息，不需要打时间戳</li>
</ol>
</li>
<li>PTP协议中，节点是一个包含实时时钟的设备，这个时钟可能会有多种用途，例如产生PTP报文的时间戳，或者触发由该节点管理的事件。</li>
<li>PTP协议包括两个方面：时钟同步功能和管理功能。所有的普通时钟在这两个方面的表现都相同，边界时钟的每一个端口相当于一个普通时钟。管理节点不需要实现时钟同步功能而只需要实现管理功能，除非它本身也是一个时钟节点。</li>
<li>IEEE 1588的所有时钟都是向224.0.1.129这个组播地址不停的发送网络报文的。</li>
</ol>


<h2>IEEE 1588工作机制</h2>

<ol>
<li>建立主从秩序。网络中的各个节点通过最佳主时钟算法，选举出祖母时钟、主时钟和从时钟。祖母时钟精度最高，主时钟次之，从时钟最低。</li>
<li>低等级的时钟向高等级的时钟进行同步。网络中的主从时钟通过握手机制进行同步报文的交换。</li>
</ol>


<h2>GPS</h2>

<ol>
<li>通过串口解析出来的GPS时间信息是UTC时间，UTC时间是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。UTC时间起点是1970年1月1日0时整。在IEEE1588 v2协议中，时间值的存储是以48位秒值和32位纳秒值两种形式构成的。</li>
</ol>


<h2>DP83640</h2>

<p><img src="http://i.imgur.com/DdVpWWZ.png" alt="DP83640功能框图" /></p>

<ol>
<li>全面支持IEEE 1588协议的物理层芯片，不但提供了完整的MII，还设计了12个GPIO引脚实现实时动作处理功能，其特点如下

<ol>
<li>支持IEEE 1588 v1和v2</li>
<li>支持以太网UDP/IP第四版，UDP/IP第六版和Layer2协议</li>
<li>支持高精度IEEE 1588时钟同步，时间戳最大分辨率可达8ns</li>
<li>提供12个可配置GPIO</li>
<li>频率可配置的同步时钟输出</li>
</ol>
</li>
<li>DP83640对IEEE 1588协议中对实时性要求极高的部分提供了完整的硬件支持，分别是

<ol>
<li>IEEE 1588同步时钟的产生</li>
<li>时钟同步报文的硬件标记</li>
<li>事件触发和事件捕获的时间戳标记</li>
</ol>
</li>
<li>DP83640的功能

<ol>
<li>IEEE 1588时钟输出。DP 83640可以向外部设备提供频率可调的同步时钟信号，其标称频率为250/nMHz，其中n为2~255之间的任意整数，即980.4kHz~125MHz之间的离散值</li>
<li>IEEE 1588事件触发。DP 83640可以在GPIO引脚上产生一个基于IEEE 1588时钟的触发信号，这个信号可以是一次性上升或下降沿，脉宽可调的单脉冲或者周期信号。DP 83640可以为每一个触发器指定相应的GPIO输出引脚以及触发时刻。当内部IEEE 1588时钟走时到达此值时，事件被触发。芯片最多可支持在任意GPIO引脚上发送八个触发信号。可支持在单引脚上发送多重触发信号，支持产生复杂的信号波形。此时，个触发信号通过逻辑或组合在一起产生一个联合信号。使用DP83640提供的触发功能，还可以让芯片输出一个秒脉冲信号</li>
<li>IEEE 1588时间戳标记。DP 83640可以为发生的外部事件标记时间戳。事件的监测可通过外部脉冲的上升沿或下降沿。事件时间戳标记单元可最多监测任意GPIO引脚上发生的八个外部事件。事件时间戳以单一序列的方式保存，此序列可最多保存八个时间戳信息。需要对事件时间戳做出35ns（频率125MHz的IEEE1588参考时钟的周期X3+11ns）的调整，来消除由于输入延迟和同步延迟带来的影响。</li>
<li>IEEE 1588同步报文检测。DP 83640的发送报文解析器和接收报文解析器可以自动检测节点发送和接收的符合IEEE 1588第一版和第二版所定义的同步报文，并将其时间戳信息提供给软件。</li>
</ol>
</li>
<li>所有的配置引脚（strap pin）内部都有微弱的上拉电阻或者下拉电阻，如果要改变默认配置，那么需要在该引脚外面上拉或者下拉2.2K的电阻。</li>
<li>7号引脚默认情况下是作为power-down的输入引脚，低电平有效。这等效于将BMCR寄存器中的bit11置1.将MICR寄存器的INT_OE位置1将会使器件跳出Power Down状态。</li>
<li>DP83640集成了系统诊断功能，能够评估连接的质量，检测潜在的错误</li>
<li>内部寄存器

<ol>
<li>ANAR(Auto Negotiation Advertisement Register)@04H

<ol>
<li>自动协商的能力</li>
</ol>
</li>
<li>BMCR(Basic Mode Control Register)@00H

<ol>
<li>使能、失能、重启自动协商</li>
<li>提供状态，包括：自动协商是否完成，连接对方是否发生了错误，是否建立了稳定的连接，</li>
<li>往Bit14写1开启loopback模式，开启loopback模式之前需要关闭自动协商</li>
<li>将bit11置1将使器件进入低功耗模式</li>
</ol>
</li>
<li>PHYSTS（PHY Status Register）@10H

<ol>
<li>Link Speed</li>
<li>bit3可以检测到是否开启loopback模式</li>
</ol>
</li>
<li>PHYCR（PHY Control Register）@19H

<ol>
<li>Auto-MDIX默认情况下是使能的，并能够通过该寄存器的【15：14】来重新配置</li>
<li>【6：5】设置LED的工作模式</li>
</ol>
</li>
<li>LEDCR @18H

<ol>
<li>设置LED闪烁频率</li>
</ol>
</li>
<li>MICR @11H

<ol>
<li>bit0置1将配置7号引脚作为低电平有效的中断输出</li>
<li>将INT_OE位置1，使器件退出低功耗模式</li>
<li>将bit1置1将会使能中断输出</li>
</ol>
</li>
<li>MISR @12H

<ol>
<li>低字节是各种中断的使能掩码</li>
<li>高字节是各中断的状态掩码</li>
<li>读MISR寄存器将会清除所有挂起的中断</li>
</ol>
</li>
<li>EDCR（Energy Detect Control） @1DH

<ol>
<li>是否使能Energy Detect Mode</li>
</ol>
</li>
<li>PAGESEL(Page Select Register) @13H</li>
<li></li>
</ol>
</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-04-13T23:20:07+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/03/21/latex/">
		
			Latex</a>
	</h2>
	<div class="entry-content">
		<h2>LaTeX简介</h2>

<ol>
<li>LaTeX是一种基于TeX的文档排版系统。</li>
<li>LaTeX并不是单独的程序，现在的TEX系统都是复杂的软件包，里面包含各种排版的引擎、编译脚本、格式转换工具、管理界面、配置文件、支持工具、字体以及数以千计的宏包和文档。一个TeX发行版就是把所有这样的部件都集合在一起，打包发布的软件</li>
<li>TeX是由TeX用户组发布的一个发行版，跨平台</li>
<li>LaTeX的命令以反斜线\开头，命令一般用英文单词命名，有的可以带参数。</li>
<li>严格来说，LaTeX并不是标记语言，而是主要基于字符串代换的宏语言
<img src="http://i.imgur.com/b7BVgmf.png" alt="使用各种引擎编译LaTeX文档的简要流程" /></li>
<li>导言区常用命令：

<ol>
<li>声明文章的标题:\title{An Embedded FTP Server Powered by PoE}</li>
<li>声明文章的作者:\author{morris}</li>
<li>声明写作日期:\date{\today}</li>
<li>声明参考文献的格式:\bibliographystyle{plain}</li>
</ol>
</li>
<li>以\begin{document}和\end{document}声明了一个document环境，里面是论文的正文部分，也是直接输出的部分</li>
<li>\maketitle命令实际输出论文标题</li>
<li>\tableofcontents命令输出目录</li>
<li>\section命令开始新的一节</li>
<li>使用空行分段，单个换行并不会使文字另起一段，而只是起到使源代码更易读的作用，空行只起分段作用，使用很多空行并不起任何增大间距的作用</li>
<li>短浅不用打空格，LaTeX会自动完成文字的缩进，即使手工在前面打了空格，LaTeX也会将其忽略</li>
<li>汉字后面的空格会被忽略，其他符号后面的空格则保留。单个的换行就相当于一个空格，因此源代码中大段文字可以安全地分成短行，空格只起分隔单词或符号的作用，使用很多空格并不起到任何增大字词间距的作用</li>
<li>在需要使用注脚的文字后面使用命令:\footnote{注脚内容}</li>
<li>需要强调的内容使用命令:\emph{内容}</li>
<li>命令都以反斜线\开头，后接命令名，命令名或者是一串字母，或是单个符号。命令可以带一些参数，如果命令的参数不止一个字符(不包括空格)，就必须用花括号括起来。可选参数如果出现，则使用方括号括起来。
<img src="http://i.imgur.com/t6MSwSB.png" alt="LaTeX命令的格式" /></li>
<li>引用的内容是在正文中使用quote环境得到,quote环境即以\begin{quote} 和\end{quote} 为起止位置的部分。它将环境中的内容单独分行，增加缩进和上下间距排印，以突出引用的部分。</li>
<li>文章的摘要也是在\maketitle之后用abstract环境生成的
<img src="http://i.imgur.com/eQWRnSC.png" alt="LaTeX环境的一般格式" /></li>
<li>最简单的输入公式的办法是把公式用一对美元符号$$括起来，如使用$a+b$就得到漂亮的a+b，这种夹在行文中的公式称为正文公式或行内公式。对比较长或比较重要的公式，一般则单独居中写在一行；为了方便引用，经常还给公式编号。这种公式被称为显示公式或列表公式，使用equation环境就可以方便的输入这种公式。</li>
<li>键盘上没有的符号，就需要使用一个命令来输入。例如表示角的符号就可以用\angle输入。命令的名字通常也就是符号的名字，圆周率的符号用\pi来表示</li>
<li>符号^用来引入一个上标，而_则引入一个下标，它们用起来差不多等同于一个带一个参数的命令，因此多个字符的上下标需要使用花括号分组，如$2^{10}=1024$</li>
<li>怎么输入90°，LaTeX默认的数学字体中，并没有一个专门用于表示角度的符号，自然也没有这么命令，角度的符号°是通过上标输入的：$^\circ$</li>
<li>插图功能不是由LaTeX的内核直接提供的，而是由graphicx宏包提供的。要使用graphicx宏包的插图功能，需要在源文件的导言区使用\usepackage命令引入宏包</li>
<li>引入graphicx宏包后就可以使用\includegraphics命令插图了，比如：\includegraphics[scale=0.4]{DC-DC.jpg}。插入的图形就是一个有内容的矩形盒子，在正文中和一个很大的字符没有多少区别。支持的图形格式包括PDF、PNG、JPG、EPS 等。</li>
<li>除了一些很小的标志图形，我们很少把插图直接夹在文字之中，而是使用单独的环境列出。而且很大的图形如果固定位置，会给分页造成困难。因此，通常把图形放在一个可以变动的相对位置的环境中，称为<strong>浮动体</strong>。在浮动体中还可以给图形加入说明性的标题。例如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\begin{figure}[ht]
</span><span class='line'>\centering
</span><span class='line'>\includegraphics[scale=0.6]{xiantu.pdf}
</span><span class='line'>\caption{宋赵爽在《周髀算经》注中作的弦图（仿制），该图给出了勾股定
</span><span class='line'>理的一个极具对称美的证明。}
</span><span class='line'>\label{fig:xiantu}
</span><span class='line'>\end{figure}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>在上面的代码中，figure环境有可选参数[ht]，表示浮动体可以出现在环境周围的文本所在处(here)和一页的顶部(top)，figure环境内部相当于普通的段落（默认没有缩进）；使用声明\centering表示后面的内容居中；使用caption命令给插图加上自动编号和标题</li>
<li>制作表格需要确定的是表格的行、列对齐模式和表格线，这是由tabular环境完成的：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\begin{table}[H]
</span><span class='line'>\begin{tabular}{|rrr|}
</span><span class='line'>\hline
</span><span class='line'>直角边$a$ & 直角边$b$ & 斜边$c$ \\
</span><span class='line'>\hline
</span><span class='line'>3 & 4 & 5 \\
</span><span class='line'>5 & 12 & 13 \\
</span><span class='line'>\hline
</span><span class='line'>\end{tabular}%
</span><span class='line'>\qquad
</span><span class='line'>($a^2 + b^2 = c^2$)
</span><span class='line'>\end{table}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>tabular环境中有一个参数，里面声明了表格中列的模式，在前面的表格中，|rrr|表示表格有3列，都是右对齐，在第一列和第三列后面各有一条垂直的表格线。在tabular环境内部，行与行之间用命令\隔开，每行内部的表项则用符号&amp;隔开。表格中的横线则是用命令\hline产生的。表格与插图一样，都是一个比较大的盒子，一般也放在浮动环境中，即table环境</li>
<li>使用\bibliographystyle{plain}声明了参考文献的格式，用\bibliography{math}命令打印参考文献列表。实际上这只是BibTeX处理文献的一个空架子，还需要定义“参考文献数据库”。BibTeX使用的参考文献数据库其实就是个后缀为.bib的文件。BibTeX数据库经常不需要我们自己录入，而可以从相关学科的网站直接下载或是从其他类型的文献数据库转换得到。定义好参考数据库后在正文中使用\cite命令选择需要LaTeX列出的文献。</li>
<li>引用不仅限于参考文献，图表、公式的编号，只要事先设定了标签，同样可以通过辅助文件为中介引用。基本的交叉引用命令是\ref，它以标签为参数，得到被引用的编号。数学宏包amsmath就定义了\eqref命令，专门用于公式的引用，并能产生括号</li>
<li>设计页面尺寸可以使用geometry宏包：\geometry{a6paper,centering,scale=0.8}，表示页面使用A6纸大小，版心居中，长宽占页面的0.8</li>
<li>改变图标标题格式可以使用caption宏包：\usepackage[format=hang,font=small,textfont=it]{caption}表示设置图表所有标题使用悬挂对齐方式，整体用小字号，而标题文本使用斜体（对汉字来说就是楷体）</li>
<li>增加目录的项目则可以用tocbibnd宏包：\usepackage[nottoc]{tocbibind}，宏包默认会在目录中加入目录项本身、参考文献、索引等项目，这里使用nottoc选项取消了在目录中显示目录本身</li>
<li>自定义环境命令,\newenvironment有3个参数，第一个参数是环境的名字，后两个参数分别是在环境开始和末尾处的代码</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\newenvironment{myquote}
</span><span class='line'>{\begin{quote}\kaishu\zihao{-5}}
</span><span class='line'>{\end{quote}}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>自定义新的命令：\newcommand\degree{^\circ}</li>
<li>LaTeX是一种结构化的排版语言，在填写便准格式的模板时可以忽略编号、格式等许多具体细节。在文档排版中应主动追求内容与格式的分离，在document环境之内避免直接使用诸如字体字号、对齐缩进的格式控制命令，而代之以有具体意义的环境和命令，让文档变得清晰</li>
</ol>


<h2>文字与符号</h2>

<ol>
<li>LaTeX中的特殊字母
<img src="http://i.imgur.com/lWzOtlB.png" alt="LaTeX中的特殊字母及命令" /></li>
<li>LaTeX提供了babel宏包，可以方便同时访问多种语言的字母表，babel宏包可带有一个或多个语言的可选参数，支持不同的语言，如:\usepackage[greek,english]{babel},将使用英语和希腊语，其中最后一个参数的英语是默认语言，此时希腊语就可以用ASCII字符代替：\textgreek{abcd}</li>
<li>LaTeX在盘拌种会将单词中的一些字母连写为一个符号，即连字，连字的有无和多少一般是由使用的字体决定的，比如fi和fl连在了一起，有时候为了美观考虑取消连字，可以使用空的分组，比如：f{}ind</li>
<li>在每个标点之后应该加上空格，以保证正确的距离和换行</li>
<li>LaTeX中遇到单引号和双引号连续出现的情形，则在双引号和单引号之间用\隔开</li>
<li>除了在数学模式中表示减号，符号-在LaTeX正文中也有多种用途：单独使用时它是连字符，两个连用时en dash，用来表示数字范围；三个连用是em dash，即破折号</li>
<li>圣罗浩使用\ldots或者\dots命令产生，相比直接输入三个句号，它所略微拉开的间距要合理的多</li>
<li>标准键盘上不能直接录入的标点符号
<img src="http://i.imgur.com/FT4ZOtP.png" alt="标准键盘不能直接录入的标点符号" /></li>
<li>文本中的空格起分隔单词的作用，任意多个空格与一个空格的功能相同；只有字符后面的空格使有效的，每行最前面的空格会被忽略。单个换行也被看做是一个空格</li>
<li>有一种不可打断的空格，在TeX中被称为带子，用~表示，TeX禁止在这种空格之间分行，因为可以用来表示一些不宜分开的情况
<img src="http://i.imgur.com/qKvkp9w.png" alt="带子的使用" /></li>
<li>西文的逗号、句号、分号等标点后面应该加空格，这不仅能保证正确的间距，也能保证正确的换行。这是因为，标点后如果没有空格，就不能换行。</li>
<li>空行，即用连续两个换行表示分段，段与段之间会自动得到合适的缩进，任意多个空行与一个空行的效果相同</li>
<li>除了分段，也可以让LaTeX直接另起一行，并不分段。\命令直接另起一行，上一行保持原来的样子，\命令可以带一个可选的长度参数，表示换行后增加的额外垂直间距，例如\[2cm]。\linebreak则指定一行的断点，上一行仍按完整一行散开对齐</li>
<li>特殊符号
<img src="http://i.imgur.com/T5X1sug.png" alt="正文中常用的特殊符号" /></li>
<li>LaTeX的基本工具宏包textcomp就定义了大量用于文本的符号，例如欧元符号\texteuro，千分符\textperthousand等。tipa宏包提供了国际音标字体的访问</li>
<li>预定义命令的字体族有3种：罗马字体族、无衬底字体族和打字机字体族，其命令为：
<img src="http://i.imgur.com/uiy67RS.png" alt="预定义命令的字体族" /></li>
<li>预定义命令的字体形状有4种：直立形状、意大利形状、倾斜形状、小型大写形状，其命令为：
<img src="http://i.imgur.com/NPpS0NK.png" alt="预定义命令的字体形状" /></li>
<li>预定义命令的字体系列有中等和加宽加粗两类
<img src="http://i.imgur.com/kIXpFT7.png" alt="预定义命令的字体系列" /></li>
<li>对于中文字体，一般只是用不同字体族进行区分。xeCJK和CJK宏包机制下，中文字体的选择命令和西文字体是分离，选择中文字体族使用\CJKfamily</li>
<li>中文的字体族，根据不同的系统和使用方式有不同，在ctex宏包及文档下有一些预定义
<img src="http://i.imgur.com/eBwRbYt.png" alt="ctex宏包提供的简化中文字体命令" /></li>
<li>字体命令：

<ol>
<li>\emph表示强调，用于把直立体改为意大利体，把意大利体改为直立体</li>
<li>\underline可以给文字或公式加下划线</li>
</ol>
</li>
<li>基本的LaTeX提供了10个简单的生命是命令调整文字的大小
<img src="http://i.imgur.com/QXMMMsV.png" alt="声明式命令调整文字大小" /></li>
<li>中文字号可以使用ctex宏包或者ctexart等文档类提供的\zihao命令设置
<img src="http://i.imgur.com/H0dDab2.png" alt="中文字号" /></li>
<li>LaTeX中的行距是与字号直接相关的，在设置字号的时候，同时也就设置了基本行距为文字大小的1.2倍</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-03-21T11:09:15+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/03/09/fieldbus/">
		
			FieldBus</a>
	</h2>
	<div class="entry-content">
		<h2>485总线</h2>

<ol>
<li>485，一般称作RS485/EIA-485，是隶属于OSI模型物理层的电气特性规定为2线，半双工，多点通信的标准。它的电气特性和RS-232不一样，用缆线两端的电压差值来表示传递信号。</li>
<li>RS485仅仅规定了接收端和发送端的电气特性，没有规定或推荐任何数据协议，常用的协议是ModBus</li>
<li>RS485的特点：

<ol>
<li>接口电平低，不易损坏芯片。RS485的电气特性：逻辑“1”以两线间的电压差为+(2~6)V表示；逻辑“0”以两线间的电压差为-(2~6)V表示。接口信号电平比RS232降低了，不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL电路连接</li>
<li>传输速率高。10米时，RS485的数据最高传输速率可达35Mbps，在1200时传输速率可达100Kbps</li>
<li>抗干扰能力强。RS485接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力增强，即抗噪声干扰性好</li>
<li>传输距离远，支持节点多。RS485总线最长可以传输1200m以上(速率≤100Kbps)，一般足底啊支持32个节点，如果使用特制的485芯片，可以达到128个或者256个节点，足底啊可以支持到400个节点</li>
</ol>
</li>
<li>RS485推荐使用在点对点网络中，线型，总线型，不能是星型，环形网络。理想情况下RS485需要2个终端匹配电阻，其阻止要求等于传输电缆的特性阻抗，一般为200Ω。没有特性阻抗的话，当左右的设备都静止或者没有能量的时候就会产生噪声，而且线移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据信号的边缘，导致数据传输出错。</li>
<li>推荐的连接方式如下，如果需要添加匹配电阻，一般在总线的起止端加入，也就是主机和设备4上面各加要给120Ω的匹配电阻
<img src="http://i.imgur.com/RlEPFc5.png" alt="RS485连接" /></li>
<li></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-03-09T11:46:13+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/02/19/altium-designer/">
		
			Altium_designer</a>
	</h2>
	<div class="entry-content">
		<h2>软件汉化</h2>

<ol>
<li>DXP->Preferences</li>
<li>在System->General中选择Use localized resources复选框</li>
<li>重启软件</li>
</ol>


<h2>恢复桌面布局</h2>

<p>当文件桌面发生混乱时，可通过View->Desktop Layout->Default命令来恢复默认的桌面布局</p>

<h2>公制与英制</h2>

<p>1mil = 1/1000inch = 0.0254mm</p>

<h2>设置图纸格点</h2>

<p>图纸格点设置包括两个方面，一个是图纸的Snap捕捉格点，一个是可视格点，还有一个是电栅格（电气格点）。
1. snap捕捉格点：表示放置线时可以捕捉到放置端点位置的点。
2. 可视格点：表示可见到的网格大小
3. 电栅格：绘制原理图的导线时系统会以电栅格大小为半径，以光标所在位置为中心进行查找电气节点，如果在此范围内有电气节点则光标会自动移动到此电气节点上</p>

<h2>视图的刷新</h2>

<p>绘制原理图时，在完成滚动画面、移动元件等操作后，又会出现画面显示残留的斑点、线段或图形变性等问题。虽然这些内容不会影响电路的正确性，但是为了美观，通过View->Refresh命令可以使显示恢复</p>

<h2>选择一个连接上的所有导线</h2>

<p>选择Edit->Select->Connection命令，将鼠标指针移动到某个连接的导线上，单击，则该连接上的所有导线都被选中，并高亮地显示出来，元器件也被特殊标示出来</p>

<h2>绘制椭圆曲线</h2>

<p>在绘图工具栏中选择绘制椭圆，按Tab键，输入相应的配置参数后在不移动鼠标的情况下连续单击5次</p>

<h2>使用Ultra Librarian软件自动生成原理图库和封装库</h2>

<ol>
<li><a href="http://webench.ti.com/cad/ULib.zip">下载ULib</a>，解压缩后安装</li>
<li>打开软件，Load Data导入bxl文件(芯片厂商提供)</li>
<li>选择输出格式为Altium Designer，然后Export，导出的文件一般放在软件目录的Exported下，比如D:\UltraLibrarian\Library\Exported
<img src="http://i.imgur.com/H9HAk1N.png" alt="数据文件导入" /></li>
<li>进入导出后的文件夹，用altium软件打开PrjScr工程文件</li>
<li>在打开的软件中双击打开UL_Form.pas文件，并运行</li>
<li>紧接着弹出的对话框中，选择导出文件夹下的【日期.txt]格式的文件</li>
<li>完成后会在相同的目录下生成需要的库文件
<img src="http://i.imgur.com/l3Mzy9u.png" alt="使用Altium软件完成余下工作" /></li>
</ol>


<h2>测量距离</h2>

<p>快捷键：Ctrl+M</p>

<h2>Mechanical13和Mechanical15</h2>

<ol>
<li>Mechanical13用于代表元件封装本体外形</li>
<li>Mechanical15用于表示囊括元件外形（包括管脚）所需的最小矩形</li>
</ol>


<h2>从PCB文件生成封装库文件</h2>

<ol>
<li>Altium提供了一个从PCB文件生成封装库文件的功能，该功能自动创建一个封装库并将PCB文件中所有用到的元件封装导入该封装库</li>
<li>方法：在PCB编辑器中单击：Design->Make PCB Library</li>
</ol>


<h2>敷铜</h2>

<ol>
<li>印刷线路板上大面积的敷铜通常有两种，一种用作散热，一种用作屏蔽来减小干扰</li>
<li>大面积敷铜上一般要开窗口（网状），这是由于印刷线路板板材的基板与铜箔之间的粘合剂在浸焊或长时间受热（如波峰焊），会产生挥发性气体无法排出，热量不易散发，以致产生铜箔膨胀、脱落现象。</li>
<li>每个板卡都包含了大量敷铜多边形，在设计时一个方便的管理方法就是把他们堆放在一起，即所谓敷铜搁置，也称敷铜堆放。堆放敷铜多边形不会将他们删除，而是把它们放进PCB文件中保留其完整的定义，但在设计窗口中他们将不再出现。</li>
<li>敷铜管理器：Tool->Polygon Pours->Polygon Manager</li>
</ol>


<h2>PCB的组成部分</h2>

<ol>
<li>元件：用于完成电路功能的各种器件</li>
<li>铜箔：铜箔在电路板上可以表现为导线、焊盘、过孔和敷铜等</li>
<li>丝印层：印刷电路板的顶层，采用绝缘材料制成。在丝印层上可以标注文字，注释电路板上的元件和整个电路板。丝印层还能起到保护顶层导线的功能</li>
<li>印制材料：采用绝缘材料制成，用于支撑整个电路板</li>
</ol>


<h2>PCB的板层</h2>

<ol>
<li>Altium Designer提供堆栈管理器对各层属性进行管理，在堆栈管理器中可以定义层的结构，看到堆栈层的立体效果。选择：Design->Layer Stack Manager</li>
<li>PCB工作层面可以分成以下几种类型：

<ol>
<li>信号层：即为用于建立电气连接的铜箔层</li>
<li>内平面：是专门用于建立电源网络的铜箔，可以算作信号层的一种</li>
<li>机械层：是用于支持电路板的印制材料层</li>
<li>掩膜层：为了方便焊接而设立的

<ol>
<li>Top/Bottom Solder，阻焊层，是指印刷电路板要上绿油的部分。实际上这阻焊层使用的是负片输出，所以在阻焊层的形状映射到板子上以后，并不是上了绿油阻焊，反而是露出了铜皮。所以阻焊层的意思是在整片阻焊的绿油上开窗，目的是允许焊接，默认情况下，没有阻焊层的区域都要上绿油</li>
<li>Top/Bottom Paste，锡膏防护层，这一层只要露出所有需要焊接的焊盘</li>
</ol>
</li>
<li>丝印层：即电路板的说明文字层</li>
<li>其余层

<ol>
<li>Drill Guide和Drill Drawing：用于描述钻孔图及钻孔位置</li>
<li>Keep-out Layer：禁止布线层</li>
<li>Multi-Layer：设置更多层面</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>电路板物理与电气边界</h2>

<ol>
<li>电路板的物理边界由机械层1来定义</li>
<li>电路板的电气边界由Keep-out层来定义</li>
<li>一般物理边界与电气边界间距50mil即可。比如电路板大小为5000milX4000mil，那么电气边界大小为4900milX3900mil</li>
</ol>


<h2>PCB设计规则(执行菜单命令：Design->Rules)</h2>

<ol>
<li>一般每个特定的网络布线宽度规则需要添加一个规则名称，以便与其他网络区分</li>
<li>通常为了降低布线间的耦合面积，减小干扰，不同层的布线需要设置成不同的走向。如双层板，默认状态下顶层为垂直走向，底层为水平走向。</li>
<li>表贴式焊盘的引出导线一般都是引出一段长度后才开始拐弯，这样就不会出现和相邻焊盘太近的情况</li>
<li>阻焊层扩展

<ol>
<li>通常阻焊层除焊盘或过孔外，整面都铺满阻焊剂。阻焊层的作用就是防止不该被焊上的部分被焊锡连接，回流焊就是靠阻焊层实现的。板子整面经过高温的锡水，没有阻焊层的裸露电路板就被粘锡焊接了，而有阻焊层的部分则不会粘锡。阻焊层的另一个作用是起到提高布线的绝缘性，防氧化和美观</li>
<li>阻焊剂印制到电路板上时，焊盘或过孔被空出，空出的面积要比焊盘或过孔大一些，这就是阻焊层扩展</li>
</ol>
</li>
<li>锡膏防护层扩展

<ol>
<li>表贴式组件在焊接前，先对焊盘涂一层锡膏，然后将组件粘在焊盘上，再用回流焊机焊接。通常在大规模生产时，标贴式焊盘的涂膏是通过一个钢模完成的。钢模上对应焊盘的位置按焊盘形状镂空，涂膏时将钢模覆盖在电路板上，将锡膏放在钢模上，用括板来回括，锡膏通过镂空的部位涂到焊盘上。PCB设计软件的锡膏层或锡膏防护层的数据就是用来制作钢模的，钢模上镂空的面积要比设计焊盘的面积小，这个差值便是锡膏防护层扩展，默认是0mil</li>
</ol>
</li>
<li>在数字电路中，是否为高频电路取决于信号的上升沿和下降沿，而不是信号的频率</li>
<li>当系统工作在50MHz时，将产生传输线效应和信号完整性问题。当系统时钟达到120MHz时，除非使用高速电路设计知识，否则基于传统方法设计的PCB将无法工作。</li>
<li>通常约定如果线传播延时大于数字信号驱动端的上升时间，则认为此类信号是高速信号并产生传输线效应</li>
<li>PCB上每英寸/单位的延时时间为0.167ns，但是如果过孔多，器件引脚多，布线上设置的约束多，延时将增大</li>
<li>如果采用CMOS或TTL电路进行设计，工作频率小于10MHz时，布线长度应不大于7in。工作频率在50MHz以上时，布线长度应不大于1.5in。如果工作频率达到或超过75MHz时，布线长度应在1in。对于GaAs芯片最大的布线长度应为0.3in。</li>
<li>解决传输线效应的另一个方法是选择正确的布线路径和终端拓扑结构。走线的拓扑结构是指一根网线的布线顺序以及布线结构。当使用告诉逻辑器件的时候，除非走线分支长度保持很短，否则边沿快速变化的信号将被信号主干走线上的分支走线所扭曲。通常情形下，PCB走线采用两种基本拓扑结构，即<strong>菊花形</strong>布线和<strong>星形</strong>布线。</li>
<li>对于菊花形布线，布线从驱动端开始，一次到达各接收端。如果使用串联电阻来改变信号特性，串联电阻的位置应该紧靠驱动端。在控制走线的高次谐波干扰方面，菊花链走线效果最好。</li>
<li>星形拓扑结构可以有效避免时钟信号的不同步问题，但在密度很高的PCB上手工完成布线十分困难。采用自动布线器是完成星形布线的最好方法。每条分支上都需要终端电阻。终端电阻的阻值应和连线的特征阻抗相匹配。</li>
<li>等长网络布线规则也称为匹配网络长度规则，用于设置指定网络等长布线规则。该规则以规定范围中的最长布线为基准，使其他网络通过匹配调整操作，以增长布线的形式在设定的公差范围内与之等长。增长的布线按设定的迂回模式（折现模式）进行布线。</li>
<li>在高速PCB设计时，设计者总是希望过孔越小越好，这样板上就可以有更多的布线空间。此外，过孔越小，其自身的寄生电容也越小，更适合用于高速电路。但孔尺寸的减小同时带来了成本的增加。当孔的深度超过钻孔直径的6倍时，就无法保证孔壁能均匀镀铜。随着激光钻孔技术的发展，钻孔的尺寸越来越小，一般直径小于等于6mil的过孔称为微孔。</li>
<li>过孔在传输线上表现为阻抗不连续的断点，会造成信号的反射。一般过孔的等效阻抗比传输线低12%左右。但过孔因为阻抗不连续而造成的反射其实是微乎其微的，其反射系数仅为0.06，过孔产生的问题更多的集中在寄生电容和电感的影响。过孔的寄生电容会给电路造成的主要影响是延长了信号的上升时间，降低了电路的速度。</li>
<li>在实际设计中可以通过增大过孔和敷铜区的距离或者减小焊盘的直径来减小寄生电容</li>
<li>在高速数字电路的设计中，过孔的寄生电感带来的危害往往大于寄生电容的影响。它的寄生串联电感会削弱旁路电容的贡献，减弱整个电源系统的滤波效用。</li>
<li>如果要在PCB文件中有几个电源和地线，则需要建立布线类规则来增加电源和地线的宽度</li>
</ol>


<h2>添加泪滴及敷铜</h2>

<ol>
<li>添加泪滴是指在导线与焊盘/过孔的链接处添加一段过渡铜箔，过渡铜箔呈现泪滴状。泪滴的作用是增加焊盘/过孔的机械强度，避免应力集中在导线与焊盘/过孔的连接处，而使连接处断裂或焊盘/过孔脱落。单击Tools->Teardrops</li>
<li>网格状填充区又称敷铜，敷铜就是将电路板中空白的地方铺满铜箔，添加敷铜不仅仅是为了好看，最主要的目的是提高电路板的抗干扰能力，起到屏蔽外界干扰的效果，通常将敷铜接地，这样电路板中空白的地方就铺满了接地的铜箔。</li>
</ol>


<h2>修改PCB的形状大小</h2>

<ol>
<li>在PCB页面用Keep-Out Layer画出所需板子的大小形状，必须是封闭的形状</li>
<li>选中画出的这些封闭的框框</li>
<li>Design->Board Shape->Define from selected objects</li>
</ol>


<h2>PCB Logo制作</h2>

<ol>
<li>DXP->Run Script</li>
<li>选择PCB Logo Creator下的工程文件
<img src="http://i.imgur.com/1NjlZbw.png" alt="PCB Logo Creator脚本工程" /></li>
<li>选择RunConverterScript，点击OK
<img src="http://i.imgur.com/BXtrhYj.png" alt="选择bmp图片开始转换" /></li>
<li>点击Load选择需要使用的bmp位图</li>
<li>选择好丝印层，点击Convert，等待转换结束</li>
</ol>


<h2>硬件构件化电路原理图绘制的规则</h2>

<ol>
<li>硬件构建分类

<ol>
<li>核心构件：只提供接口，没有需求接口，比如芯片的硬件最小系统</li>
<li>中间构件：既有需求接口，又有提供接口，比如232电平转换构件</li>
<li>终端构件：只有需求接口，比如LCD构件</li>
</ol>
</li>
<li>通用规则

<ol>
<li>元器件命名格式

<ol>
<li>核心构件：其元器件直接编号命名，同种类型的元件命名时冠以相同的字母前缀，如R1，R2</li>
<li>中间构件和终端构件：元器件命名格式采用“构件名-标志字符？”，例如LCD构件中所有的电阻名称统一为“LCD-R”</li>
</ol>
</li>
<li>为硬件构件添加详细的文字描述</li>
<li>将前两歩产生的内容封装在一个虚线框内，组成硬件构件的内部实体</li>
<li>为该硬件构件添加与其他构件交互的输入、输出接口标识。接口标识有两种

<ol>
<li>接口注释：位于虚线框内，是为构件接口所作的解释性文字，采用斜体</li>
<li>接口网标：位于虚线框外，具有电气特性</li>
</ol>
</li>
</ol>
</li>
<li>核心构件设计规则

<ol>
<li>核心构件的接口标识均为网标，若同意引脚具有不同功能，则接口网标依据第一功能选项命名</li>
</ol>
</li>
<li>中间构件设计规则

<ol>
<li>描述需求接口采用接口注释，描述提供接口采用接口网标</li>
<li>直观起见，将构件的需求接口放置在构件实体的左侧，提供接口放置在右侧</li>
<li>接口网标的命名规则是：构件名称-引脚信号/功能名称</li>
<li>接口注释名称前的构件名称可有可无</li>
</ol>
</li>
<li>终端构件设计规则

<ol>
<li>接口标识均为斜体标注的接口注释</li>
</ol>
</li>
</ol>


<h2>布线总结</h2>

<ol>
<li>按小键盘的*键或大键盘的数字2键添加一个过孔</li>
<li>按L键可以切换布线层</li>
<li>按数字3可设定最小线宽、典型线宽、最大线宽的值进行切换</li>
<li>差分布线

<ol>
<li>差分网络是两条存在耦合的传输线，一天携带信号，另一条则携带它的互补信号。使用差分对布线前要对设定差分对网络进行设置。设置可以在原理图中设置，也可以在PCB中进行设置</li>
<li>原理图中添加差分对规则:在命名差分对网络时，必须保证网络名的前缀是一样的，后缀中用下划线带一个N和一个P字母即可。命名好之后，点击菜单Place->Directives->DifferentialPair命令，在差分对上放置两个差分图标</li>
</ol>
</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-02-19T15:12:32+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts/2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    suda-morris

Powered by Octopress-WenRis Group
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>