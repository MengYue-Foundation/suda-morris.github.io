
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>WenRis Blog</title>
	<meta name="author" content="suda-morris">

	
	<meta name="description" content="WenRis Blog">
	<meta name="keywords" content="C/C++,Python,Lua">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="WenRis Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">WenRis Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.baidu.com" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:suda-morris.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/Morris1106com" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/suda-morris" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.baidu.com" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:suda-morris.github.io">
	</form>
</nav>

</header>
	
		
	

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/25/html5-introduce/">
		
			HTML5_introduce</a>
	</h2>
	<div class="entry-content">
		

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-25T22:26:10+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/23/project-manager/">
		
			系统集成项目管理</a>
	</h2>
	<div class="entry-content">
		<h2>信息系统集成基础知识</h2>

<ol>
<li>信息系统集成是指将计算机软件、硬件、网络通信等技术和产品集成成为能够满足用户特定需求的信息系统，包括总体策划、设计、开发、实施、服务及保障</li>
<li>信息系统集成的<strong>本质</strong>是实现优化的综合统筹设计</li>
<li>信息系统集成要以满足用户需求为<strong>根本出发点</strong></li>
<li>信息系统集成的核心是<strong>软件</strong></li>
<li>信息系统集成是一项综合性的系统工程，<strong>技术</strong>是系统集成工作的的核心，<strong>管理和商务</strong>活动是系统集成项目成功实施的保障</li>
<li>信息系统集成实现的<strong>关键</strong>在于解决各子系统之间的互联和互操作问题</li>
<li>信息系统集成主要分为<strong>设备系统集成</strong>（即硬件系统集成，或弱电系统集成）和<strong>应用系统集成</strong>（也称行业信息化解决方案集成）两大类。设备系统集成又可分为智能建筑系统集成、计算机网络系统集成和安防系统集成</li>
</ol>


<h2>信息系统集成资质管理</h2>

<ol>
<li>信息系统集成的资质是指从事计算机信息系统集成的综合能力，包括技术水平、管理水平、服务水平、质量保证能力、技术装备、系统建设质量、人员构成与素质、经营业绩、资产状况等要素</li>
<li>凡是从事计算机信息系统集成业务的单位，必须经过资质认证并取得《计算机信息系统集成资质证书》</li>
<li>凡是要建设计算机信息系统的单位，应选择具有相应等级《资质证书》的计算机信息系统集成单位来承建计算机信息系统</li>
<li><strong>工业和信息化</strong>部负责计算机信息系统集成资质认证管理工作</li>
<li>计算机信息系统集成资质等级分一、二、三、四级</li>
<li>资质监督管理是指对获证单位资质保持的<strong>监督检查</strong>和<strong>资质变更</strong>的管理</li>
<li>《资质证书》有效期<strong>3年</strong>，获证单位应每年进行一次<strong>自查</strong>（自查时间是每年2月1日至4月30日），并将自查结果报资质认证工作办公室备案；资质认证工作办公室对获证单位每四年进行一次换证检查。</li>
<li>计算机信息系统集成资质认证工作根据<strong>认证和审批分离</strong>的原则，按照先由认证机构认证，再由信息产业主管部门审批的工作程序进行</li>
<li>获证单位应提前做好换证工作准备，最迟应在《资质证书》有效期满<strong>前3个月</strong>，向相应的资质认证工作办公室提出更换证书申请</li>
<li>获证单位原则上在获证<strong>一年以后</strong>如果达到更高级别的资质评定条件，可以像相应的认证机构提出比原资质更高级的升级认证申请</li>
<li>系统集成一、二级资质证书由<strong>工业和信息化部</strong>审批，三、四级由<strong>地方信息产业主管部门</strong>审批，报工业和信息化部备案</li>
<li>计算机信息系统集成企业资质等级评定条件主要从综合条件、财务状况、信誉、业绩、管理能力、技术实力和人才实力7个方面进行考核</li>
<li>企业资质等级评定条件：

<ol>
<li>特一级资质

<ul>
<li>取得一级资质不少于三年</li>
<li>注册资本和实收资本均不少于2亿元</li>
<li>固定资产中电子设备的净值不少于1000万元，无形资产中软件的账面净值不少于1000万元</li>
<li>近三年系统集成年收入均不少于5亿元</li>
</ul>
</li>
<li>一级资质

<ul>
<li>取得二级资质不少于两年</li>
<li>主业是计算机信息系统集成，近三年的系统集成收入总额占营收入总额的比例不低于70%，且近三年系统集成收入总额不少于5亿元</li>
<li>注册资本和实收资本均不少于5000万元</li>
<li>近三年至少完成4个合同额不少于1500万元的系统集成项目</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于5年</li>
<li>从事软件开发与系统集成相关工作的人员不少于220人，其中大学本科以及以上学历人员所占比例不低于80%；具有计算机信息系统集成项目管理人员资质的人数不少于30名，其中高级项目经理人数不少于10名</li>
</ul>
</li>
<li>二级资质

<ul>
<li>取得三级资质不少于一年</li>
<li>主业是计算机信息系统集成，近三年的系统集成收入总额占营收入总额的比例不低于60%，且近三年系统集成收入总额不少于2.5亿元</li>
<li>注册资本和实收资本均不少于2000万元</li>
<li>近三年至少完成3个合同额不少于1000万元的系统集成项目</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于4年</li>
<li>从事软件开发与系统集成相关工作的人员不少于150人，其中大学本科以及以上学历人员所占比例不低于80%；具有计算机信息系统集成项目管理人员资质的人数不少于18名，其中高级项目经理人数不少于4名</li>
</ul>
</li>
<li>三级资质

<ul>
<li>取得四级资质不少于一年</li>
<li>主业是计算机信息系统集成，近三年的系统集成收入总额占营收入总额的比例不低于50%，且近三年系统集成收入总额不少于5000万元</li>
<li>注册资本和实收资本均不少于200万元</li>
<li>近三年至少完成1个合同额不少于300万元的系统集成项目</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于3年</li>
<li>从事软件开发与系统集成相关工作的人员不少于50人，其中大学本科以及以上学历人员所占比例不低于60%；具有计算机信息系统集成项目管理人员资质的人数不少于6名，其中高级项目经理人数不少于1名</li>
</ul>
</li>
<li>四级资质

<ul>
<li>注册资本和实收资本均不少于30万元</li>
<li>企业的主要负责人从事信息技术领域企业管理的经历不少于2年</li>
<li>从事软件开发与系统集成相关工作的人员不少于15人，其中大学本科以及以上学历人员所占比例不低于60%；具有计算机信息系统集成项目管理人员资质的人数不少于2名</li>
</ul>
</li>
</ol>
</li>
<li><strong>中国软件测评中心</strong>和<strong>广州赛宝认证中心服务有限公司</strong>两家评审机构承担<strong>特一级资质</strong>认定的第三方评审工作</li>
<li>一级资质企业获得特一级资质后其拥有的一级资质任然有效，企业必须按照相关规定参与一级资质的年度监督检查和到期换证等工作</li>
<li>项目经理资质管理

<ol>
<li>系统集成项目经理分为项目经理、高级项目经理和资深项目经理3个级别</li>
<li>项目经理

<ol>
<li>需要获得软考证书（系统集成项目管理工程师或者信息系统项目管理师）</li>
<li>至少有两项合同额在200万元以上的系统集成项目</li>
<li>完成系统集成项目总额500万以上</li>
</ol>
</li>
<li>高级项目经理

<ol>
<li>获得项目经理资质不少于3年</li>
<li>至少有一项合同额在1200万元以上的系统集成项目</li>
<li>完成系统集成项目总额3000万以上</li>
</ol>
</li>
<li>资深项目经理

<ol>
<li>获得高级项目经理资质不少于5年</li>
<li>具有硕士以上学位</li>
<li>至少有两项合同额在3000万元以上的系统集成项目或者至少有四项合同额在1500万元以上的系统集成项目</li>
</ol>
</li>
</ol>
</li>
<li><strong>项目经理</strong>可承担合同额在5000万元以下的系统集成项目，<strong>高级项目经理</strong>可承担合同额在5000万以下的系统集成项目，<strong>资深项目经理</strong>可承担各种规模的系统集成项目</li>
<li>系统集成项目经理资质证书有工业和信息化部统一印制</li>
<li>每<strong>两年</strong>对系统集成项目经理资质进行一次<strong>年审</strong>，年审结论分为<strong>合格</strong>、<strong>不合格</strong>、<strong>不在岗</strong>3种</li>
<li>计算机信息系统集成企业资质的三、四级证书应有工业和信息化部印制，由各省市系统集成企业资质主管部门颁发</li>
<li>企业拥有1个信息技术发明专利可等同于3个软件产品登记</li>
</ol>


<h2>信息化概论</h2>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-23T13:23:26+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/13/wechat-develop/">
		
			微信公众号开发</a>
	</h2>
	<div class="entry-content">
		<h2>微信接口请求返回格式介绍</h2>

<blockquote><p>微信接口是通过GET方式请求的，返回的数据格式是JSON</p></blockquote>

<h2>常用接口功能</h2>

<ol>
<li>access_token获取接口

<ul>
<li>access_token是公众号的全局唯一票据，龚总好调用各接口时都需要使用access_token</li>
<li>存储至少要保留512个字符空间，有效期目前为2个小时，重复获取将导致上次获取的access_token失效</li>
</ul>
</li>
<li>获取微信服务器IP接口</li>
<li>长链接转短链接接口</li>
<li>获取用户列表</li>
<li>获取用户基本信息(UnionID机制)</li>
<li>网页授权接口

<ul>
<li>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息</li>
<li>两种scope模式：

<ol>
<li>snsapi_base时只能获取到openid</li>
<li>snsapi_userinfo时可获取到其他信息</li>
</ol>
</li>
</ul>
</li>
<li>素材管理接口</li>
<li>高级群发接口

<ul>
<li>两个优点

<ol>
<li>可根据openid群发</li>
<li>群发图文内容支持html</li>
</ol>
</li>
</ul>
</li>
<li>JSSDK接口</li>
<li>模板消息接口</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-13T21:31:02+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/wechat/'>wechat</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/02/wordpress/">
		
			Wordpress</a>
	</h2>
	<div class="entry-content">
		

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-02T10:53:44+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/20/basic-analog-knowledge/">
		
			Basic-Analog-Knowledge</a>
	</h2>
	<div class="entry-content">
		<h2>磁珠</h2>

<ol>
<li>全称：铁氧体磁珠滤波器。是一种抗干扰元件，滤除高频噪声效果显著</li>
<li>磁珠有很高的电阻率和磁导率，等效于电阻和电感串联，但电阻值和电感值都随频率变化</li>
<li>磁珠的单位是欧姆，不是亨特，120R~600R之间都很常用</li>
<li>主要特性参数：

<ol>
<li>直流电阻(DCR):直流电流通过此磁珠时，此磁珠所呈现的电阻值</li>
<li>额定电流(mA)</li>
<li>阻抗[z]@100MHz(ohm):这里指的是交流阻抗</li>
<li>阻抗频率特性</li>
<li>电阻频率特性</li>
<li>感抗频率特性</li>
</ol>
</li>
<li>用途：

<ol>
<li>抑制信号线、电源线上的高频干扰和尖峰脉冲。它也具有吸收景点放点脉冲干扰的能力</li>
<li>电感是储能元件，而磁珠时能量转换器件。电感多用于电源滤波回路，侧重于抑制传导性干扰；磁珠多用于信号回路，主要用于EMI(电磁兼容)方面。磁珠用来吸收超高频信号，例如在一些RF电路、PLL、振荡电路、含超高频存储器电路等，都需要在电源输入部分加磁珠</li>
</ol>
</li>
</ol>


<h2>TVS二极管</h2>

<ol>
<li>TVS二极管和常见的文雅二极管工作原理相似，如果高于标志上的击穿电压，TVS二极管就会导通，与稳压二极管相比，TVS二极管具有更高的电流导通能力。TVS二极管的两极收到反向瞬态高能冲击时，以10e-12秒的量级的速度，将其两极间的高阻抗变为低阻抗，同时吸收高达数千瓦的浪涌功率，使得两极之间的电压钳位于一个安全值，有效地保护电子线路中的精密元器件免受浪涌脉冲的破坏</li>
<li></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-08-20T12:22:41+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/analog/'>analog</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/17/w5500-introduce/">
		
			W5500-Introduce</a>
	</h2>
	<div class="entry-content">
		<h2>W5500网络模块简介</h2>

<ol>
<li>公司：Wiznet</li>
<li>使用硬件逻辑门电路实现TCP/IP协议栈的传输层及网络层（如：TCP，UDP，ICMP，IPv4，ARP，IGMP，PPPoE等协议），并集成了数据链路层，物理层(10BaseT/100BaseTX)，以及32K字节片上RAM作为数据收发缓存，使得上位机主控芯片只需承担TCP/IP应用层控制信息的处理任务，大大节省了上位机对于数据复制、协议处理和中断处理等方面的工作量，提升了系统利用率及可靠性</li>
<li>操作过程中，用户可以近似将W5500作为MCU的一个外设RAM来使用，非常简易。W5500对外接口通常为通用的80MHz高速SPI</li>
<li>W5500支持同时的8个socket，方便和不同的IP和设备进行通讯；为了减小系统能耗，W5500提供了网络环形模式(WOL)以及掉电模式供客户选择使用；W5500是非可攻击性的硬件网络引擎，可以防止类似于洪流，诈骗式以及注入式网络攻击，提高了网络安全</li>
<li>支自动协商(10/100-Based全双工/半双工)</li>
<li>3.3V工作电压，I/O信号口5V耐压</li>
<li>W5500 不支持Auto-MDI-X，也就是不支持交叉直连自动切换，对于某些比较老的设备，可能需要特定的交叉线或者直连线。比如模块连模块，需要使用交叉线，模块连路由器或者交换机需要使用直连线。</li>
<li>W5500不支持自动极性变换功能，因此用户需要使用直连线与交换机或者路由器连接，使用交叉线与终端设备(如服务器，工作站或者其他W5500)相连接。然而用户可以使用任何一种类型的网线与具有自动极性变换的其他设备相连。</li>
<li>W5500以太网芯片的内核由传输层的TCP、UDP、ICMP、IGMP等协议、网络层的IP、ARP、PPPoE等协议以及链路层的MAC构成，再加上物理层的PHY和外围的寄存器、内存、SPI接口组成了这一整套硬件化的以太网解决方案</li>
<li>SPI时钟设定值速率为80MHz，但是高速信号在受电磁串扰和长信号线的影响下可能会失真，实测具有稳定波形的始终速率为33.3MHz</li>
</ol>


<h2>W5500初始化主要使用的几个文件：</h2>

<ol>
<li>W5500_conf.c->主要配置W5500的MAC、IP地址，W5500基本的数据读写过程，复位设置函数等</li>
<li>Socket.c->主要介绍了W5500的SOCKET相关配置函数，比如SOCKET的打开、关闭以及接收数据、发送数据等等</li>
<li>Utility.c->主要介绍了基本的延时函数，还有数据格式转化函数</li>
<li>w5500.c->主要介绍W5500的寄存器读写过程</li>
</ol>


<h2>W5500的Socket初始化</h2>

<ol>
<li>W5500的操作需要设置一下寄存器的参数：

<ol>
<li>模式寄存器(MR)</li>
<li>中断屏蔽寄存器(IMR)</li>
<li>重发时间寄存器(RTR)</li>
<li>重发计数寄存器(RCR)</li>
</ol>
</li>
<li>设置网络信息，下面的寄存器是关于网络的基本设置，需要根据网络环境来进行设置

<ol>
<li>网关地址寄存器(GAR)</li>
<li>本机物理地址寄存器(SHAR)</li>
<li>子网掩码寄存器(SUBR)</li>
<li>本机IP地址寄存器(SIPR)</li>
</ol>
</li>
<li>设置端口存储信息，这一步设置端口TX/RX存储信息，每个端口的基地址和屏蔽地址在这里确定并保存。

<ol>
<li>W5500有一个通用寄存器，8个Socket寄存器区，以及对应每个Socket的收发缓存区。每一个Socket的发送缓存区都在一个16KB的物理接收内存中，初始化分配为2KB。无论给每个Socket分配多达的收发缓存，都必须在16为的偏移地址范围内(0x0000~0xFFFF).16KB的发送内存初始化被分配为每个SOcket 2KB发送缓存区(2KB*8=16KB)。</li>
<li>初始化分配的2KB Socket发送缓存，可以通过使用Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)重新分配，一旦所有的Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)配置完成，16KB的发送内存就会按照配置分配给每个Socket的发送缓存，并按照从Socket0到7顺序分配。16KB物理内存的地址是可以自增的，但是为了避免数据传输错误，需要避免发送缓存大小寄存器(Sn_TXBUF_SIZE)的和超过16</li>
<li>16KB的发送内存中分配了对应Socket n的发送缓存区，用于为来自主机传输的数据做缓存。Socket n发送缓存区的16位偏移地址支持64KB的寻址范围(从0x0000到0xFFFF)</li>
</ol>
</li>
</ol>


<h2>SPI工作协议</h2>

<ol>
<li>SPI协议定义了四种工作模式(模式0，1，2，3)。每种模式的区别是根据SCLK的极性及相位不同定义的。SPI的模式0和模式3唯一不同的就是在非活动状态下，SCLK信号的极性，SPI模式0在时钟空闲状态时钟极性为低电平。SPI的模式0和3，数据都是在SCLK的上升沿锁存，在下降沿输出。W5500支持SPI模式0以及模式3，MISO和MOSI信号无论是接收或者发送，均遵从从最高标志位(MSB)到最低标志位(LSB)的传输序列。</li>
<li>W5500与外设主机的通讯受SPI数据帧控制，W5500的帧分为3段：地址段，控制段，数据段</li>
<li>地址段为W5500寄存器或者TX/RX内存指定的16位的偏移地址。</li>
<li>控制段指定了地址段设定的偏移区域的归属，读写访问模式以及SPI工作模式(可变长度模式/固定长度模式)</li>
<li>数据段可以设定为任意长度(N字节)或者是固定长度：1字节，2字节或4字节；如果SPI工作模式设置为可变数据长度模式(VDM),SPI的SCSn信号需要由外部主机通过SPI帧控制。</li>
<li>在可变长度模式下，SCSn控制SPI帧的开始和停止：

<ol>
<li>SCSn信号拉低，即代表W5500的SPI帧开始(地址段)</li>
<li>SCSn信号拉低，即代表W5500的SPI帧结束(数据段的随机N字节数据结尾)</li>
</ol>
</li>
<li>W5500的SPI数据帧包括了16为地址段的偏移地址，8为控制段和N字节数据段。8为控制段可以通过修改区域选择位(BSB[4:0]),读写访问模式位(RWB)以及SPI工作模式位(OM[1:0])来重新定义。区域选择位选择了归属于偏移地址的区域</li>
<li>W5500支持数据的连续读写。其流程为数据从(2/4/N字节连续数据的)偏移地址的基址开始传输，偏移地址会自增寻址(加1)传输接下来的数据</li>
<li>SPI数据帧控制段对应位的说明：

<ol>
<li>区域选择位BSB[4:0]-> 【00000】= 通用寄存器；【00001】= Socket0寄存器；【00010】=Socket0发送缓存；【00011】=Socket0接收缓存；【00101】=Socket1寄存器；【00110】=Socket1发送缓存；【00111】=Socket1接收缓存；【01001】= Socket2寄存器；【01010】=Socket2发送缓存；【01011】=Socket2接收缓存；【10101】=Socket3寄存器；【01110】=Socket3发送缓存；【01111】=Socket3接收缓存；【10001】= Socket4寄存器；【10010】=Socket4发送缓存；【10011】=Socket4接收缓存；【10101】=Socket5寄存器；【10110】=Socket5发送缓存；【10111】=Socket5接收缓存；【11001】= Socket6寄存器；【11010】=Socket6发送缓存；【11011】=Socket6接收缓存；【11101】=Socket7寄存器；【11110】=Socket7发送缓存；【11111】=Socket7接收缓存；</li>
<li>读写访问模式位RWB-> 【0】=读；【1】=写</li>
<li>工作模式位OM[1:0]-> 【00】=可变数据长度模式，N字节数据段(1≤N)；【01】=固定数据长度模式，1字节数据长度(N=1)；【10】=固定数据长度模式，2字节数据长度(N=2)；【11】=固定数据长度模式，4字节数据长度(N=4)；</li>
</ol>
</li>
<li>W5500有一个通用寄存器，8个Socket寄存器，以及对应每个Socket的收发缓存区。每个区域均通过SPI数据帧的区域选择位BSB[4:0]来选取。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212635.png" alt="SPI模式0/3" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212850.png" alt="SPI数据帧" /></li>
</ol>


<h2>物理层</h2>

<blockquote><p>由计算机和网络介质之间的实际界面组成，可定义电器信号、符号、线的状态和时钟要求、数据编码和数据传输用的连接器。如最常用的RS-232规范、10BASE-T的曼彻斯特编码以及RJ-45就属于这一层。</p></blockquote>

<h2>数据链路层</h2>

<blockquote><ol>
<li>数据链路层通过物理网络链路提供可靠的数据传输。不同的数据链路层定义了不同的网络和协议特征，其中包括物理编址、网络拓扑结构、错误校验、帧序列以及流控</li>
<li>以太网协议规定，一组电信号构成一个数据包，叫做“帧”，每一帧分成三个部分：以太网首部、数据及以太网尾部。</li>
<li>以太网首部包含数据帧的一些说明，比如发送者、接收者、数据类型等等；数据部分则是数据的具体内容；以太网尾部则是CRC校验码</li>
<li>以太网首部的长度固定为14字节。数据的长度最短为46字节，最长为1500字节。以太网尾部的长度固定为4字节。因此，整个数据帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送</li>
<li>数据链路层实际上由两个独立的部分组成：介质存取控制(MAC)和逻辑链路控制(LLC)。MAC描述在共享介质环境中如何进行站的调度、发生和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据流向。一般来讲，MAC只在共享介质环境中才是重要的，只有在共享介质环境中多个节点才能连接到同一传输介质上。</li>
<li>一块网卡如何知道另一块网卡的MAC地址?ARP协议(网络层)可以解决这个问题。以太网数据帧必须知道接收方的MAC地址然后才能发送。有了数据帧的定义，网卡的MAC地址，广播的发送方式，数据链路层就可以在多台计算机之间传送数据了</li>
</ol>
</blockquote>

<h2>网络层</h2>

<blockquote><ol>
<li>网络层负责在源和终点之间建立连接。它一般包括网络寻址，还可能包括流量控制、错误检查等。相同MAC标准的不同网段之间的数据传输一般只涉及到数据链路层，而不同的MAC标准之间的数据传输都涉及到网络层。IP路由器工作在网络层，因为可以实现多种网络间的互联。</li>
<li>IP数据包分为“标头”和“数据”两个部分。标头部分主要包括版本、长度、IP地址等细心，数据部分则是IP数据报的具体内容。IP数据报的标头部分长度为20到60字节，整个数据报的总长度最大为65535字节，因此理论上，一个数据报的数据部分最长为65515字节。以太网数据帧的数据部分最长只有1500字节，因此如果IP数据报超过了1500字节，它就要分割成几个以太网数据帧分开发送了。</li>
</ol>
</blockquote>

<h2>传输层</h2>

<blockquote><ol>
<li>传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能一般包括流控、多路传输、虚电路管路以及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接受设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到物理链路上；虚电路由传输层建立、维护和终止；差错校验包括为检测传输错误而建立的各种不同结构；而差错回复包括所采取的行动，以便解决发生的任何错误。</li>
<li>必须要在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，UDP数据段也是有“标头”和“数据”两部分组成</li>
<li>标头部分主要定义了发出端口和接收端口，“数据”部分就是具体的内容，然后把整个UDP数据段放入IP数据报的“数据”部分，而IP数据报又是放在以太网数据帧之中的。</li>
<li>UDP数据段非常简单，标头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据报</li>
<li>为了提高网络可靠性，诞生了TCP协议，这个协议非常复杂，但可以近似认为，他就是有确认机制的UDP协议，没发出一个数据都要求确认。如果有一个数据缺失，就收不到确认，发送方就知道有必要重发这个数据了</li>
<li>TCP数据段没有长度限制，理论上可以无限长，但是为了保证网络的效率。通常TCP数据段的长度不会超过IP数据报的长度，以确保单个TCP数据段不必再分割。</li>
</ol>
</blockquote>

<h2>应用层</h2>

<blockquote><p>应用层是最接近终端用户的第一层，这就意味着应用层与用户之间是通过应用软件直接相互作用。应用层并非由计算机上云sing的实际应用软件组成，而是由向应用程序提供访问网络资源的API组成。</p></blockquote>

<h2>寄存器</h2>

<h3>W5500通用寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823140450.png" alt="W5500通用寄存器" /></p>

<h3>Socket寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823141841.png" alt="Socket寄存器" /></p>

<ol>
<li>通用寄存器区配置了W5500的基本信息，如IP以及MAC地址</li>
<li>W5500支持8个Socket作为通讯信道，每一个Socket通过Socket n寄存器控制。Socket n寄存器可以通过SPI数据帧中的区域选择寄存器BSB[4:0]来选定对应的寄存器n。</li>
</ol>


<h2>TCP/IP协议族</h2>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgW5500%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95%E6%9D%BF%E6%95%99%E7%A8%8B.png" alt="TCP/IP协议族" /></p>

<h2>TCP协议</h2>

<ol>
<li>TCP协议通过三个报文段完成连接的建立，这个过程称为三次握手。TCP连接建立过程：

<ol>
<li>第一次握手：建立连接时，客户端发送SYN包(seq=j)到服务器，并进入SYN_SEND状态，等待服务器确认</li>
<li>第二次握手：服务器收到SYN包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(seq=k),即SYN+ACK包，此时服务器进入SYN_RECV状态</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISH状态，完成三次握手</li>
</ol>
</li>
<li>终止一个TCP连接需要四次挥手，这是由TCP的半关闭(half-close)造成的

<ol>
<li>第一次挥手：主动方发出设置了FIN位的报文，表示主动终止从本地到远端的单向链接；此时主动方进入FIN_WAIT1状态，意思是它在等待远端的FIN报文</li>
<li>第二次挥手：远端收到FIN后，会立即发送ACK；主动方收到ACK后，进入FIN_WAIT2状态，所以FIN_WAIT1状态持续的时间非常短；此时远端进入CLOSE-WAIT状态，一条单向链接终止了，但另一条还没有，处于HALF-CLOSE连接状态</li>
<li>第三次挥手：当远端进行了必要的数据发送后，它发送FIN，表示它出发的单向连接也要关闭，同时它进入LAST_ACK状态</li>
<li>第四次挥手：主动方收到FIN后，回应一个ACK；远端就此进入CLOSED状态，连接关闭；主动方进入TIME WAIT状态，确保最后一个ACK没有丢失，防止新连接占用刚刚关闭的主动方的地址端口，使得网络中流浪的老连接的返祖被误认为新连接的分组</li>
</ol>
</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手/四次挥手" /></li>
<li>当W5500初始化完成后，程序进入主循环，此时读取Socket的状态值，并选择进入哪种模式。当Socket处于关闭状态时，在进行通信之前，我们先将该Socket初始化，这个Socket作为服务器端，端口号要固定为侦听的端口。当socket将处于初始化完成状态，即SOCK_INIT状态，此时，作为TCP服务器就要执行listen()函数来侦听端口。由于W5500内嵌了TCP/IP协议，连接过程是不需要单片机干预的。如果连接过程中出错造成超时，该Socket将会被关闭，重新进入SOCK_CLOSE状态。待TCP连接的3次握手完成后，socket的状态将会转变为连接建立状态，即代码中定义的SOCK_ESTABLISHED状态。在进入SOCK_ESTABLISHED状态后，便可进行数据收发。数据通信完毕之后执行disconnect()函数，在收到对方FIN数据包之前，该socket将进入SOCK_CLOSE_WAIT状态。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPServer%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPServer流程图" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPClient%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPClient流程图" /></li>
</ol>


<h2>UDP协议</h2>

<ol>
<li><img src="http://i.imgur.com/ceIUeSz.png" alt="UDP通信流程图" /></li>
<li>当socket处于关闭状态时，在进行通信之前我们先将该UDP模式的socket端口初始化。当socket将处于初始化完成状态即SOCK_UDP状态，此时就可以通过广播方式发送数据了。</li>
<li><img src="http://i.imgur.com/FxqWkWp.png" alt="UDP报文" /></li>
</ol>


<h2>DHCP协议</h2>

<ol>
<li>W5500作为DHCP客户端，路由器作为DHCP服务器端，在DHCP请求的过程中，包括4个主要阶段：发现阶段、提供阶段、选择阶段以及确认阶段</li>
<li>首次W5500客户端发送DHCPDISCOVER消息(IP地址租用申请)，这个消息通过广播方式发出，所有网络中的DHCP服务器都将接收到这个消息。随后，网络中的DHCP服务器会回应一个DHCPOFFER消息(IP地址租用提供)，由于这个时候客户端还没有网络地址，所以DHCPOFFER也是通过广播的方式发送出去的。然后，向该服务器发送DHCPREQUEST消息。在DHCPREQUEST消息中将包含客户端申请的IP地址。最后，DHCP服务器将会送DHCPACK的相应消息来通知客户端可以使用该IP地址，该确认里面包含了分配的IP地址和该地址的一个稳定期限的租约(默认是8天)，并同时更新DHCP数据库</li>
<li>DHCP初始化完成以后，通过获取DHCP_SOCKET的状态来获取动态IP地址。第一个状态DHCP_RET_NONE就是获取不成功，第二个状态DHCP_RET_TIMEOUT是获取IP地址超时，都不符合条件。第三个状态DHCP_RET_UPDATE就是获取动态IP地址成功，此时将得到的IP地址通过SPI写入W5500的寄存器。如果是DHCP_RET_CONFLICT冲突状态，就要返回DHCP服务重新获取</li>
<li><img src="http://i.imgur.com/sqc1tce.jpg" alt="DHCP报文格式" /></li>
<li>报文格式解析：

<ol>
<li>OP：若是client送给server的封包，设为1，反之为2</li>
<li>HTYPE：硬件类别，10MB以太网为1，100MB以太网为2</li>
<li>HLEN：硬件地址长度，Ethernet为6</li>
<li>HOPS：若封包需要经过router传送，每站加1，若在同一网段内，为0</li>
<li>TRANSACTION ID：DHCP REQUEST时产生的数值，以作为DHCPREPLY时的依据</li>
<li>SECONDS：Client端启动时间(秒)</li>
<li>FLAGS：从0到15共16bits，最左1bit为1时表示server将以广播方式传送封包给client，其余尚未使用</li>
<li>ciaddr：yhaoshiclient端想继续使用之前取得的IP地址，则列于这里</li>
<li>yiaddr：从server送回client的DHCP OFFER与DHCPACK封包中，此栏填写分配给client的IP地址</li>
<li>siaddr：若client需要透过网络开机，从server送出的DHCP OFFER、DHCPACK、DHCPNACK封包中，此栏填写开机程序代码所在server的地址</li>
<li>giaddr：若需跨网域进行DHCP发放，此栏为relay agent的地址，否则为0</li>
<li>chaddr：client的硬件地址</li>
<li>sname：sever的名称字符串，以0x00结尾</li>
<li>file：若client需要透过网络开机，此栏将指出开机程序名称，稍后以TFTP传送</li>
<li>options：允许厂商定义选项，提供更多的设定信息，其长度可变，同时可携带多个选项，每一个选项的第一个字节为信息代码，其后一个自己为该项数据长度，最后为项目内容</li>
</ol>
</li>
</ol>


<h2>DNS协议</h2>

<ol>
<li>客户端初始化完毕之后，如果DNS运行标志位是1或者DNS发送次数超过3次就直接返回。如果不是上面的情况，并且DNS Server的IP不是0.0.0.0时，进入switch函数。当处于DNS域名解析成功状态时，DNS_OK置1，发送请求报文次数置0。当DNS解析域名失败时，标志位置0，请求报文次数加1，然后跳出循环。</li>
<li>DNS报文格式：<img src="http://i.imgur.com/C48NfJR.jpg" alt="DNS报文格式" />

<ul>
<li>标识：DNS报文的ID，对于相关联的请求报文和应答报文，这个字段是相同的</li>
<li>标志：<img src="http://i.imgur.com/ZaPageY.jpg" alt="标志字段" />

<ul>
<li>QR：查询/响应的标志位，1为响应，0为查询</li>
<li>opcode：定义查询或响应的类型(若为0则表示是标准的，若为1则是反向的，若为2则是服务器状态请求)</li>
<li>AA：授权回答的标志位，该位在相应报文中有效，1表示名字服务器是权限服务器</li>
<li>TC：截断标志位，1表示响应以超过512字节并已经被截断</li>
<li>RD：只能在响应报文中置1，表示可以得到递归响应</li>
<li>zero：0，保留字段</li>
<li>rcode：返回码，表示响应的差错状态，0表示无差错，1表示格式差错，2表示问题在域名服务器上，3表示域参照问题，4表示查询类型不支持，5表示在管理上被禁止</li>
</ul>
</li>
<li>问题数、资源记录数、授权资源记录数和额外资源记录数，这四个字段都是两字节，分别对应下面的查询问题、回答、授权和额外信息部分的数量。一般问题数都为1，DNS查询报文中，资源记录数、授权资源记录数和额外资源记录数都为0.</li>
<li>查询问题部分的格式：<img src="http://i.imgur.com/qkVuppN.gif" alt="查询问题格式" />

<ul>
<li>查询名部分长度不定，一般为要查询的域名，有时候也有IP的时候，即反向查询。此部分由一个或者多个标识符序列组成，每个标识符以首字节数的计数值来说明该标识符长度，每个名字以0结束。技术字节数必须在0~63之间</li>
<li>查询类型：

<ul>
<li>1：IPv4地址</li>
<li>2：名字服务器</li>
<li>5：规范名称</li>
<li>6：开始授权，标记一个区的开始</li>
<li>11：熟知服务，定义主机提供的网络服务</li>
<li>12：指针，把IP地址转化为域名</li>
<li>13：主机信息，给出主机使用的硬件和操作系统的表述</li>
<li>15：邮件交换，把邮件改变路由送到邮件服务器</li>
<li>28：IPv6地址</li>
<li>252：传送整个区的请求</li>
<li>255：对所有记录的请求</li>
</ul>
</li>
<li>查询类：通常为1，指Internet数据</li>
</ul>
</li>
<li>回答字段，授权字段和附加信息字段均采用资源记录的相同格式：<img src="http://i.imgur.com/WuZQrVt.gif" alt="资源记录格式" />

<ul>
<li>域名字段(不定长或者2字节)：记录资源数据对应的名字，它的格式和查询名字段格式相同。当报文中域名重复出现时，就需要使用2字节的偏移指针来替换。</li>
<li>类型、类：含义与查询问题部分的类型和类相同</li>
<li>生存时间：该字段表示资源记录的生命周期，一般用于当地址解析程序取出资源记录后决定保存以及使用缓存数据的时间</li>
<li>资源数据长度：表示资源数据的长度，以字节为单位，如果资源数据为IP则为0004</li>
<li>资源数据：该字段是可变长字段，表示按查询段要求返回的相关资源记录的数据</li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>SMTP协议</h2>

<ol>
<li><img src="http://i.imgur.com/9TsOlUJ.png" alt="邮件发送过程示意图" /></li>
<li>SMTP在TCP协议25号端口监听连续请求。SMTP连接和发送过程：

<ol>
<li>建立TCP连接</li>
<li>客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端正希望以OK作为相应，表明准备接收</li>
<li>客户端发送RCPT命令，以表示该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件</li>
<li>协商结束，发送邮件，用命令DATA发送</li>
<li>以“.”号表示结束并将内容一起发出去，结束此次发送，用QUIT命令退出</li>
</ol>
</li>
</ol>


<h2>ICMP协议</h2>

<ol>
<li>ICMP是Internet控制报文协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令，这个ping的过程实际上就是ICMP协议工作的过程。Ping命令利用ICMP回射请求报文和回射应答报文来测试目标系统是否可达。</li>
<li>执行ping后，首先向目标服务器发出回送请求报文。计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求。这个ICMP回送回答报文在IP层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP地址字段被交换了，类型字段里填入了表示回送回答的0，这两点，也就是，从送信方式来看，自己送出的ICMP报文从目标服务器哪里像鹦鹉学舌那样原样返回了</li>
</ol>


<h2>Http协议</h2>

<ol>
<li>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。</li>
<li>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</li>
<li>请求报文格式如下：请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体</li>
<li>应答报文格式如下：状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</li>
<li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF</li>
<li>请求方法有多种：

<ol>
<li>GET 请求获取Request-URI所标识的资源</li>
<li>POST 在Request-URI所标识的资源后附加新的数据</li>
</ol>
</li>
<li>状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF 其中Status-Code标识服务器发回的响应状态代码；Reason-Phrase标识状态代码的文本描述</li>
<li>状态码有三位数字组成，第一个数字定义了响应的类别，且有5种可能取值：

<ol>
<li>1xx：指示信息，标识请求已接收，继续处理</li>
<li>2xx：成功，标识请求已被成功接收、理解、接受</li>
<li>3xx：重定向，要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误，请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误，服务器位能实现合法的请求</li>
</ol>
</li>
<li>常见状态码、状态描述、说明

<ol>
<li>200 OK 客户端请求成功</li>
<li>400 Bad Request 客户端请求有语法错误，不能被服务器理解</li>
<li>401 Unauthorized 请求未经授权，这个状态码必须和WW-Authenticate报文域一起使用</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found 请求资源不存在</li>
<li>500 Internal Server Error 服务器发生不可预期的错误</li>
<li>503 Server Unavaliable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ol>
</li>
<li>普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。

<ol>
<li>Cache-Control用于指定缓存指令，缓存指令是单向的，而且是独立的。

<ul>
<li>请求时的缓存指令包括：no-cache(用于指示请求或响应消息不能缓存)、no-store、max-age、max-stale、min-fresh、only-if-cached</li>
<li>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage</li>
</ul>
</li>
<li>Date普通报头域表示消息产生的日期和时间</li>
<li>Connection普通报头域允许发送指定连接的选项，例如指定连接是连续或者指定“close”选项，通知服务器，在响应完成后，关闭连接。在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</li>
</ol>
</li>
<li>请求报头允许客户端向服务器传递请求的附加信息以及客户端自身的信息，常用的请求报头：

<ol>
<li>Accept：用于指定客户端接收哪些类型的信息，Accept:image/gif表明客户端希望接收GIF图像格式的资源；Accept:text/html表明客户端希望接收html文本</li>
<li>Accept-Charset：用于指定客户端接受的字符集，如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受</li>
<li>Accept-Encoding：指定可接受的内容编码</li>
<li>Accept-Language：指定一种自然语言</li>
<li>Authorization：用于证明客户端有权查看某个资源，当浏览器访问一个页面时，如果收到服务器的响应代码为401，可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证</li>
<li>Host:发送请求是，该报头域是必须的，主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回</li>
<li>User-Agent：该请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器，不过，这个报头域不是必须的，如果我们自己编写一个浏览器，不适用User-Agent请求报头域，那么服务器端就无法得知我们的信息了</li>
</ol>
</li>
<li>请求报头举例：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>GET /form.html HTTP/1.1 (CRLF)
</span><span class='line'>Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)
</span><span class='line'>Accept-Language:zh-cn (CRLF)
</span><span class='line'>Accept-Encoding:gzip,deflate (CRLF)
</span><span class='line'>If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)
</span><span class='line'>If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)
</span><span class='line'>User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)
</span><span class='line'>Host:www.guet.edu.cn (CRLF)
</span><span class='line'>Connection:Keep-Alive (CRLF)
</span><span class='line'>(CRLF)
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>响应报头允许服务器传递不能放在状态行中的附件响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息；常用的响应报头：

<ol>
<li>Location用于重定向接收者到一个新的位置，Location响应报头域常用在更换域名的时候</li>
<li>Server包含了服务器用来处理请求的软件信息，与User-Agent请求报头域是相对应的</li>
<li>WWW-Authenticate响应报头域西粗被包含在401响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时候，服务端响应报头就包含该报头域</li>
</ol>
</li>
<li>实体报头。请求和响应消息都可以传送一个实体，一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。常用的实体报头：

<ol>
<li>Content-Encoding：被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip</li>
<li>Content-Language：实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:da</li>
<li>Content-Length：实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示</li>
<li>Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型</li>
<li>Last-Modified：实体报头域用于指示资源的最后修改日期和时间</li>
<li>Expires：实体报头域给出响应过期的日期和时间。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0</li>
</ol>
</li>
<li>HTTP协议通常是承载于TCP洗衣之上的，有时也承载于TLS或SSL协议层之上，这时称之为HTTPS协议。默认HTTP的端口号为80，HTTPS的端口号为443</li>
<li><img src="http://i.imgur.com/PiBPPM0.png" alt="HTTP请求报文" /></li>
<li><img src="http://i.imgur.com/EZ63EEL.png" alt="HTTP响应报文" /></li>
<li>GET与POST方法有以下区别：

<ol>
<li>Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</li>
<li>在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交</li>
<li>GET方式提交的数据最多只能有1024字节，而POST则没有此限制</li>
</ol>
</li>
<li></li>
</ol>


<h2>NetBIOS</h2>

<p><img src="http://i.imgur.com/OAHwfCG.png" alt="NetBIOS实现过程" /></p>

<ol>
<li>NetBIOS协议是一种在局域网上的程序可以使用的应用程序编程接口，为v横须提供了请求低级服务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能，几乎所有的局域网都是在NetBIOS协议的基础上工作的。NetBIOS协议，简单来说就是通过访问设备名称就可以实现对IP地址的访问。</li>
<li>在Windows操作系统中，默认情况下在安装TCP/IP协议后会自动安装NetBIOS协议。</li>
<li>ping主机名的第一个数据包就是NBNS(NetBIOS Name Server)协议包，它是TCP/IP上的NetBIOS协议族的一部分，它在基于NetBIOS名称访问的网络上提供主机名和地址映射方法。NBNS是动态DNS的一种。Microsoft的NBNS实现称为WINS。NetBIOS的报文类型较多，结构复杂，在不同的网络化境和不同的用途中会使用不同的报文，可用端口进行区分。如图所示NetBIOS协议架构
<img src="http://i.imgur.com/MxZkqby.jpg" alt="NetBIOS协议架构" /></li>
<li>NetBIOS数据报有很多不同格式，主要取决于服务和信息类型，以及用以传送NetBIOS数据报的传输协议。NetBIOS协议架构包含三种基本服务：NAME、SESSION和DATAGRAM，其中NAME所用协议就是NBNS协议</li>
<li>WINS协议使用的报文即为NetBIOS的名字报文，其总体格式如下图所示
<img src="http://i.imgur.com/i2pWvfO.png" alt="NetBIOS名字报文格式" />其中2字节通用标志中更详细的字段划分为：操作代码(5bits)操作标志(7bits)结果代码(4bits)

<ol>
<li>事物ID：请求方为每次名字服务请求所设定的ID值，响应方在相应的响应报文中要填入这个事物ID值</li>
<li>操作代码：指示报文的类型,最高位为0表示数据包为Reauest请求，最高位为1表示数据包为Response应答，其余4个比特均为0</li>
<li>操作标志：操作标志位，最低位为1表示广播或者多播，最低位为0表示单播，其他位均为0</li>
<li>结果代码：在相应报文中指示请求的结果，一般为0</li>
<li>问题记录个数：请求查询问题的个数，对于Request数据包，该值为1，对于Response数据包，该值为0</li>
<li>回答记录个数：对于Response数据包有用，Response数据包中响应问题的个数，一般为1</li>
<li>权威记录个数：在权威记录部分的记录数量，用不到的时候为0</li>
<li>附加记录个数：在附加记录部分数量，用不到的时候为0</li>
</ol>
</li>
<li>报文的前12字节总称NetBIOS名字报文的首部，通过首部可以判断是否为名字查询的报文。NetBIOS名字报文中最常见的是携带问题记录的报文，问题记录的格式是：问题名称(若干字节) 问题类型(2字节) 问题类别(2字节)。通过携带问题记录的报文，我们可以得到要查询的名字字符，如果和本机名相符，就发送报文响应，相应中带有IP地址，发送广播的主机就会得到该IP地址</li>
<li>NETBIOS会话报文具有通用的4字节首部和与类型相关的报文内容：类型(1字节) 标志(1字节) 长度(2字节) 内容(若干字节)

<ol>
<li>类型：指名NetBIOS会话报文的类型，可用的值有：

<ul>
<li>0x00:会话消息</li>
<li>0x81:会话请求</li>
<li>0x82:正面会话响应</li>
<li>0x83:负面会话响应</li>
<li>0x84:重定向会话响应</li>
<li>0x85:会话保活</li>
</ul>
</li>
<li>标志：0~6位保留未用，第7位作为扩展的长度位，使NetBIOS会话报文的内容部分最多可以达到128K字节</li>
<li>长度：NetBIOS会话报文的内容部分的长度，不包括首部的4字节</li>
</ol>
</li>
<li><img src="http://i.imgur.com/O24egoi.png" alt="NBNS" />计算机1向计算机2的137端口发送一个NODE STATUS REQUEST请求数据包，计算机2收到该数据包后，向计算机1返回一个NODE STATUS RESPONSE响应数据包，该数据包中包含计算机2的MAC地址、机器地址、所属的工作组等信息</li>
<li>NODE STATUS REQUEST数据包由12字节的HEADER域和38字节的QUESTION ENTRIES域两个部分组成，HEADER域分为8个字段：
<img src="http://i.imgur.com/VKpTVaA.png" alt="NetBIOS HEADER" /></li>
<li>QUESTION ENTRIES域组成
<img src="http://i.imgur.com/93RGC0D.png" alt="QUESTION ENTRIES" />其中：

<ul>
<li>QUESTION_NAME为要查询的远程计算机的名称，长度为34字节。NBNS规定，计算机NetBIOS的名称不超过16字节，且最后一个字节必须为0x0；</li>
<li>QUESTION_TYPE对于REQUEST数据包取值为0x0021</li>
<li>QUESTION_CLASS取值为0x0001</li>
</ul>
</li>
<li>当某台机器的137端口收到NODE STATUS REQUEST请求数据包之后，由该机器的NETBIOS服务随即生成并返回一个NODE STATUS RESPONSE响应数据包。该响应数据包由HEADER域和RESOURCE RECORD域两部分组成。RESOURCE RECORD域组成如图所示：
<img src="http://i.imgur.com/IPEjagx.png" alt="RESOURCE RECORD" />

<ul>
<li>RP_NAME：34字节，与Request数据包的QUESTION_NAME格式定义相同</li>
<li>RP_TYPE：与Request数据包中的QUESTION_TYPE字段相同</li>
<li>RP_CLASS：与前面Request数据包的QUESTION_CLASS字段取值相同</li>
<li>TTL：4字节，取值为0x00000000</li>
<li>RDLENGTH:表示从NUM_NAMES字段开始到整个RESOURCE RECORD结束共有多少个字节</li>
<li>NUM_NAMES：表示紧随其后的NODE_NAME ARRAY数组的元素个数，数组的每个元素具有NODE_NAME结构，如图所示为NODE_NAME结构：
<img src="http://i.imgur.com/ArSP1Xp.png" alt="NODE_NAME" /></li>
<li>NETBIOS FORMAT NAME表示远程主机的机器名或者组名，具体依赖NAME_FLAG字段的取值；</li>
<li>NAME_FLAGs：当最高位为1时，NETBIOS FORMAT NAME字段中存储的是Group NetBIOS名称，即工作组名，当最高位为0时，NETBIOS FORMAT NAMR字段中存储的是机器名</li>
<li>STATICS：包含的字段非常多，开始6字节是远程主机的MAC地址</li>
</ul>
</li>
</ol>


<h2>NTP协议</h2>

<ol>
<li>NTP是网络时间协议，是用来使设备时间同步化的一种协议，在一些应用长河里，时间同步时十分重要的，贴别是随着设备运行时间增长，时间误差就越来越大，因为设备中晶振自身会产生误差，那么NTP协议就可以解决这个问题。</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-08-17T09:50:48+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/msp430f5529/'>msp430f5529</a>, <a class='category' href='/blog/categories/w5500/'>w5500</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/27/cadence-allegro/">
		
			Cadence-Allegro</a>
	</h2>
	<div class="entry-content">
		<h2>Cadence简介</h2>

<ol>
<li>Cadence公司著名的软件有Cadence Allegro（布局布线设计工具），Cadence LDV，Cadence IC，Cadence OrCAD等</li>
<li>整个软件系统主要功能模块：

<ol>
<li>Design Entry HDL：提供了一个原理图输入和分析环境</li>
<li>Design Entry CIS：是Cadence收钩原OrCAD公司的产品，是国际上通用的标准的原理图输入工具，与Allegro实现了无缝连接</li>
<li>Design Entry HDL Rules Checker：Design Entry HDL的规则检查工具</li>
<li>Library Explorer：进行数字设计库管理的软件，可以调用Design Entry HDL、PCB Librarian、PCB Designer、Allegro System Architect等工具建立的元件符号和模型</li>
<li>Package Designer：芯片和封装的设计分析软件</li>
<li>PCB Editor：高性能PCB设计软件</li>
<li>PCB Librairan：Allegro库开发</li>
<li>PCB Router：CCT布线器</li>
<li>PCB SI：提供一个集成的高速设计与分析环境</li>
<li>Physical Viewer：Allegro浏览器模块</li>
<li>Project Manager：Design Entry HDL的项目管理器</li>
<li>AMS Simulator：工业标准的模拟、数字及模拟/数字混合信号仿真系统</li>
<li>PCB Editor Utilities：包含Pad Designer、DB Doctor和Bach DRC等工具</li>
</ol>
</li>
</ol>


<h2>快捷键</h2>

<ol>
<li>原理图编辑：

<ol>
<li>原理图放大：I，或者Ctrl+滚轮向上滚</li>
<li>原理图缩小：O，或者Ctrl+滚动向下</li>
<li>原理图向上走：PGUP</li>
<li>原理图向下走：PGDN</li>
<li>原理图向左走：Ctrl+PGUP</li>
<li>原理图向右走：Ctrl+PGDN</li>
<li>元器件旋转，变换方向：R</li>
<li>元器件复制拖动：Ctrl+拖动</li>
<li>元器件更新：

<ol>
<li>replace：元起价信息包括封装全部更新</li>
<li>update：只会更新元器件基本细心，封装信息不会更新</li>
</ol>
</li>
</ol>
</li>
<li>SCH库编辑：

<ol>
<li>进入下一个分片元件的编辑：Ctrl+N</li>
<li>返回上一个分片元件的编辑：Ctrl+B</li>
</ol>
</li>
</ol>


<h2>补充知识</h2>

<ol>
<li>0.1inch = 2.54mm</li>
<li>总线的命名：Basename[0:len-1]表示总线名Basename，位长len</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-27T21:55:59+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cadence/'>cadence</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/22/tl-wr740n/">
		
			TL-WR740N刷机救砖指南</a>
	</h2>
	<div class="entry-content">
		<h2>型号</h2>

<blockquote><p>Flash：4MB，DRAM：32MB，CPU：AR7240，Baud：115200</p></blockquote>

<h2>固件下载</h2>

<p><a href="http://www.dd-wrt.com/site/support/router-database">下载地址</a></p>

<h2>TTL刷机命令</h2>

<ol>
<li>上电连续输入TPL三个字母知道进入uboot界面停住</li>
<li>tftpdboot 0x80000000 [固件名称]</li>
<li>erase 0x9f020000 +0x3c0000</li>
<li>cp.b 0x80000 0x9f020000 0x3c0000</li>
<li>bootm 0x9f020000</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-22T09:51:38+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/20/linux-kernel/">
		
			Linux_Kernel</a>
	</h2>
	<div class="entry-content">
		<h2>内核make流程</h2>

<ol>
<li>make %config和make menuconfig的目的是为了生成.config文件，而Kconfig作为生成make menuconfig等图形配置界面工具而存在</li>
<li>.config 文件中决定了内核中的哪些代码被编译进内核，哪些代码被当做模块编译</li>
<li>make根据.config中的描述，通过解析Makefile文件来进行编译，最终生成zImage文件</li>
<li>流程中设计的文件与命令，再加上Linux内核的scripts目录构成了内核的Kbuild机制，内核通过这种方式，最终编译得到内核镜像文件zImage</li>
</ol>


<h2>KBuild机制实现原理</h2>

<ol>
<li>从编译过程来看，每一个被编译的目录下都会生成一个build-in.o文件，他们都由自己目录下的源代码编译生成，所有目录下的build-in.o文件最终链接生成vmlinux文件，最后由内核压缩程序加工vmlinux生成内核压缩镜像文件zImage</li>
<li>总原理来看，Kbuild机制只会把obj-y的值编译进内核。每个Makefile文件中都有这个变量，只不过obj-后面一半都跟着一个变量，这个变量的值来自于.config。</li>
<li>待编译目录下的Makefile，如有Kbuild，则Kbuild优先，唯一使用Kbuild而不是Makefile的就是顶层目录</li>
</ol>


<h2>Kconfig语法</h2>

<ol>
<li>config

<ul>
<li>为menu或者choice中的一个选项条目</li>
<li>config后面常跟一个变量名，比如ARM，那么在.config中将以CONFIG_ARM=y或n的形式出现</li>
<li>下一行写该变量的取值类型,可以是bool,tristate,string,hex,int</li>
<li>default为变量缺省值，可以被用户设置值覆盖</li>
<li>prompt后边是出现在配置菜单中的对应于一个配置选项的文字，没有prompt条目，将使得用户不能在配置界面中显示并配置该配置选项</li>
<li>depends on var表示该变量必须在var被设置的情况下才能进行设置，否则取值为n，即使default为y</li>
<li>select var表示它将影响到变量var，使得var至少应该配置为y或者m</li>
<li>help中的文字将作为配置界面中的帮助信息</li>
</ul>
</li>
<li>menu

<ul>
<li>在menu和endmenu中间可配置若干config条目</li>
</ul>
</li>
<li>choice

<ul>
<li>在choice和endchoice之间可定义若干config条目。choice中的config条目只能有2种类型：bool或者tristate，且不能同时有这两种变量。对于bool型变量只能在多个选择中选择1个为y；对于tristate型变量，要么将多个设置为m，要么仅将1个设为y，其余为n。</li>
</ul>
</li>
<li>comment

<ul>
<li>用于定于帮助信息，将出现在配置界面的第一行，并且还会出现在配置文件.config中作为注释</li>
</ul>
</li>
<li>source

<ul>
<li>由于内核源代码中大多数目录下都有各自的Kconfig文件，因此需要一种手段将所有的Kconfig文件组织为一个整体。这就是source的功能，它用于引入另一个Kconfig文件，有点类似于C语言中的#include</li>
</ul>
</li>
</ol>


<h2>Makefile文件精解</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#如果CONFIG_ATL1=y，将递归进入本目录的子目录atl1，并根据该子目录下的Makefile文件的内容决定该子目录如何继续拧编译，否则将不进入本目录的子目录atl1进行编译</span>
</span><span class='line'><span class="n">obj</span><span class="o">-</span><span class="err">$</span><span class="p">(</span><span class="n">CONFIG_ATL1</span><span class="p">)</span> <span class="o">+=</span> <span class="n">atl1</span><span class="o">/</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#如果.config中变量CONFIG_GIANFAR=y，那么将变异本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar)sysfa.c文件并将其功能集成进zImage；如果.config文件中变量CONFIG_GIANFAR=m，那么将编译本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar_sysfs.c文件生成模块gianfar.ko；否则将编译gianfar.c,gianfar_ethtool.c</span>
</span><span class='line'><span class="n">gianfar_mii</span><span class="p">.</span><span class="n">c</span><span class="p">,</span><span class="n">gianfar_sysfa</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="n">obj</span><span class="o">-</span><span class="err">$</span><span class="p">(</span><span class="n">CONFIG_GIANFAR</span><span class="p">)</span> <span class="o">+=</span> <span class="n">gianfar_driver</span><span class="p">.</span><span class="n">o</span>
</span><span class='line'><span class="n">gianfar_driver</span><span class="o">-</span><span class="nl">objs</span> <span class="p">:</span><span class="o">=</span> <span class="n">gianfar</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_ethtool</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_mii</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_sysfs</span><span class="p">.</span><span class="n">o</span>
</span></code></pre></td></tr></table></div></figure>


<h2>zImage文件生成过程</h2>

<ol>
<li>内核代码首先被编译生成vmlinux，放在Linux源码的顶层目录下</li>
<li>这个vmlinux可执行文件又通过arm-linux-objcopy命令转化为二进制代码文件Image（放在arch/arm/boot目录下），其实这个Image文件才是真是的内核代码文件，因为这个文件会比较大，所以内核会对它做压缩处理</li>
<li>为了最大化减小Image的体积，内核调用gzip工具吧Image压缩成piggy.gz文件</li>
<li>为了让内核具有自引导功能，在arch/arm/boot/compressed目录下有head.o,misc.o两个文件构成解压和自引导代码，而让真实的piggy.gz文件也参与编译，最终生成了梁歪一个vmlinux文件，放在arch/arm/boot/compressed目录下，并最终调用arm-linux-objcopy生成二进制文件zImage。</li>
<li>综上，zImage文件由arch/arm/boot/compressed目录下的head.S和misc.c文件（自解压程序）+内核真实代码文件组成</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-20T23:30:54+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/kernel/'>kernel</a>, <a class='category' href='/blog/categories/linux/'>linux</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/20/cpp-knowledges/">
		
			CPP-Knowledges</a>
	</h2>
	<div class="entry-content">
		<h2>流</h2>

<ol>
<li>标准C++中，iostream中常见的操作算子(manipulator):flush,endl,oct(后面跟的数据解析成八进制)，hex(后面跟的数解析成十六进制)，dec(后面跟的数解析成十进制)，boolalpha(后面跟的数据解析成布尔类型，并用true和false来显示)，showpos(后面跟的数据显示正负号)，fixed(后面跟的数不要四舍五入),noshowpos(后面跟的数如果是正数就显示+号),showpoint(后面跟的数据显示小数点)，scientific(后面跟的数据以科学计数法的形式表示);在Qt中附加的一些操作算子：forcesign(后面的数据显示正负号),forcepoint(后面的数据显示小数点),noforcesign(后面的数据如果是正数就不显示+号)</li>
<li>标准C++的iostream中，getline(cin,your_string)语句能够从标准输入流中提取一行字符串</li>
<li>在Qt中很容易用与iostream对应的同一个名称定义QTextStream，由于控制台输入和输出主要用在调试过程，所以Qt提供了一个全局函数qDebug(),用它可以方便地将消息发送到控制台，且具有灵活的接口</li>
<li>流被用来读取/写入文件、连接网络和处理字符串，它有一个有用的特性是易于从混合数据类型中得到字符串。</li>
<li>STL中的字符串流：std::ostringstream,常用来定义一个string_buffer;</li>
<li>STL中的文件流std::ofstream,用来定义一个文件流管道如ofstream outf后绑定一个文件：outf.open(&ldquo;file path&rdquo;)</li>
<li>STL中的输入文件流std::ifstream,打开文件instream inf;inf.open(&ldquo;file path&rdquo;),判断是否读到了文件末尾inf.eof(),读取一行数据getline(inf,newstr)</li>
<li>STL中的stringstream对应于Qt里面的QString，STL中的fstream对应于Qt里面的QFile，STL中的iostream对应于Qt中的QTextStream</li>
</ol>


<h2>运算符new和delete</h2>

<ul>
<li>new运算符从堆(heap)中分配内存空间，并且返回指向新分配的对象的指针，如果由于某种原因无法完成内存分配，就会抛出一个异常</li>
<li>delete运算符的作用是释放动态分配的内存并将其返回给堆。delete操作只能用于由new运算符返回的指针或者空指针。</li>
</ul>


<h2>智能指针</h2>

<ul>
<li>智能指针是一个对象，它用来保存和管理指向堆对象的指针，其行为与常规的指针非常类似，只是它会在合适的时刻自动删除堆对象。这个类在Qt中对应的是QPointer，在标准库中是std::auto_ptr,在Boost中是shared_ptr</li>
</ul>


<h2>引用</h2>

<ul>
<li>在C++中，引用提供了一种给左值赋予一个别名的机制，对于避免费事或者不必要的复制引用是非常有用的，例如向函数传送一个非常大的对象作为参数。<strong>引用必须在声明时进行初始化且其初始化器也必须是一个左值</strong>,例如：<code>int n;int&amp; rn=n;</code>引用变量rn是实际变量n的别名</li>
<li>一种好的编程实践是：对于不需要通过函数来进行变化的指针和引用参数，应使用const来保护它们。只读引用参数的能力在于：对按引用传递参数提供了高效性，而对按值传递参数提供了安全性</li>
</ul>


<h2>类的友元</h2>

<ul>
<li>友元机制允许非成员函数访问一个类的私有数据，关键字friend可以放在类的生命或者函数声明之前，友元声明位于类定义之内</li>
<li>通常而言，为了达到下面两个目的才会使用友元函数：

<ol>
<li>为了使用工厂方法，此时需要对某个类强制实施某些创建规则</li>
<li>为了使用全局运算符函数，比如operator&lt;&lt;()和operator>>()，此时不希望将运算符作为某个类的成员函数，或者没有写入类定义的权利</li>
</ol>
</li>
</ul>


<h2>运算符重载</h2>

<ol>
<li>C++使用关键字operator为运算符赋予新的含义</li>
<li>例如重载&lt;&lt;运算符：friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const Complex&amp; c);</li>
</ol>


<h2>define与inline的区别</h2>

<blockquote><ol>
<li>对#define宏的替换过程是由预处理器处理的，预处理器本质上是一个文本编辑器。对inline函数的替换过程是由编译器处理的，它会执行更智能的操作，进行正确的类型检查</li>
<li>inline函数必须在调用之前<strong>定义</strong></li>
<li>在一个源代码模块中只能有一次inline定义</li>
</ol>
</blockquote>

<h2>带变长实参表的函数</h2>

<blockquote><ol>
<li>在C和C++中，可以定义其参数表以省略号结尾的函数。省略号使调用者能够制定参数的数量以及类型。</li>
<li>为了定义使用省略号的函数，需要包含cstdarg库</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">double</span> <span class="nf">mean</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...){</span>
</span><span class='line'>  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>               <span class="cm">/*ap执行第一个未命名实参*/</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>      <span class="n">sum</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="kt">double</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>                 <span class="cm">/*返回之前清除栈*/</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sum</span><span class="o">/</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>预处理宏主要应用场合</h2>

<blockquote><ol>
<li>使用#ifndef/#define/#endif将头文件包裹起来，以避免多次包含某个头文件</li>
<li>使用#ifdef/#else/#endif对某些代码部分进行条件编译</li>
<li><strong>FILE</strong>宏和<strong>LINE</strong>宏用于调试并给出框架信息</li>
</ol>
</blockquote>

<h2>C++中的多态性</h2>

<blockquote><ol>
<li>C++源于C语言，它的编译器也试图在编译时绑定函数调用，这主要是基于性能方面的考虑。编译器无法仅凭集成关系和基类指针就确定它正在操作何种对象。如果没有运行时检查，就无法保证运行时调用正确的函数。C++要求使用一个特殊的关键字来允许运行时通过指针和引用进行函数调用的绑定，这个关键字就是virtual，它能够使得程序具有多态性。</li>
<li>由于this是在执行它的构造函数时被初始化的，在执行它的析构函数的时候被销毁，因此不要指望在这两种条件下能够执行正确的运行时绑定。当在构造函数或者析构函数里面调用任何this方法时，将由编译时绑定决定应该调用哪一个方法，就好像不存在virtual关键字一样。</li>
<li>一般而言，如果类中包含一个或者多个virtual函数，则也应包含一个虚析构函数。这是因为，当对对台对象集合进行操作时，通常是通过基类指针删除这些对象，这会导致对析构函数的间接调用，如果析构函数不为virtual类型，在编译时绑定将决定应该调用哪一个析构函数，从而可能导致派生对象的不完整析构</li>
<li>静态成员函数不能使虚函数；内敛函数不能是虚函数；构造函数不能是虚函数</li>
</ol>
</blockquote>

<h2>虚函数实现原理</h2>

<blockquote><ol>
<li>父类中如果有虚函数存在，编译器就会为该对象创建一个虚函数表，里面存放自己的虚函数的指针。</li>
<li>子类继承父类，编译器也会为子类创建一个不同的虚函数表，存放子类自己的虚函数指针</li>
<li>拥有虚函数表的类都会另外创建一个指向该表的指针</li>
<li>所以当父类指针指向子类对象，调用虚函数的时候就会根据子类对象的虚函数表调用得到子类的虚函数，而不是父类的虚函数</li>
<li>如果没有在子类中定义与父类同名的虚函数，那么就会在子类的虚函数表中就会写上父类的相应的虚函数的函数入口地址；如果在子类中也定义了同名的虚函数，那么在虚函数表中用子类的虚函数的函数地址覆盖掉父类的相应的虚函数的函数地址</li>
<li>每个类只有一份虚函数表，所有该类的对象共用同一张虚函数表</li>
<li>只有函数声明没有函数定义的虚函数也是纯虚函数</li>
</ol>
</blockquote>

<h2>纯virtual函数的声明</h2>

<blockquote><ol>
<li>virtual returnType functionName(parameterList)=0;</li>
<li>抽象基类中至少要有一个virtual函数</li>
<li>抽象基类中不能有public的构造函数</li>
<li>抽象基类的任何具体派生类都必须重写并定义全部的纯virtual基类函数，话句话说，任何没有重写并定义全部纯virtual基类函数的派生类都是抽象类</li>
</ol>
</blockquote>

<h2>重载，隐藏与重写</h2>

<blockquote><ol>
<li>当函数foo在同一个作用域内存在两个或者多个版本(具有不同的签名)时，就称foo函数被<strong>重载</strong>了</li>
<li>当基类中的一个virtual函数在培生累中也存在，并且他们具有相同的签名和返回类型时，就称派生类中的版本“重写”了基类中的版本</li>
<li>派生类中的成员函数，会隐藏基类中与之同名的全部函数，如果出现这种情况，则：

<ul>
<li>只有派生类函数可以被直接调用</li>
<li>类作用域解析运算符::西部用来显式地调用基类函数</li>
</ul>
</li>
</ol>
</blockquote>

<h2>有三种特殊的成员函数从来不会被继承，编译器会为没有定义它们的类自动生成这三种函数</h2>

<ol>
<li>拷贝构造函数：类名（const 类名&amp; 变量名）</li>
<li>复制赋值运算符</li>
<li>析构函数</li>
</ol>


<h2>构造函数</h2>

<blockquote><p>如果一个类没有构造函数，那么编译器就会自动产生一个默认的public构造函数，而这个构造函数会调用它的每一个基类的默认构造函数。如果某个类有一些构造函数但是没有默认构造函数，那么它就不会进行默认的初始化工作，这种情况下，任何派生类构造函数都必须在其初始化列表中明确地指名应该调用哪一个基类构造函数</p></blockquote>

<h2>类的前置声明</h2>

<blockquote><ol>
<li>类的前置声明将它的名称声明成一个有效的类名称，但不给出类的定义。这会使得类名称能够被用作<strong>指针</strong>和<strong>引用</strong>的类型，在遇到类的定义之前，不会将这些指针和引用进行解引操作。</li>
<li><strong>如果可以使用前置声明，就不要使用#include指令</strong></li>
</ol>
</blockquote>

<h2>范型与模板</h2>

<blockquote><p>1.模板为C++编译器提供了一个途径，能够为带有参数化类型和相同行为的类和函数生成多个版本。模板使用关键字template以及用尖括号&lt;>包围的模板参数进行区分。与函数参数不同，模板参数不仅可以传递变量和值，还可以传递类型表达式。例如：template <class T,int max> Buffer{T v[max];}
2. 每当编译器看到一个特定参数类型的组合首次用于一个模板函数时，就称此模板进行了实例化。
3. 类模板主要用来生成数据的通用容器，其参数能够指名容器中的内容。所有的Qt容器类以及标准模板库(STL)中的所有容器类都是参数化的。
4. 所有模板的定义(类和函数)都必须出现在头文件中，这是因为编译器需要用这些定义来根据模板声明生成代码</p></blockquote>

<h2>其他</h2>

<ul>
<li>C++中使用struct的大多数情形是需要将数据项分组在一起，但是不需要成员函数</li>
<li>const成员函数中不允许对数据成员进行修改，如果修改，编译器将报错，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误。注意可以在const成员函数里面更改可变成员(mutable member)的值，而常规的数据成员的值不能改变</li>
<li>类内定义的成员函数编译器会优先编译成内联(inline)函数</li>
<li>初始化列表优先于构造函数执行.初始化列表只能用于构造函数,初始化列表可以同时初始化多个数据成员</li>
<li>const数据成员的初始化必须写在初始化列表中</li>
<li>M_PI来自于&lt;math.h>,它位于cstdlib库中</li>
<li>foreach()宏需要赋值它所遍历的容器，这就要求使用foreach必须要有拷贝构造函数</li>
<li>C++类型可以分成两类：值类型和对象类型，值类型的有Anything*，int，char，QString，QDate和QVariant。带有共有默认构造函数、拷贝构造函数和复制赋值运算符的任何类型都是值类型</li>
<li>C++对于没有数据成员的类在实例化的时候会分配1个内存单元(1Byte)，用于标记该对象的存在</li>
<li>含有纯虚函数的类叫做抽象类,抽象类无法实例化对象</li>
<li></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-20T09:42:10+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>c++</a>


</div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts/2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    suda-morris

Powered by Octopress-WenRis Group
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>