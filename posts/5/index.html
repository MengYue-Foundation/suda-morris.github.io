
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>WenRis Blog</title>
	<meta name="author" content="suda-morris">

	
	<meta name="description" content="WenRis Blog">
	<meta name="keywords" content="C/C++,Python,Lua">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="WenRis Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">WenRis Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="/blog/categories">Categories</a></li>
	<li><a href="/aboutme">About</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.baidu.com" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:suda-morris.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/Morris1106com" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/suda-morris" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.baidu.com" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:suda-morris.github.io">
	</form>
</nav>

</header>
	
		
	

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/17/w5500-introduce/">
		
			W5500-Introduce</a>
	</h2>
	<div class="entry-content">
		<h2>W5500网络模块简介</h2>

<ol>
<li>公司：Wiznet</li>
<li>使用硬件逻辑门电路实现TCP/IP协议栈的传输层及网络层（如：TCP，UDP，ICMP，IPv4，ARP，IGMP，PPPoE等协议），并集成了数据链路层，物理层(10BaseT/100BaseTX)，以及32K字节片上RAM作为数据收发缓存，使得上位机主控芯片只需承担TCP/IP应用层控制信息的处理任务，大大节省了上位机对于数据复制、协议处理和中断处理等方面的工作量，提升了系统利用率及可靠性</li>
<li>操作过程中，用户可以近似将W5500作为MCU的一个外设RAM来使用，非常简易。W5500对外接口通常为通用的80MHz高速SPI</li>
<li>W5500支持同时的8个socket，方便和不同的IP和设备进行通讯；为了减小系统能耗，W5500提供了网络环形模式(WOL)以及掉电模式供客户选择使用；W5500是非可攻击性的硬件网络引擎，可以防止类似于洪流，诈骗式以及注入式网络攻击，提高了网络安全</li>
<li>支自动协商(10/100-Based全双工/半双工)</li>
<li>3.3V工作电压，I/O信号口5V耐压</li>
<li>W5500 不支持Auto-MDI-X，也就是不支持交叉直连自动切换，对于某些比较老的设备，可能需要特定的交叉线或者直连线。比如模块连模块，需要使用交叉线，模块连路由器或者交换机需要使用直连线。</li>
<li>W5500不支持自动极性变换功能，因此用户需要使用直连线与交换机或者路由器连接，使用交叉线与终端设备(如服务器，工作站或者其他W5500)相连接。然而用户可以使用任何一种类型的网线与具有自动极性变换的其他设备相连。</li>
<li>W5500以太网芯片的内核由传输层的TCP、UDP、ICMP、IGMP等协议、网络层的IP、ARP、PPPoE等协议以及链路层的MAC构成，再加上物理层的PHY和外围的寄存器、内存、SPI接口组成了这一整套硬件化的以太网解决方案</li>
<li>SPI时钟设定值速率为80MHz，但是高速信号在受电磁串扰和长信号线的影响下可能会失真，实测具有稳定波形的始终速率为33.3MHz</li>
</ol>


<h2>W5500初始化主要使用的几个文件：</h2>

<ol>
<li>W5500_conf.c->主要配置W5500的MAC、IP地址，W5500基本的数据读写过程，复位设置函数等</li>
<li>Socket.c->主要介绍了W5500的SOCKET相关配置函数，比如SOCKET的打开、关闭以及接收数据、发送数据等等</li>
<li>Utility.c->主要介绍了基本的延时函数，还有数据格式转化函数</li>
<li>w5500.c->主要介绍W5500的寄存器读写过程</li>
</ol>


<h2>W5500的Socket初始化</h2>

<ol>
<li>W5500的操作需要设置一下寄存器的参数：

<ol>
<li>模式寄存器(MR)</li>
<li>中断屏蔽寄存器(IMR)</li>
<li>重发时间寄存器(RTR)</li>
<li>重发计数寄存器(RCR)</li>
</ol>
</li>
<li>设置网络信息，下面的寄存器是关于网络的基本设置，需要根据网络环境来进行设置

<ol>
<li>网关地址寄存器(GAR)</li>
<li>本机物理地址寄存器(SHAR)</li>
<li>子网掩码寄存器(SUBR)</li>
<li>本机IP地址寄存器(SIPR)</li>
</ol>
</li>
<li>设置端口存储信息，这一步设置端口TX/RX存储信息，每个端口的基地址和屏蔽地址在这里确定并保存。

<ol>
<li>W5500有一个通用寄存器，8个Socket寄存器区，以及对应每个Socket的收发缓存区。每一个Socket的发送缓存区都在一个16KB的物理接收内存中，初始化分配为2KB。无论给每个Socket分配多达的收发缓存，都必须在16为的偏移地址范围内(0x0000~0xFFFF).16KB的发送内存初始化被分配为每个SOcket 2KB发送缓存区(2KB*8=16KB)。</li>
<li>初始化分配的2KB Socket发送缓存，可以通过使用Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)重新分配，一旦所有的Socket发送缓存大小寄存器(Sn_TXBUF_SIZE)配置完成，16KB的发送内存就会按照配置分配给每个Socket的发送缓存，并按照从Socket0到7顺序分配。16KB物理内存的地址是可以自增的，但是为了避免数据传输错误，需要避免发送缓存大小寄存器(Sn_TXBUF_SIZE)的和超过16</li>
<li>16KB的发送内存中分配了对应Socket n的发送缓存区，用于为来自主机传输的数据做缓存。Socket n发送缓存区的16位偏移地址支持64KB的寻址范围(从0x0000到0xFFFF)</li>
</ol>
</li>
</ol>


<h2>SPI工作协议</h2>

<ol>
<li>SPI协议定义了四种工作模式(模式0，1，2，3)。每种模式的区别是根据SCLK的极性及相位不同定义的。SPI的模式0和模式3唯一不同的就是在非活动状态下，SCLK信号的极性，SPI模式0在时钟空闲状态时钟极性为低电平。SPI的模式0和3，数据都是在SCLK的上升沿锁存，在下降沿输出。W5500支持SPI模式0以及模式3，MISO和MOSI信号无论是接收或者发送，均遵从从最高标志位(MSB)到最低标志位(LSB)的传输序列。</li>
<li>W5500与外设主机的通讯受SPI数据帧控制，W5500的帧分为3段：地址段，控制段，数据段</li>
<li>地址段为W5500寄存器或者TX/RX内存指定的16位的偏移地址。</li>
<li>控制段指定了地址段设定的偏移区域的归属，读写访问模式以及SPI工作模式(可变长度模式/固定长度模式)</li>
<li>数据段可以设定为任意长度(N字节)或者是固定长度：1字节，2字节或4字节；如果SPI工作模式设置为可变数据长度模式(VDM),SPI的SCSn信号需要由外部主机通过SPI帧控制。</li>
<li>在可变长度模式下，SCSn控制SPI帧的开始和停止：

<ol>
<li>SCSn信号拉低，即代表W5500的SPI帧开始(地址段)</li>
<li>SCSn信号拉低，即代表W5500的SPI帧结束(数据段的随机N字节数据结尾)</li>
</ol>
</li>
<li>W5500的SPI数据帧包括了16为地址段的偏移地址，8为控制段和N字节数据段。8为控制段可以通过修改区域选择位(BSB[4:0]),读写访问模式位(RWB)以及SPI工作模式位(OM[1:0])来重新定义。区域选择位选择了归属于偏移地址的区域</li>
<li>W5500支持数据的连续读写。其流程为数据从(2/4/N字节连续数据的)偏移地址的基址开始传输，偏移地址会自增寻址(加1)传输接下来的数据</li>
<li>SPI数据帧控制段对应位的说明：

<ol>
<li>区域选择位BSB[4:0]-> 【00000】= 通用寄存器；【00001】= Socket0寄存器；【00010】=Socket0发送缓存；【00011】=Socket0接收缓存；【00101】=Socket1寄存器；【00110】=Socket1发送缓存；【00111】=Socket1接收缓存；【01001】= Socket2寄存器；【01010】=Socket2发送缓存；【01011】=Socket2接收缓存；【10101】=Socket3寄存器；【01110】=Socket3发送缓存；【01111】=Socket3接收缓存；【10001】= Socket4寄存器；【10010】=Socket4发送缓存；【10011】=Socket4接收缓存；【10101】=Socket5寄存器；【10110】=Socket5发送缓存；【10111】=Socket5接收缓存；【11001】= Socket6寄存器；【11010】=Socket6发送缓存；【11011】=Socket6接收缓存；【11101】=Socket7寄存器；【11110】=Socket7发送缓存；【11111】=Socket7接收缓存；</li>
<li>读写访问模式位RWB-> 【0】=读；【1】=写</li>
<li>工作模式位OM[1:0]-> 【00】=可变数据长度模式，N字节数据段(1≤N)；【01】=固定数据长度模式，1字节数据长度(N=1)；【10】=固定数据长度模式，2字节数据长度(N=2)；【11】=固定数据长度模式，4字节数据长度(N=4)；</li>
</ol>
</li>
<li>W5500有一个通用寄存器，8个Socket寄存器，以及对应每个Socket的收发缓存区。每个区域均通过SPI数据帧的区域选择位BSB[4:0]来选取。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212635.png" alt="SPI模式0/3" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150825212850.png" alt="SPI数据帧" /></li>
</ol>


<h2>物理层</h2>

<blockquote><p>由计算机和网络介质之间的实际界面组成，可定义电器信号、符号、线的状态和时钟要求、数据编码和数据传输用的连接器。如最常用的RS-232规范、10BASE-T的曼彻斯特编码以及RJ-45就属于这一层。</p></blockquote>

<h2>数据链路层</h2>

<blockquote><ol>
<li>数据链路层通过物理网络链路提供可靠的数据传输。不同的数据链路层定义了不同的网络和协议特征，其中包括物理编址、网络拓扑结构、错误校验、帧序列以及流控</li>
<li>以太网协议规定，一组电信号构成一个数据包，叫做“帧”，每一帧分成三个部分：以太网首部、数据及以太网尾部。</li>
<li>以太网首部包含数据帧的一些说明，比如发送者、接收者、数据类型等等；数据部分则是数据的具体内容；以太网尾部则是CRC校验码</li>
<li>以太网首部的长度固定为14字节。数据的长度最短为46字节，最长为1500字节。以太网尾部的长度固定为4字节。因此，整个数据帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送</li>
<li>数据链路层实际上由两个独立的部分组成：介质存取控制(MAC)和逻辑链路控制(LLC)。MAC描述在共享介质环境中如何进行站的调度、发生和接收数据。MAC确保信息跨链路的可靠传输，对数据传输进行同步，识别错误和控制数据流向。一般来讲，MAC只在共享介质环境中才是重要的，只有在共享介质环境中多个节点才能连接到同一传输介质上。</li>
<li>一块网卡如何知道另一块网卡的MAC地址?ARP协议(网络层)可以解决这个问题。以太网数据帧必须知道接收方的MAC地址然后才能发送。有了数据帧的定义，网卡的MAC地址，广播的发送方式，数据链路层就可以在多台计算机之间传送数据了</li>
</ol>
</blockquote>

<h2>网络层</h2>

<blockquote><ol>
<li>网络层负责在源和终点之间建立连接。它一般包括网络寻址，还可能包括流量控制、错误检查等。相同MAC标准的不同网段之间的数据传输一般只涉及到数据链路层，而不同的MAC标准之间的数据传输都涉及到网络层。IP路由器工作在网络层，因为可以实现多种网络间的互联。</li>
<li>IP数据包分为“标头”和“数据”两个部分。标头部分主要包括版本、长度、IP地址等细心，数据部分则是IP数据报的具体内容。IP数据报的标头部分长度为20到60字节，整个数据报的总长度最大为65535字节，因此理论上，一个数据报的数据部分最长为65515字节。以太网数据帧的数据部分最长只有1500字节，因此如果IP数据报超过了1500字节，它就要分割成几个以太网数据帧分开发送了。</li>
</ol>
</blockquote>

<h2>传输层</h2>

<blockquote><ol>
<li>传输层向高层提供可靠的端到端的网络数据流服务。传输层的功能一般包括流控、多路传输、虚电路管路以及差错校验和恢复。流控管理设备之间的数据传输，确保传输设备不发送比接受设备处理能力大的数据；多路传输使得多个应用程序的数据可以传输到物理链路上；虚电路由传输层建立、维护和终止；差错校验包括为检测传输错误而建立的各种不同结构；而差错回复包括所采取的行动，以便解决发生的任何错误。</li>
<li>必须要在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，UDP数据段也是有“标头”和“数据”两部分组成</li>
<li>标头部分主要定义了发出端口和接收端口，“数据”部分就是具体的内容，然后把整个UDP数据段放入IP数据报的“数据”部分，而IP数据报又是放在以太网数据帧之中的。</li>
<li>UDP数据段非常简单，标头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据报</li>
<li>为了提高网络可靠性，诞生了TCP协议，这个协议非常复杂，但可以近似认为，他就是有确认机制的UDP协议，没发出一个数据都要求确认。如果有一个数据缺失，就收不到确认，发送方就知道有必要重发这个数据了</li>
<li>TCP数据段没有长度限制，理论上可以无限长，但是为了保证网络的效率。通常TCP数据段的长度不会超过IP数据报的长度，以确保单个TCP数据段不必再分割。</li>
</ol>
</blockquote>

<h2>应用层</h2>

<blockquote><p>应用层是最接近终端用户的第一层，这就意味着应用层与用户之间是通过应用软件直接相互作用。应用层并非由计算机上云sing的实际应用软件组成，而是由向应用程序提供访问网络资源的API组成。</p></blockquote>

<h2>寄存器</h2>

<h3>W5500通用寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823140450.png" alt="W5500通用寄存器" /></p>

<h3>Socket寄存器</h3>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImg20150823141841.png" alt="Socket寄存器" /></p>

<ol>
<li>通用寄存器区配置了W5500的基本信息，如IP以及MAC地址</li>
<li>W5500支持8个Socket作为通讯信道，每一个Socket通过Socket n寄存器控制。Socket n寄存器可以通过SPI数据帧中的区域选择寄存器BSB[4:0]来选定对应的寄存器n。</li>
</ol>


<h2>TCP/IP协议族</h2>

<p><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgW5500%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95%E6%9D%BF%E6%95%99%E7%A8%8B.png" alt="TCP/IP协议族" /></p>

<h2>TCP协议</h2>

<ol>
<li>TCP协议通过三个报文段完成连接的建立，这个过程称为三次握手。TCP连接建立过程：

<ol>
<li>第一次握手：建立连接时，客户端发送SYN包(seq=j)到服务器，并进入SYN_SEND状态，等待服务器确认</li>
<li>第二次握手：服务器收到SYN包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(seq=k),即SYN+ACK包，此时服务器进入SYN_RECV状态</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISH状态，完成三次握手</li>
</ol>
</li>
<li>终止一个TCP连接需要四次挥手，这是由TCP的半关闭(half-close)造成的

<ol>
<li>第一次挥手：主动方发出设置了FIN位的报文，表示主动终止从本地到远端的单向链接；此时主动方进入FIN_WAIT1状态，意思是它在等待远端的FIN报文</li>
<li>第二次挥手：远端收到FIN后，会立即发送ACK；主动方收到ACK后，进入FIN_WAIT2状态，所以FIN_WAIT1状态持续的时间非常短；此时远端进入CLOSE-WAIT状态，一条单向链接终止了，但另一条还没有，处于HALF-CLOSE连接状态</li>
<li>第三次挥手：当远端进行了必要的数据发送后，它发送FIN，表示它出发的单向连接也要关闭，同时它进入LAST_ACK状态</li>
<li>第四次挥手：主动方收到FIN后，回应一个ACK；远端就此进入CLOSED状态，连接关闭；主动方进入TIME WAIT状态，确保最后一个ACK没有丢失，防止新连接占用刚刚关闭的主动方的地址端口，使得网络中流浪的老连接的返祖被误认为新连接的分组</li>
</ol>
</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手/四次挥手" /></li>
<li>当W5500初始化完成后，程序进入主循环，此时读取Socket的状态值，并选择进入哪种模式。当Socket处于关闭状态时，在进行通信之前，我们先将该Socket初始化，这个Socket作为服务器端，端口号要固定为侦听的端口。当socket将处于初始化完成状态，即SOCK_INIT状态，此时，作为TCP服务器就要执行listen()函数来侦听端口。由于W5500内嵌了TCP/IP协议，连接过程是不需要单片机干预的。如果连接过程中出错造成超时，该Socket将会被关闭，重新进入SOCK_CLOSE状态。待TCP连接的3次握手完成后，socket的状态将会转变为连接建立状态，即代码中定义的SOCK_ESTABLISHED状态。在进入SOCK_ESTABLISHED状态后，便可进行数据收发。数据通信完毕之后执行disconnect()函数，在收到对方FIN数据包之前，该socket将进入SOCK_CLOSE_WAIT状态。</li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPServer%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPServer流程图" /></li>
<li><img src="http://7xj5i0.com1.z0.glb.clouddn.com/@/BlogImgTCPClient%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCPClient流程图" /></li>
</ol>


<h2>UDP协议</h2>

<ol>
<li><img src="http://i.imgur.com/ceIUeSz.png" alt="UDP通信流程图" /></li>
<li>当socket处于关闭状态时，在进行通信之前我们先将该UDP模式的socket端口初始化。当socket将处于初始化完成状态即SOCK_UDP状态，此时就可以通过广播方式发送数据了。</li>
<li><img src="http://i.imgur.com/FxqWkWp.png" alt="UDP报文" /></li>
</ol>


<h2>DHCP协议</h2>

<ol>
<li>W5500作为DHCP客户端，路由器作为DHCP服务器端，在DHCP请求的过程中，包括4个主要阶段：发现阶段、提供阶段、选择阶段以及确认阶段</li>
<li>首次W5500客户端发送DHCPDISCOVER消息(IP地址租用申请)，这个消息通过广播方式发出，所有网络中的DHCP服务器都将接收到这个消息。随后，网络中的DHCP服务器会回应一个DHCPOFFER消息(IP地址租用提供)，由于这个时候客户端还没有网络地址，所以DHCPOFFER也是通过广播的方式发送出去的。然后，向该服务器发送DHCPREQUEST消息。在DHCPREQUEST消息中将包含客户端申请的IP地址。最后，DHCP服务器将会送DHCPACK的相应消息来通知客户端可以使用该IP地址，该确认里面包含了分配的IP地址和该地址的一个稳定期限的租约(默认是8天)，并同时更新DHCP数据库</li>
<li>DHCP初始化完成以后，通过获取DHCP_SOCKET的状态来获取动态IP地址。第一个状态DHCP_RET_NONE就是获取不成功，第二个状态DHCP_RET_TIMEOUT是获取IP地址超时，都不符合条件。第三个状态DHCP_RET_UPDATE就是获取动态IP地址成功，此时将得到的IP地址通过SPI写入W5500的寄存器。如果是DHCP_RET_CONFLICT冲突状态，就要返回DHCP服务重新获取</li>
<li><img src="http://i.imgur.com/sqc1tce.jpg" alt="DHCP报文格式" /></li>
<li>报文格式解析：

<ol>
<li>OP：若是client送给server的封包，设为1，反之为2</li>
<li>HTYPE：硬件类别，10MB以太网为1，100MB以太网为2</li>
<li>HLEN：硬件地址长度，Ethernet为6</li>
<li>HOPS：若封包需要经过router传送，每站加1，若在同一网段内，为0</li>
<li>TRANSACTION ID：DHCP REQUEST时产生的数值，以作为DHCPREPLY时的依据</li>
<li>SECONDS：Client端启动时间(秒)</li>
<li>FLAGS：从0到15共16bits，最左1bit为1时表示server将以广播方式传送封包给client，其余尚未使用</li>
<li>ciaddr：yhaoshiclient端想继续使用之前取得的IP地址，则列于这里</li>
<li>yiaddr：从server送回client的DHCP OFFER与DHCPACK封包中，此栏填写分配给client的IP地址</li>
<li>siaddr：若client需要透过网络开机，从server送出的DHCP OFFER、DHCPACK、DHCPNACK封包中，此栏填写开机程序代码所在server的地址</li>
<li>giaddr：若需跨网域进行DHCP发放，此栏为relay agent的地址，否则为0</li>
<li>chaddr：client的硬件地址</li>
<li>sname：sever的名称字符串，以0x00结尾</li>
<li>file：若client需要透过网络开机，此栏将指出开机程序名称，稍后以TFTP传送</li>
<li>options：允许厂商定义选项，提供更多的设定信息，其长度可变，同时可携带多个选项，每一个选项的第一个字节为信息代码，其后一个自己为该项数据长度，最后为项目内容</li>
</ol>
</li>
</ol>


<h2>DNS协议</h2>

<ol>
<li>客户端初始化完毕之后，如果DNS运行标志位是1或者DNS发送次数超过3次就直接返回。如果不是上面的情况，并且DNS Server的IP不是0.0.0.0时，进入switch函数。当处于DNS域名解析成功状态时，DNS_OK置1，发送请求报文次数置0。当DNS解析域名失败时，标志位置0，请求报文次数加1，然后跳出循环。</li>
<li>DNS报文格式：<img src="http://i.imgur.com/C48NfJR.jpg" alt="DNS报文格式" />

<ul>
<li>标识：DNS报文的ID，对于相关联的请求报文和应答报文，这个字段是相同的</li>
<li>标志：<img src="http://i.imgur.com/ZaPageY.jpg" alt="标志字段" />

<ul>
<li>QR：查询/响应的标志位，1为响应，0为查询</li>
<li>opcode：定义查询或响应的类型(若为0则表示是标准的，若为1则是反向的，若为2则是服务器状态请求)</li>
<li>AA：授权回答的标志位，该位在相应报文中有效，1表示名字服务器是权限服务器</li>
<li>TC：截断标志位，1表示响应以超过512字节并已经被截断</li>
<li>RD：只能在响应报文中置1，表示可以得到递归响应</li>
<li>zero：0，保留字段</li>
<li>rcode：返回码，表示响应的差错状态，0表示无差错，1表示格式差错，2表示问题在域名服务器上，3表示域参照问题，4表示查询类型不支持，5表示在管理上被禁止</li>
</ul>
</li>
<li>问题数、资源记录数、授权资源记录数和额外资源记录数，这四个字段都是两字节，分别对应下面的查询问题、回答、授权和额外信息部分的数量。一般问题数都为1，DNS查询报文中，资源记录数、授权资源记录数和额外资源记录数都为0.</li>
<li>查询问题部分的格式：<img src="http://i.imgur.com/qkVuppN.gif" alt="查询问题格式" />

<ul>
<li>查询名部分长度不定，一般为要查询的域名，有时候也有IP的时候，即反向查询。此部分由一个或者多个标识符序列组成，每个标识符以首字节数的计数值来说明该标识符长度，每个名字以0结束。技术字节数必须在0~63之间</li>
<li>查询类型：

<ul>
<li>1：IPv4地址</li>
<li>2：名字服务器</li>
<li>5：规范名称</li>
<li>6：开始授权，标记一个区的开始</li>
<li>11：熟知服务，定义主机提供的网络服务</li>
<li>12：指针，把IP地址转化为域名</li>
<li>13：主机信息，给出主机使用的硬件和操作系统的表述</li>
<li>15：邮件交换，把邮件改变路由送到邮件服务器</li>
<li>28：IPv6地址</li>
<li>252：传送整个区的请求</li>
<li>255：对所有记录的请求</li>
</ul>
</li>
<li>查询类：通常为1，指Internet数据</li>
</ul>
</li>
<li>回答字段，授权字段和附加信息字段均采用资源记录的相同格式：<img src="http://i.imgur.com/WuZQrVt.gif" alt="资源记录格式" />

<ul>
<li>域名字段(不定长或者2字节)：记录资源数据对应的名字，它的格式和查询名字段格式相同。当报文中域名重复出现时，就需要使用2字节的偏移指针来替换。</li>
<li>类型、类：含义与查询问题部分的类型和类相同</li>
<li>生存时间：该字段表示资源记录的生命周期，一般用于当地址解析程序取出资源记录后决定保存以及使用缓存数据的时间</li>
<li>资源数据长度：表示资源数据的长度，以字节为单位，如果资源数据为IP则为0004</li>
<li>资源数据：该字段是可变长字段，表示按查询段要求返回的相关资源记录的数据</li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>SMTP协议</h2>

<ol>
<li><img src="http://i.imgur.com/9TsOlUJ.png" alt="邮件发送过程示意图" /></li>
<li>SMTP在TCP协议25号端口监听连续请求。SMTP连接和发送过程：

<ol>
<li>建立TCP连接</li>
<li>客户端发送HELO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端正希望以OK作为相应，表明准备接收</li>
<li>客户端发送RCPT命令，以表示该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件</li>
<li>协商结束，发送邮件，用命令DATA发送</li>
<li>以“.”号表示结束并将内容一起发出去，结束此次发送，用QUIT命令退出</li>
</ol>
</li>
</ol>


<h2>ICMP协议</h2>

<ol>
<li>ICMP是Internet控制报文协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令，这个ping的过程实际上就是ICMP协议工作的过程。Ping命令利用ICMP回射请求报文和回射应答报文来测试目标系统是否可达。</li>
<li>执行ping后，首先向目标服务器发出回送请求报文。计算机送出的回送请求到达目标服务器后，服务器回答这一请求，向送信方发送回送请求。这个ICMP回送回答报文在IP层来看，与被送来的回送请求报文基本上一样。不同的只是，源和目标IP地址字段被交换了，类型字段里填入了表示回送回答的0，这两点，也就是，从送信方式来看，自己送出的ICMP报文从目标服务器哪里像鹦鹉学舌那样原样返回了</li>
</ol>


<h2>Http协议</h2>

<ol>
<li>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。</li>
<li>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</li>
<li>请求报文格式如下：请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体</li>
<li>应答报文格式如下：状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</li>
<li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF</li>
<li>请求方法有多种：

<ol>
<li>GET 请求获取Request-URI所标识的资源</li>
<li>POST 在Request-URI所标识的资源后附加新的数据</li>
</ol>
</li>
<li>状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF 其中Status-Code标识服务器发回的响应状态代码；Reason-Phrase标识状态代码的文本描述</li>
<li>状态码有三位数字组成，第一个数字定义了响应的类别，且有5种可能取值：

<ol>
<li>1xx：指示信息，标识请求已接收，继续处理</li>
<li>2xx：成功，标识请求已被成功接收、理解、接受</li>
<li>3xx：重定向，要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误，请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误，服务器位能实现合法的请求</li>
</ol>
</li>
<li>常见状态码、状态描述、说明

<ol>
<li>200 OK 客户端请求成功</li>
<li>400 Bad Request 客户端请求有语法错误，不能被服务器理解</li>
<li>401 Unauthorized 请求未经授权，这个状态码必须和WW-Authenticate报文域一起使用</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found 请求资源不存在</li>
<li>500 Internal Server Error 服务器发生不可预期的错误</li>
<li>503 Server Unavaliable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ol>
</li>
<li>普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。

<ol>
<li>Cache-Control用于指定缓存指令，缓存指令是单向的，而且是独立的。

<ul>
<li>请求时的缓存指令包括：no-cache(用于指示请求或响应消息不能缓存)、no-store、max-age、max-stale、min-fresh、only-if-cached</li>
<li>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage</li>
</ul>
</li>
<li>Date普通报头域表示消息产生的日期和时间</li>
<li>Connection普通报头域允许发送指定连接的选项，例如指定连接是连续或者指定“close”选项，通知服务器，在响应完成后，关闭连接。在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</li>
</ol>
</li>
<li>请求报头允许客户端向服务器传递请求的附加信息以及客户端自身的信息，常用的请求报头：

<ol>
<li>Accept：用于指定客户端接收哪些类型的信息，Accept:image/gif表明客户端希望接收GIF图像格式的资源；Accept:text/html表明客户端希望接收html文本</li>
<li>Accept-Charset：用于指定客户端接受的字符集，如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受</li>
<li>Accept-Encoding：指定可接受的内容编码</li>
<li>Accept-Language：指定一种自然语言</li>
<li>Authorization：用于证明客户端有权查看某个资源，当浏览器访问一个页面时，如果收到服务器的响应代码为401，可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证</li>
<li>Host:发送请求是，该报头域是必须的，主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回</li>
<li>User-Agent：该请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器，不过，这个报头域不是必须的，如果我们自己编写一个浏览器，不适用User-Agent请求报头域，那么服务器端就无法得知我们的信息了</li>
</ol>
</li>
<li>请求报头举例：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>GET /form.html HTTP/1.1 (CRLF)
</span><span class='line'>Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)
</span><span class='line'>Accept-Language:zh-cn (CRLF)
</span><span class='line'>Accept-Encoding:gzip,deflate (CRLF)
</span><span class='line'>If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)
</span><span class='line'>If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)
</span><span class='line'>User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)
</span><span class='line'>Host:www.guet.edu.cn (CRLF)
</span><span class='line'>Connection:Keep-Alive (CRLF)
</span><span class='line'>(CRLF)
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>响应报头允许服务器传递不能放在状态行中的附件响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息；常用的响应报头：

<ol>
<li>Location用于重定向接收者到一个新的位置，Location响应报头域常用在更换域名的时候</li>
<li>Server包含了服务器用来处理请求的软件信息，与User-Agent请求报头域是相对应的</li>
<li>WWW-Authenticate响应报头域西粗被包含在401响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时候，服务端响应报头就包含该报头域</li>
</ol>
</li>
<li>实体报头。请求和响应消息都可以传送一个实体，一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。常用的实体报头：

<ol>
<li>Content-Encoding：被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip</li>
<li>Content-Language：实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:da</li>
<li>Content-Length：实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示</li>
<li>Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型</li>
<li>Last-Modified：实体报头域用于指示资源的最后修改日期和时间</li>
<li>Expires：实体报头域给出响应过期的日期和时间。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0</li>
</ol>
</li>
<li>HTTP协议通常是承载于TCP洗衣之上的，有时也承载于TLS或SSL协议层之上，这时称之为HTTPS协议。默认HTTP的端口号为80，HTTPS的端口号为443</li>
<li><img src="http://i.imgur.com/PiBPPM0.png" alt="HTTP请求报文" /></li>
<li><img src="http://i.imgur.com/EZ63EEL.png" alt="HTTP响应报文" /></li>
<li>GET与POST方法有以下区别：

<ol>
<li>Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</li>
<li>在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交</li>
<li>GET方式提交的数据最多只能有1024字节，而POST则没有此限制</li>
</ol>
</li>
</ol>


<h2>NetBIOS</h2>

<p><img src="http://i.imgur.com/OAHwfCG.png" alt="NetBIOS实现过程" /></p>

<ol>
<li>NetBIOS协议是一种在局域网上的程序可以使用的应用程序编程接口，为v横须提供了请求低级服务的统一的命令集，作用是为了给局域网提供网络以及其他特殊功能，几乎所有的局域网都是在NetBIOS协议的基础上工作的。NetBIOS协议，简单来说就是通过访问设备名称就可以实现对IP地址的访问。</li>
<li>在Windows操作系统中，默认情况下在安装TCP/IP协议后会自动安装NetBIOS协议。</li>
<li>ping主机名的第一个数据包就是NBNS(NetBIOS Name Server)协议包，它是TCP/IP上的NetBIOS协议族的一部分，它在基于NetBIOS名称访问的网络上提供主机名和地址映射方法。NBNS是动态DNS的一种。Microsoft的NBNS实现称为WINS。NetBIOS的报文类型较多，结构复杂，在不同的网络化境和不同的用途中会使用不同的报文，可用端口进行区分。如图所示NetBIOS协议架构
<img src="http://i.imgur.com/MxZkqby.jpg" alt="NetBIOS协议架构" /></li>
<li>NetBIOS数据报有很多不同格式，主要取决于服务和信息类型，以及用以传送NetBIOS数据报的传输协议。NetBIOS协议架构包含三种基本服务：NAME、SESSION和DATAGRAM，其中NAME所用协议就是NBNS协议</li>
<li>WINS协议使用的报文即为NetBIOS的名字报文，其总体格式如下图所示
<img src="http://i.imgur.com/i2pWvfO.png" alt="NetBIOS名字报文格式" />其中2字节通用标志中更详细的字段划分为：操作代码(5bits)操作标志(7bits)结果代码(4bits)

<ol>
<li>事物ID：请求方为每次名字服务请求所设定的ID值，响应方在相应的响应报文中要填入这个事物ID值</li>
<li>操作代码：指示报文的类型,最高位为0表示数据包为Reauest请求，最高位为1表示数据包为Response应答，其余4个比特均为0</li>
<li>操作标志：操作标志位，最低位为1表示广播或者多播，最低位为0表示单播，其他位均为0</li>
<li>结果代码：在相应报文中指示请求的结果，一般为0</li>
<li>问题记录个数：请求查询问题的个数，对于Request数据包，该值为1，对于Response数据包，该值为0</li>
<li>回答记录个数：对于Response数据包有用，Response数据包中响应问题的个数，一般为1</li>
<li>权威记录个数：在权威记录部分的记录数量，用不到的时候为0</li>
<li>附加记录个数：在附加记录部分数量，用不到的时候为0</li>
</ol>
</li>
<li>报文的前12字节总称NetBIOS名字报文的首部，通过首部可以判断是否为名字查询的报文。NetBIOS名字报文中最常见的是携带问题记录的报文，问题记录的格式是：问题名称(若干字节) 问题类型(2字节) 问题类别(2字节)。通过携带问题记录的报文，我们可以得到要查询的名字字符，如果和本机名相符，就发送报文响应，相应中带有IP地址，发送广播的主机就会得到该IP地址</li>
<li>NETBIOS会话报文具有通用的4字节首部和与类型相关的报文内容：类型(1字节) 标志(1字节) 长度(2字节) 内容(若干字节)

<ol>
<li>类型：指名NetBIOS会话报文的类型，可用的值有：

<ul>
<li>0x00:会话消息</li>
<li>0x81:会话请求</li>
<li>0x82:正面会话响应</li>
<li>0x83:负面会话响应</li>
<li>0x84:重定向会话响应</li>
<li>0x85:会话保活</li>
</ul>
</li>
<li>标志：0~6位保留未用，第7位作为扩展的长度位，使NetBIOS会话报文的内容部分最多可以达到128K字节</li>
<li>长度：NetBIOS会话报文的内容部分的长度，不包括首部的4字节</li>
</ol>
</li>
<li><img src="http://i.imgur.com/O24egoi.png" alt="NBNS" />计算机1向计算机2的137端口发送一个NODE STATUS REQUEST请求数据包，计算机2收到该数据包后，向计算机1返回一个NODE STATUS RESPONSE响应数据包，该数据包中包含计算机2的MAC地址、机器地址、所属的工作组等信息</li>
<li>NODE STATUS REQUEST数据包由12字节的HEADER域和38字节的QUESTION ENTRIES域两个部分组成，HEADER域分为8个字段：
<img src="http://i.imgur.com/VKpTVaA.png" alt="NetBIOS HEADER" /></li>
<li>QUESTION ENTRIES域组成
<img src="http://i.imgur.com/93RGC0D.png" alt="QUESTION ENTRIES" />其中：

<ul>
<li>QUESTION_NAME为要查询的远程计算机的名称，长度为34字节。NBNS规定，计算机NetBIOS的名称不超过16字节，且最后一个字节必须为0x0；</li>
<li>QUESTION_TYPE对于REQUEST数据包取值为0x0021</li>
<li>QUESTION_CLASS取值为0x0001</li>
</ul>
</li>
<li>当某台机器的137端口收到NODE STATUS REQUEST请求数据包之后，由该机器的NETBIOS服务随即生成并返回一个NODE STATUS RESPONSE响应数据包。该响应数据包由HEADER域和RESOURCE RECORD域两部分组成。RESOURCE RECORD域组成如图所示：
<img src="http://i.imgur.com/IPEjagx.png" alt="RESOURCE RECORD" />

<ul>
<li>RP_NAME：34字节，与Request数据包的QUESTION_NAME格式定义相同</li>
<li>RP_TYPE：与Request数据包中的QUESTION_TYPE字段相同</li>
<li>RP_CLASS：与前面Request数据包的QUESTION_CLASS字段取值相同</li>
<li>TTL：4字节，取值为0x00000000</li>
<li>RDLENGTH:表示从NUM_NAMES字段开始到整个RESOURCE RECORD结束共有多少个字节</li>
<li>NUM_NAMES：表示紧随其后的NODE_NAME ARRAY数组的元素个数，数组的每个元素具有NODE_NAME结构，如图所示为NODE_NAME结构：
<img src="http://i.imgur.com/ArSP1Xp.png" alt="NODE_NAME" /></li>
<li>NETBIOS FORMAT NAME表示远程主机的机器名或者组名，具体依赖NAME_FLAG字段的取值；</li>
<li>NAME_FLAGs：当最高位为1时，NETBIOS FORMAT NAME字段中存储的是Group NetBIOS名称，即工作组名，当最高位为0时，NETBIOS FORMAT NAMR字段中存储的是机器名</li>
<li>STATICS：包含的字段非常多，开始6字节是远程主机的MAC地址</li>
</ul>
</li>
</ol>


<h2>SNTP协议</h2>

<ol>
<li>SNTP是简单网络时间协议，是用来使设备时间同步化的一种协议，在一些应用场合里，时间同步时十分重要的，贴别是随着设备运行时间增长，时间误差就越来越大，因为设备中晶振自身会产生误差，那么SNTP协议就可以解决这个问题。</li>
<li>报文格式：<img src="http://i.imgur.com/y9GprbA.gif" alt="SNTP报文格式" />

<ul>
<li>LI: 跳跃指示器</li>
<li>VN：版本号</li>
<li>Mode：模式

<ul>
<li>0——预留</li>
<li>1——对称行为</li>
<li>3——客户机</li>
<li>4——服务器</li>
<li>5——广播</li>
<li>6——NTP控制信息</li>
</ul>
</li>
<li>Stratum：对本地时钟级别的整体识别</li>
<li>Poll：有符号整数表示连续信息间的最大间隔</li>
<li>Precision：有符号整数表示本地时钟精确度</li>
<li>Root Delay：有符号固定点序号表示主要参考源的总延迟，很短时间内的位15到16间的分段点</li>
<li>Root Dispersion：无符号固定点序号表示相对主要参考源的正常差错，很短时间内的位15到16间的分段点</li>
<li>Reference Identifier：识别特殊参考源</li>
<li>Originate Timestamp：这是向服务器请求分离客户机的时间，采用64位时标格式</li>
<li>Receive Timestamp：这是向服务器请求到达客户机的时间，采用64位时标格式</li>
<li>Transmit Timestamp：这是客户机答复分离服务器的时间，采用64位时标格式</li>
<li>Authenticator：当实现了NTP认证模式主要标识符和信息数字域就包括已定义的信息认证代码信息</li>
</ul>
</li>
<li>原理图：<img src="http://i.imgur.com/kKI2sUY.png" alt="SNTP原理示意图" /></li>
</ol>


<h2>TFTP协议</h2>

<ol>
<li>TFTP是TCP/IP协议族中的而一个用来在客户机和服务器之间进行简单文件传输的协议，基于UDP协议实现，端口号为69.</li>
<li>TFTP是专为小文件喜欢书设计的，提供不复杂、开销小的文件传输服务，缺乏标准FTP协议的许多特征。</li>
<li>TFTP只能从远程服务器上读、写文件或者读写文件传送给远程服务器。它不能列出目录并且当前不提供用户认证</li>
<li>TFTP有3中传输模式：

<ol>
<li>netASCII模式即8位网络ASCII码</li>
<li>octet即八位组模式</li>
<li>邮件模式，这种模式现在已经废弃不用了</li>
</ol>
</li>
<li>TFTP数据包结构
<img src="http://i.imgur.com/eQqDEd2.png" alt="TFTP报文格式" /></li>
<li>操作码

<ul>
<li>1=RRQ，读请求，由客户端使用，用来建立一条从服务器读数据的连接</li>
<li>2=WRQ，写请求，由客户端使用，用来建立一条把数据写到服务器的连接，它的格式与RRQ相同</li>
<li>3=data</li>
<li>4=ACK</li>
<li>5-error</li>
</ul>
</li>
<li>Filename（文件名字段）说明客户要读或写的位于服务器上的文件，文件名是NETASCII码字符，以0结束。</li>
<li>Mode（模式字段）是一个ASCII码串netASCII或octet，同样以0字节结束。netASCII表示数据是以成行的ASCII码字符组成，以两个字节一回车字符后跟换行符。OCTET模式用于传输文件，这种文件在源机上以8位格式存储。在使用MAIL模式时，用户可以在FILE处使用接收人的地址，这个地址可以是用户名或@主机的形式，如果是后一种形式，允许主机使用电子邮件传输此文件。如果使用MAIL类型，包必须以WRQ开始，否则它与NETASCII完全一样</li>
<li>DATA数据包还包括一个数据块号和数据，数据块号域从1开始编码，每个数据块加1，这样接收方可以确定这个包是新数据还是已经接收过的数据。数据域从0字节到512字节。如果数据域是512字节，则它不是最后一个包，如果小于512字节则表示这个包是最后一个包。如果最后一个包正好512字节，则再发送一个0字节的包用于表示结束</li>
<li>ACK包用于确认数据包以手法哦。当接收方收到一个数据包后，回享发送方发送一个ACK包，而发行方则会在收到一个ACK包后继续发送下一个包。若发送完未能收到ACK包，则会使用超时机制，重新发送刚才的数据包。除了ACK和用于中断的包外，其他的包均需得到确认。发出新的数据包等于确认上次的包。WRQ和DATA包由ACK或ERROR数据包确认，而RRQ数据包由DATA或ERROR数据包确认</li>
<li>ERROR数据包可以被其他任何类型的包确认，错误码指定错误的类型，它用于服务器不能处理读请求或者写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。差错编号字段给出一个数字的差错码，跟着是一个ASCII表示的差错报文字段，可能包含额外的操作系统说明

<ul>
<li>1：文件未找到</li>
<li>2：访问非法</li>
<li>3：磁盘满或超过分配的配额</li>
<li>4：非法的TFTP操作</li>
<li>5：位置的传输ID</li>
<li>6：文件已经存在</li>
<li>7：没有类似的用户</li>
</ul>
</li>
<li>通信流程：任何一个传输进程都以WRQ或者RRQ开始，收到一个确定应答并建立一个连接。创建连接时候，通信双方随机选择一个TID，因为是随机选择，因此两次选择同一个ID的可能性就很小了。每个包包括两个TID，发送者ID和接收者ID。这些ID用于在UDP通信时选择端口，在第一次请求的时候它会将请求发到TID 69，也就是服务器的69端口上，应答时，服务器使用一个选择好的TID作为源TID，并用上一个包中的TID作为目的ID进行发送。这两个被选择的ID在随后的通信中会被一直使用。连接成功后文件就以固定的512字节块的长度进行发送。每个数据包都包含一个数据块，块号从1开始而且是连续的。因此对于写入请求的确定是一个比较特殊的情况，因此它的包的包号是0.再发送下一个包之前，数据块必须得到确认响应包的确认。如果一个数据包的大小小于512字节，则表明传输结束。如果包在网络中丢失，接收端就会在超市以后重新传输最后一个未被确认的数据包，这就是导致丢失包的发送者重新发送丢失包。通信的双方都是数据的发出者与接收者，一方传输数据接收应答，另一方发出应答接收数据。发送者需要保留一个包在手头用于重新发送，由LOCk确认响应保证所有过去的包都已收到。大部分的错误会导致连接中断，错误由一个错误的数据包引起。这个包不会被确认，也不会被重新发送，因此另一方无法接收到。如果错误包丢失，则使用超时机制。错误主要由下面三种情况引起的：不能满足请求，收到的数据包内容错误，对需要资源的访问丢失。TFTP只有在一种情况下不中断连接，这种情况是源端口号不正确，在这种情况下，指示错误的包会被发送到源机。这个协议限制很多，这都是为了实现起来比较方便而进行的。
<img src="http://i.imgur.com/A8vhQRY.jpg" alt="TFTP通信流程" /></li>
<li>TFTP的工作过程很想停止等待协议，发送完一个文件块后就等待对方的确认，确认时应指名所确认的块号。发送完数据后在规定的时间内收不到确认就要重发数据PDU（协议数据单元），发送确认PDU的一方若在规定时间内收不到下一个文件块，也要重发确认PDU。这样保证文件传送不致因某一个数据报的丢失而告失败</li>
</ol>


<h2>FTP协议</h2>

<ol>
<li>FTP（File Transfer Protocol，文件传输协议），用于Internet上的控制文件的双向传输</li>
<li>FTP协议使用TCP端口中的20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是是否使用20作为传输数据的端口与FTP使用的传输模式相关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器和客户端协商决定</li>
<li>FTP支持两种模式，一种方式叫做Standard（也就是PORT方式，主动方式），一种是Passive（也就是PASV，被动方式）。Standard模式，FTP的客户端发送PORT命令到FTP服务器，Psaaive模式下FTP的客户端发送PASV命令到FTP Server

<ol>
<li>Port

<ul>
<li>FTP客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务端通过自己的TCP 20端口连接至客户端的指定端口发送数据。FTP server必须和客户端建立一个新的连接用来传送数据</li>
</ul>
</li>
<li>Passive

<ul>
<li>在建立控制通道的时候和Standard模式类似，但建立连接以后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接</li>
</ul>
</li>
</ol>
</li>
<li>很多防火墙在设置的时候是不允许接收外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作</li>
<li>传输方式：

<ol>
<li>ASCII传输

<ul>
<li>假定用户正在拷贝的文件包含简单的ASCII码文本，如果在远程机器上运行的是不同的操作系统，当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，他们可能是程序、数据库，字处理文件或者压缩文件。在拷贝任何非文本文件之前，用binary命令告诉ftp逐字拷贝，不要对这些文件进行处理，即使用二进制传输方式</li>
</ul>
</li>
<li>二进制传输

<ul>
<li>在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。计时目的机器上包含位序列的文件时没有意义的。如果在ASCII方式下传输二进制文件，即使不需要也仍会转译。这会使传输稍微变慢，也会损坏数据，是文件变得不能使用。（在大多数计算机上，ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。）
<img src="http://i.imgur.com/8EpzUrL.jpg" alt="FTP连接" /></li>
</ul>
</li>
</ol>
</li>
<li>一般来讲，控制连接一直保持到客户-服务器连接的全过程，但数据连接可以根据需要随时开启和结束。而通用的传输方式是流方式，并且文件结尾是以关闭数据连接为标志。这意味着对每一个文件传输或目录列表来说都要建立一个全新的数据连接</li>
<li>一个典型的主动方式的过程：

<ol>
<li>客户端打开一个随机的端口（端口号大于1024，这里记为x），同时一个FTP进程连接至服务器的21号命令端口。此时，源端口为客户端随机端口x，远程端口为服务器21.正是由于客户端发出命令要求建立数据连接，所以数据连接是在客户的控制下建立的</li>
<li>客户通常在客户端主机上为所在的数据连接端选择一个临时端口号。客户从该端口发布一个被动的打开</li>
<li>客户使用PORT命令从控制连接上把端口号法相服务器</li>
<li>服务器在控制连接上接收端口号，并向客户端主机上的端口发布一个主动的打开。服务器的数据连接端一直使用端口20</li>
</ol>
</li>
<li>命令处理

<ol>
<li>接入命令：USER、PASS、ACCT、REIN、QUIT、ABOR</li>
<li>文件管理命令：CWD、CDUP、DELE、LIST、NLIST、MKD、PWD、RMD、RNFR、RNTO和SMNT</li>
<li>数据格式化命令：TYPE、STUR、MODE</li>
<li>端口定义命令：PORT、PASV</li>
<li>文件传送命令：RETR、STOR、APPE、STOU、ALLO、REST、STAT</li>
<li>杂项命令：HELP、NOOP、SITE、SYST</li>
</ol>
</li>
<li>每个FTP命令至少产生一个响应，响应有两个部分：三位数字的树以及紧随后面的正文，数字部分定义代码，正文部分定义所需要的参数和额外的解释。第一位数字定义命令的状态，第二位数字定义命令的意义，第三位数字提供附加信息</li>
<li>当数据通过数据流传输时，控制流处于空闲状态。而当控制流空闲很长时间后，客户端的防火墙会将其会话置为超时，这样当大量数据通过防火墙时，会产生一些问题。此时，虽然文件可以成功传输，但因为控制会话会被防火墙断开，传输会产生一些错误</li>
<li>主动模式

<ol>
<li>客户端打开一个随机的端口（端口号大于1024，这里称x），同时一个FTP进程连接至服务器的21号命令端口，此时，源端口为随机端口x，在客户端，远程端口为21，在服务器</li>
<li>客户端开始监听端口(x+1),同时向服务器发送一个端口命令（通过服务器的21号命令端口），此命令告诉服务器客户端正在监听的端口号并且已准备好从此端口号接收数据。这个端口号就是我们所知的数据端口</li>
<li>服务器打开20号源端口并且建立和客户端数据端口的链接。此时源端口为20，远程数据端口为（x+1）</li>
<li>客户端通过本地的数据端口建立一个和服务器20号端口的链接，然后向服务器发送一个应答，告诉服务器它已经建立好了一个连接</li>
</ol>
</li>
<li>被动模式

<ol>
<li>在被动方式FTP中，命令链接和数据连接都是由客户端发起，这样就可以解决从服务器到客户端的数据端口的入向链接被防火墙过滤掉的问题</li>
<li>当开启一个FTP连接时，客户端打开两个任意的非特权本地端口（N>1024和N+1）。第一个端口连接服务器的21端口，但与主动方式的FTP不同，客户端不会提交PORT命令并允许服务器来回连它的数据端口，而是提交PASV命令。这样做的结果是服务器会开启一个任意的非特权端口（P>1024），并发送PORT命令给客户端。然后客户端发起从本地端口N+1到服务器端口P的连接用来传送数据</li>
<li>对于服务器端的防火墙来说，必须允许下面的通讯才能支持被动方式的FTP：

<ol>
<li>从任何大于1024的端口到服务器的21端口（客户端的初始化连接）</li>
<li>服务器的21端口到任何大于1024的端口（服务器响应到客户端的控制端口的连接）</li>
<li>从任何大于1024端口到服务器的大于1024端口（客户端初始化数据连接到服务器指定的任意端口）</li>
<li>服务器的大于1024端口到远程的大于1024的端口（服务器发送ACK响应和数据到客户端的数据端口）</li>
</ol>
</li>
</ol>
</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-08-17T09:50:48+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/msp430f5529/'>msp430f5529</a>, <a class='category' href='/blog/categories/w5500/'>w5500</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/27/cadence-allegro/">
		
			Cadence-Allegro</a>
	</h2>
	<div class="entry-content">
		<h2>Cadence简介</h2>

<ol>
<li>Cadence公司著名的软件有Cadence Allegro（布局布线设计工具），Cadence LDV，Cadence IC，Cadence OrCAD等</li>
<li>整个软件系统主要功能模块：

<ol>
<li>Design Entry HDL：提供了一个原理图输入和分析环境</li>
<li>Design Entry CIS：是Cadence收钩原OrCAD公司的产品，是国际上通用的标准的原理图输入工具，与Allegro实现了无缝连接</li>
<li>Design Entry HDL Rules Checker：Design Entry HDL的规则检查工具</li>
<li>Library Explorer：进行数字设计库管理的软件，可以调用Design Entry HDL、PCB Librarian、PCB Designer、Allegro System Architect等工具建立的元件符号和模型</li>
<li>Package Designer：芯片和封装的设计分析软件</li>
<li>PCB Editor：高性能PCB设计软件</li>
<li>PCB Librairan：Allegro库开发</li>
<li>PCB Router：CCT布线器</li>
<li>PCB SI：提供一个集成的高速设计与分析环境</li>
<li>Physical Viewer：Allegro浏览器模块</li>
<li>Project Manager：Design Entry HDL的项目管理器</li>
<li>AMS Simulator：工业标准的模拟、数字及模拟/数字混合信号仿真系统</li>
<li>PCB Editor Utilities：包含Pad Designer、DB Doctor和Bach DRC等工具</li>
</ol>
</li>
</ol>


<h2>快捷键</h2>

<ol>
<li>原理图编辑：

<ol>
<li>原理图放大：I，或者Ctrl+滚轮向上滚</li>
<li>原理图缩小：O，或者Ctrl+滚动向下</li>
<li>原理图向上走：PGUP</li>
<li>原理图向下走：PGDN</li>
<li>原理图向左走：Ctrl+PGUP</li>
<li>原理图向右走：Ctrl+PGDN</li>
<li>元器件旋转，变换方向：R</li>
<li>元器件复制拖动：Ctrl+拖动</li>
<li>元器件更新：

<ol>
<li>replace：元起价信息包括封装全部更新</li>
<li>update：只会更新元器件基本细心，封装信息不会更新</li>
</ol>
</li>
</ol>
</li>
<li>SCH库编辑：

<ol>
<li>进入下一个分片元件的编辑：Ctrl+N</li>
<li>返回上一个分片元件的编辑：Ctrl+B</li>
</ol>
</li>
</ol>


<h2>补充知识</h2>

<ol>
<li>0.1inch = 2.54mm</li>
<li>总线的命名：Basename[0:len-1]表示总线名Basename，位长len</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-27T21:55:59+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cadence/'>cadence</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/22/tl-wr740n/">
		
			TL-WR740N刷机救砖指南</a>
	</h2>
	<div class="entry-content">
		<h2>型号</h2>

<blockquote><p>Flash：4MB，DRAM：32MB，CPU：AR7240，Baud：115200</p></blockquote>

<h2>固件下载</h2>

<p><a href="http://www.dd-wrt.com/site/support/router-database">下载地址</a></p>

<h2>TTL刷机命令</h2>

<ol>
<li>上电连续输入TPL三个字母知道进入uboot界面停住</li>
<li>tftpdboot 0x80000000 [固件名称]</li>
<li>erase 0x9f020000 +0x3c0000</li>
<li>cp.b 0x80000 0x9f020000 0x3c0000</li>
<li>bootm 0x9f020000</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-22T09:51:38+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">

</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/20/linux-kernel/">
		
			Linux_Kernel</a>
	</h2>
	<div class="entry-content">
		<h2>内核make流程</h2>

<ol>
<li>make %config和make menuconfig的目的是为了生成.config文件，而Kconfig作为生成make menuconfig等图形配置界面工具而存在</li>
<li>.config 文件中决定了内核中的哪些代码被编译进内核，哪些代码被当做模块编译</li>
<li>make根据.config中的描述，通过解析Makefile文件来进行编译，最终生成zImage文件</li>
<li>流程中设计的文件与命令，再加上Linux内核的scripts目录构成了内核的Kbuild机制，内核通过这种方式，最终编译得到内核镜像文件zImage</li>
</ol>


<h2>KBuild机制实现原理</h2>

<ol>
<li>从编译过程来看，每一个被编译的目录下都会生成一个build-in.o文件，他们都由自己目录下的源代码编译生成，所有目录下的build-in.o文件最终链接生成vmlinux文件，最后由内核压缩程序加工vmlinux生成内核压缩镜像文件zImage</li>
<li>总原理来看，Kbuild机制只会把obj-y的值编译进内核。每个Makefile文件中都有这个变量，只不过obj-后面一半都跟着一个变量，这个变量的值来自于.config。</li>
<li>待编译目录下的Makefile，如有Kbuild，则Kbuild优先，唯一使用Kbuild而不是Makefile的就是顶层目录</li>
</ol>


<h2>Kconfig语法</h2>

<ol>
<li>config

<ul>
<li>为menu或者choice中的一个选项条目</li>
<li>config后面常跟一个变量名，比如ARM，那么在.config中将以CONFIG_ARM=y或n的形式出现</li>
<li>下一行写该变量的取值类型,可以是bool,tristate,string,hex,int</li>
<li>default为变量缺省值，可以被用户设置值覆盖</li>
<li>prompt后边是出现在配置菜单中的对应于一个配置选项的文字，没有prompt条目，将使得用户不能在配置界面中显示并配置该配置选项</li>
<li>depends on var表示该变量必须在var被设置的情况下才能进行设置，否则取值为n，即使default为y</li>
<li>select var表示它将影响到变量var，使得var至少应该配置为y或者m</li>
<li>help中的文字将作为配置界面中的帮助信息</li>
</ul>
</li>
<li>menu

<ul>
<li>在menu和endmenu中间可配置若干config条目</li>
</ul>
</li>
<li>choice

<ul>
<li>在choice和endchoice之间可定义若干config条目。choice中的config条目只能有2种类型：bool或者tristate，且不能同时有这两种变量。对于bool型变量只能在多个选择中选择1个为y；对于tristate型变量，要么将多个设置为m，要么仅将1个设为y，其余为n。</li>
</ul>
</li>
<li>comment

<ul>
<li>用于定于帮助信息，将出现在配置界面的第一行，并且还会出现在配置文件.config中作为注释</li>
</ul>
</li>
<li>source

<ul>
<li>由于内核源代码中大多数目录下都有各自的Kconfig文件，因此需要一种手段将所有的Kconfig文件组织为一个整体。这就是source的功能，它用于引入另一个Kconfig文件，有点类似于C语言中的#include</li>
</ul>
</li>
</ol>


<h2>Makefile文件精解</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#如果CONFIG_ATL1=y，将递归进入本目录的子目录atl1，并根据该子目录下的Makefile文件的内容决定该子目录如何继续拧编译，否则将不进入本目录的子目录atl1进行编译</span>
</span><span class='line'><span class="n">obj</span><span class="o">-</span><span class="err">$</span><span class="p">(</span><span class="n">CONFIG_ATL1</span><span class="p">)</span> <span class="o">+=</span> <span class="n">atl1</span><span class="o">/</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#如果.config中变量CONFIG_GIANFAR=y，那么将变异本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar)sysfa.c文件并将其功能集成进zImage；如果.config文件中变量CONFIG_GIANFAR=m，那么将编译本目录下的gianfar.c,gianfar_ethtool.c,gianfar_mii.c,gianfar_sysfs.c文件生成模块gianfar.ko；否则将编译gianfar.c,gianfar_ethtool.c</span>
</span><span class='line'><span class="n">gianfar_mii</span><span class="p">.</span><span class="n">c</span><span class="p">,</span><span class="n">gianfar_sysfa</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="n">obj</span><span class="o">-</span><span class="err">$</span><span class="p">(</span><span class="n">CONFIG_GIANFAR</span><span class="p">)</span> <span class="o">+=</span> <span class="n">gianfar_driver</span><span class="p">.</span><span class="n">o</span>
</span><span class='line'><span class="n">gianfar_driver</span><span class="o">-</span><span class="nl">objs</span> <span class="p">:</span><span class="o">=</span> <span class="n">gianfar</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_ethtool</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_mii</span><span class="p">.</span><span class="n">o</span>\
</span><span class='line'>                      <span class="n">gianfar_sysfs</span><span class="p">.</span><span class="n">o</span>
</span></code></pre></td></tr></table></div></figure>


<h2>zImage文件生成过程</h2>

<ol>
<li>内核代码首先被编译生成vmlinux，放在Linux源码的顶层目录下</li>
<li>这个vmlinux可执行文件又通过arm-linux-objcopy命令转化为二进制代码文件Image（放在arch/arm/boot目录下），其实这个Image文件才是真是的内核代码文件，因为这个文件会比较大，所以内核会对它做压缩处理</li>
<li>为了最大化减小Image的体积，内核调用gzip工具吧Image压缩成piggy.gz文件</li>
<li>为了让内核具有自引导功能，在arch/arm/boot/compressed目录下有head.o,misc.o两个文件构成解压和自引导代码，而让真实的piggy.gz文件也参与编译，最终生成了梁歪一个vmlinux文件，放在arch/arm/boot/compressed目录下，并最终调用arm-linux-objcopy生成二进制文件zImage。</li>
<li>综上，zImage文件由arch/arm/boot/compressed目录下的head.S和misc.c文件（自解压程序）+内核真实代码文件组成</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-20T23:30:54+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/kernel/'>kernel</a>, <a class='category' href='/blog/categories/linux/'>linux</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/20/cpp-knowledges/">
		
			CPP-Knowledges</a>
	</h2>
	<div class="entry-content">
		<h2>流</h2>

<ol>
<li>标准C++中，iostream中常见的操作算子(manipulator):flush,endl,oct(后面跟的数据解析成八进制)，hex(后面跟的数解析成十六进制)，dec(后面跟的数解析成十进制)，boolalpha(后面跟的数据解析成布尔类型，并用true和false来显示)，showpos(后面跟的数据显示正负号)，fixed(后面跟的数不要四舍五入),noshowpos(后面跟的数如果是正数就显示+号),showpoint(后面跟的数据显示小数点)，scientific(后面跟的数据以科学计数法的形式表示);在Qt中附加的一些操作算子：forcesign(后面的数据显示正负号),forcepoint(后面的数据显示小数点),noforcesign(后面的数据如果是正数就不显示+号)</li>
<li>标准C++的iostream中，getline(cin,your_string)语句能够从标准输入流中提取一行字符串</li>
<li>在Qt中很容易用与iostream对应的同一个名称定义QTextStream，由于控制台输入和输出主要用在调试过程，所以Qt提供了一个全局函数qDebug(),用它可以方便地将消息发送到控制台，且具有灵活的接口</li>
<li>流被用来读取/写入文件、连接网络和处理字符串，它有一个有用的特性是易于从混合数据类型中得到字符串。</li>
<li>STL中的字符串流：std::ostringstream,常用来定义一个string_buffer;</li>
<li>STL中的文件流std::ofstream,用来定义一个文件流管道如ofstream outf后绑定一个文件：outf.open(&ldquo;file path&rdquo;)</li>
<li>STL中的输入文件流std::ifstream,打开文件instream inf;inf.open(&ldquo;file path&rdquo;),判断是否读到了文件末尾inf.eof(),读取一行数据getline(inf,newstr)</li>
<li>STL中的stringstream对应于Qt里面的QString，STL中的fstream对应于Qt里面的QFile，STL中的iostream对应于Qt中的QTextStream</li>
</ol>


<h2>运算符new和delete</h2>

<ul>
<li>new运算符从堆(heap)中分配内存空间，并且返回指向新分配的对象的指针，如果由于某种原因无法完成内存分配，就会抛出一个异常</li>
<li>delete运算符的作用是释放动态分配的内存并将其返回给堆。delete操作只能用于由new运算符返回的指针或者空指针。</li>
</ul>


<h2>智能指针</h2>

<ul>
<li>智能指针是一个对象，它用来保存和管理指向堆对象的指针，其行为与常规的指针非常类似，只是它会在合适的时刻自动删除堆对象。这个类在Qt中对应的是QPointer，在标准库中是std::auto_ptr,在Boost中是shared_ptr</li>
</ul>


<h2>引用</h2>

<ul>
<li>在C++中，引用提供了一种给左值赋予一个别名的机制，对于避免费事或者不必要的复制引用是非常有用的，例如向函数传送一个非常大的对象作为参数。<strong>引用必须在声明时进行初始化且其初始化器也必须是一个左值</strong>,例如：<code>int n;int&amp; rn=n;</code>引用变量rn是实际变量n的别名</li>
<li>一种好的编程实践是：对于不需要通过函数来进行变化的指针和引用参数，应使用const来保护它们。只读引用参数的能力在于：对按引用传递参数提供了高效性，而对按值传递参数提供了安全性</li>
</ul>


<h2>类的友元</h2>

<ul>
<li>友元机制允许非成员函数访问一个类的私有数据，关键字friend可以放在类的生命或者函数声明之前，友元声明位于类定义之内</li>
<li>通常而言，为了达到下面两个目的才会使用友元函数：

<ol>
<li>为了使用工厂方法，此时需要对某个类强制实施某些创建规则</li>
<li>为了使用全局运算符函数，比如operator&lt;&lt;()和operator>>()，此时不希望将运算符作为某个类的成员函数，或者没有写入类定义的权利</li>
</ol>
</li>
</ul>


<h2>运算符重载</h2>

<ol>
<li>C++使用关键字operator为运算符赋予新的含义</li>
<li>例如重载&lt;&lt;运算符：friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const Complex&amp; c);</li>
</ol>


<h2>define与inline的区别</h2>

<blockquote><ol>
<li>对#define宏的替换过程是由预处理器处理的，预处理器本质上是一个文本编辑器。对inline函数的替换过程是由编译器处理的，它会执行更智能的操作，进行正确的类型检查</li>
<li>inline函数必须在调用之前<strong>定义</strong></li>
<li>在一个源代码模块中只能有一次inline定义</li>
</ol>
</blockquote>

<h2>带变长实参表的函数</h2>

<blockquote><ol>
<li>在C和C++中，可以定义其参数表以省略号结尾的函数。省略号使调用者能够制定参数的数量以及类型。</li>
<li>为了定义使用省略号的函数，需要包含cstdarg库</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">double</span> <span class="nf">mean</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">...){</span>
</span><span class='line'>  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>               <span class="cm">/*ap执行第一个未命名实参*/</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>      <span class="n">sum</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span><span class="kt">double</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>                 <span class="cm">/*返回之前清除栈*/</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sum</span><span class="o">/</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>预处理宏主要应用场合</h2>

<blockquote><ol>
<li>使用#ifndef/#define/#endif将头文件包裹起来，以避免多次包含某个头文件</li>
<li>使用#ifdef/#else/#endif对某些代码部分进行条件编译</li>
<li><strong>FILE</strong>宏和<strong>LINE</strong>宏用于调试并给出框架信息</li>
</ol>
</blockquote>

<h2>C++中的多态性</h2>

<blockquote><ol>
<li>C++源于C语言，它的编译器也试图在编译时绑定函数调用，这主要是基于性能方面的考虑。编译器无法仅凭集成关系和基类指针就确定它正在操作何种对象。如果没有运行时检查，就无法保证运行时调用正确的函数。C++要求使用一个特殊的关键字来允许运行时通过指针和引用进行函数调用的绑定，这个关键字就是virtual，它能够使得程序具有多态性。</li>
<li>由于this是在执行它的构造函数时被初始化的，在执行它的析构函数的时候被销毁，因此不要指望在这两种条件下能够执行正确的运行时绑定。当在构造函数或者析构函数里面调用任何this方法时，将由编译时绑定决定应该调用哪一个方法，就好像不存在virtual关键字一样。</li>
<li>一般而言，如果类中包含一个或者多个virtual函数，则也应包含一个虚析构函数。这是因为，当对对台对象集合进行操作时，通常是通过基类指针删除这些对象，这会导致对析构函数的间接调用，如果析构函数不为virtual类型，在编译时绑定将决定应该调用哪一个析构函数，从而可能导致派生对象的不完整析构</li>
<li>静态成员函数不能使虚函数；内敛函数不能是虚函数；构造函数不能是虚函数</li>
</ol>
</blockquote>

<h2>虚函数实现原理</h2>

<blockquote><ol>
<li>父类中如果有虚函数存在，编译器就会为该对象创建一个虚函数表，里面存放自己的虚函数的指针。</li>
<li>子类继承父类，编译器也会为子类创建一个不同的虚函数表，存放子类自己的虚函数指针</li>
<li>拥有虚函数表的类都会另外创建一个指向该表的指针</li>
<li>所以当父类指针指向子类对象，调用虚函数的时候就会根据子类对象的虚函数表调用得到子类的虚函数，而不是父类的虚函数</li>
<li>如果没有在子类中定义与父类同名的虚函数，那么就会在子类的虚函数表中就会写上父类的相应的虚函数的函数入口地址；如果在子类中也定义了同名的虚函数，那么在虚函数表中用子类的虚函数的函数地址覆盖掉父类的相应的虚函数的函数地址</li>
<li>每个类只有一份虚函数表，所有该类的对象共用同一张虚函数表</li>
<li>只有函数声明没有函数定义的虚函数也是纯虚函数</li>
</ol>
</blockquote>

<h2>纯virtual函数的声明</h2>

<blockquote><ol>
<li>virtual returnType functionName(parameterList)=0;</li>
<li>抽象基类中至少要有一个virtual函数</li>
<li>抽象基类中不能有public的构造函数</li>
<li>抽象基类的任何具体派生类都必须重写并定义全部的纯virtual基类函数，话句话说，任何没有重写并定义全部纯virtual基类函数的派生类都是抽象类</li>
</ol>
</blockquote>

<h2>重载，隐藏与重写</h2>

<blockquote><ol>
<li>当函数foo在同一个作用域内存在两个或者多个版本(具有不同的签名)时，就称foo函数被<strong>重载</strong>了</li>
<li>当基类中的一个virtual函数在培生累中也存在，并且他们具有相同的签名和返回类型时，就称派生类中的版本“重写”了基类中的版本</li>
<li>派生类中的成员函数，会隐藏基类中与之同名的全部函数，如果出现这种情况，则：

<ul>
<li>只有派生类函数可以被直接调用</li>
<li>类作用域解析运算符::西部用来显式地调用基类函数</li>
</ul>
</li>
</ol>
</blockquote>

<h2>有三种特殊的成员函数从来不会被继承，编译器会为没有定义它们的类自动生成这三种函数</h2>

<ol>
<li>拷贝构造函数：类名（const 类名&amp; 变量名）</li>
<li>复制赋值运算符</li>
<li>析构函数</li>
</ol>


<h2>构造函数</h2>

<blockquote><p>如果一个类没有构造函数，那么编译器就会自动产生一个默认的public构造函数，而这个构造函数会调用它的每一个基类的默认构造函数。如果某个类有一些构造函数但是没有默认构造函数，那么它就不会进行默认的初始化工作，这种情况下，任何派生类构造函数都必须在其初始化列表中明确地指名应该调用哪一个基类构造函数</p></blockquote>

<h2>类的前置声明</h2>

<blockquote><ol>
<li>类的前置声明将它的名称声明成一个有效的类名称，但不给出类的定义。这会使得类名称能够被用作<strong>指针</strong>和<strong>引用</strong>的类型，在遇到类的定义之前，不会将这些指针和引用进行解引操作。</li>
<li><strong>如果可以使用前置声明，就不要使用#include指令</strong></li>
</ol>
</blockquote>

<h2>范型与模板</h2>

<blockquote><p>1.模板为C++编译器提供了一个途径，能够为带有参数化类型和相同行为的类和函数生成多个版本。模板使用关键字template以及用尖括号&lt;>包围的模板参数进行区分。与函数参数不同，模板参数不仅可以传递变量和值，还可以传递类型表达式。例如：template <class T,int max> Buffer{T v[max];}
2. 每当编译器看到一个特定参数类型的组合首次用于一个模板函数时，就称此模板进行了实例化。
3. 类模板主要用来生成数据的通用容器，其参数能够指名容器中的内容。所有的Qt容器类以及标准模板库(STL)中的所有容器类都是参数化的。
4. 所有模板的定义(类和函数)都必须出现在头文件中，这是因为编译器需要用这些定义来根据模板声明生成代码</p></blockquote>

<h2>其他</h2>

<ul>
<li>C++中使用struct的大多数情形是需要将数据项分组在一起，但是不需要成员函数</li>
<li>const成员函数中不允许对数据成员进行修改，如果修改，编译器将报错，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误。注意可以在const成员函数里面更改可变成员(mutable member)的值，而常规的数据成员的值不能改变</li>
<li>类内定义的成员函数编译器会优先编译成内联(inline)函数</li>
<li>初始化列表优先于构造函数执行.初始化列表只能用于构造函数,初始化列表可以同时初始化多个数据成员</li>
<li>const数据成员的初始化必须写在初始化列表中</li>
<li>M_PI来自于&lt;math.h>,它位于cstdlib库中</li>
<li>foreach()宏需要赋值它所遍历的容器，这就要求使用foreach必须要有拷贝构造函数</li>
<li>C++类型可以分成两类：值类型和对象类型，值类型的有Anything*，int，char，QString，QDate和QVariant。带有共有默认构造函数、拷贝构造函数和复制赋值运算符的任何类型都是值类型</li>
<li>C++对于没有数据成员的类在实例化的时候会分配1个内存单元(1Byte)，用于标记该对象的存在</li>
<li>含有纯虚函数的类叫做抽象类,抽象类无法实例化对象</li>
<li></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-20T09:42:10+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c-plus-plus/'>c++</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/19/qt4-knowldegs/">
		
			QT4知识点</a>
	</h2>
	<div class="entry-content">
		<h2>Qt核心模块</h2>

<p>Qt是一个大库，由数个较小的库或者模块组成，其中最为常见的有如下这些，除了core和gui，其余模块都需要在qmake的工程文件中启用：</p>

<ol>
<li>core：包括QObject，QThread，QFile，Qvariant等等</li>
<li>gui：所有从QWidget派生的类外加一些相关的类</li>
<li>xml：用于解析和序列化XML</li>
<li>sql：用于与SQL数据库通信</li>
<li>phonon：用于播放多媒体文件</li>
<li>webkit：用于使用一种嵌入式web浏览器，QtWebkit</li>
</ol>


<h2>工程文件.pro</h2>

<ol>
<li>对于Qt程序，程序不必编写Makefile文件，Qt提供了一个qmake工具，它会根据工程文件来产生对应的Makefile文件。亦可以用qmake -project命令产生一个简单的工程文件，当执行这个命令的时候，qmake会将当前工作目录下的全部源文件(<em>.cpp)作为SOURCES列出来，而将该目录下的全部头文件(</em>.h)作为HEADERS列出来。最终生成的可执行文件的名称由TARGET变量指定，其默认为工程的名称</li>
<li>TEMPLATE=app，表明qmake应该以一个适合建立这个应用的模板化的Makefile开始，如果这个工程文件用于建立库，则应当使用语句TEMPLATE=lib，以表明应使用Makefile库模板。第三种可能是源代码文件分布在多个子目录下，而每一个子目录下的文件都具有自己的工程文件，这种情况下，位于父目录的工程文件中应该包含语句TMPLATE=subdirs，这会导致在父目录和每一个子目录下都生成Malefile</li>
<li>添加库：LIBS += -Lpathtolibs</li>
<li>CONFIG += console表示是控制台程序</li>
<li>当编写并测试完库之后，在编译链接过程结束后它将被安装到由qmake变量DESTDIR指定的目录下。例如，dataobjects库的工程文件包含如下相关的行：

<ul>
<li>TEMPLATE = lib</li>
<li>DESTDIR = pathto_install_libs</li>
</ul>
</li>
<li>对于库模板，qmake将产生一个包含install目标的Makefile，这样，在成功编译链接之后执行命令make install将会把这个库复制到某个特定的位置</li>
</ol>


<h2>Qt中获取命令行参数</h2>

<ul>
<li>QCoreApplication app(argc,argv);</li>
<li>QStringList arglist = app.arguments();</li>
<li>arglist.size等于命令行参数的个数</li>
</ul>


<h2>Qt中的字符串</h2>

<ol>
<li>const char*，主要用于与C语言库的接口</li>
<li>来自C++标准库的string，任何地方都可以使用这种类型</li>
<li>QString，优于STL中的字符串类型，有着更加丰富的API而且更加容易使用。</li>
<li>在Qt中使用类似于iostream中的cin，cout：

<ul>
<li><h1>include &lt;QString></h1></li>
<li><h1>include &lt;QTextStream></h1></li>
<li>QTextStream cout(stdout)</li>
<li>QTextStream cin(stdin)</li>
<li>cin.readLine()</li>
</ul>
</li>
<li>sizeof(QString)=4,sizeof(QChar)=2,sizeof(QDate)=4,sizeof(qint32)=4,sizeof(qint64)=8;QString是一个使用动态内存的复杂类，因此必须调用length()来获得字符串中QChar的数量。由于QChar的大小为char的两倍，所以在计算内存中QString中实际大小时需要将长度乘以2，在运行时，QString能够与具有同一个值的另一个字符串共享内存</li>
</ol>


<h2>去掉最大、最小、关闭按钮</h2>

<blockquote><p>setWindowFlags(windowFlags()|Qt::FramelessWindowHint|Qt::WindowTitleHint);</p></blockquote>

<h2>使用中文</h2>

<blockquote><ol>
<li>下载qpf格式的font_wenquanyi字体，将下载的字库文件复制到qt安装目录的lib/fonts子目录下</li>
</ol>
</blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\#include &lt;QTextCodec&gt;
</span><span class='line'>  QApplication a(argc, argv);
</span><span class='line'>    QTextCodec::setCodecForLocale(QTextCodec::codecForName("UTF-8"));     //中文支持
</span><span class='line'>    QTextCodec::setCodecForTr(QTextCodec::codecForName("UTF-8"));       //支持Tr中文
</span><span class='line'>    QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8")); //支持中文文件名显示
</span><span class='line'>    QFont font;
</span><span class='line'>    font.setPointSize(160);                                           //实际上是16的字号，但设成16却不行
</span><span class='line'>    font.setFamily(("wenquanyi"));
</span><span class='line'>    font.setBold(false);
</span><span class='line'>    a.setFont(font);</span></code></pre></td></tr></table></div></figure>


<h2>隐藏鼠标箭头</h2>

<blockquote><ol>
<li>对于整个程序: QApplication::setOverrideCursor(Qt::BlankCursor);</li>
<li>对单个控件：lable->setCursor(Qt::BlankCursor);//隐藏鼠标  label->setCursor(Qt::ArrowCursor);//显示正常鼠标</li>
</ol>
</blockquote>

<h2>QStringList与迭代</h2>

<blockquote><ol>
<li>QStringList实际上就是一个QList<QString>,此外，QStringList还具有一些特别针对字符串的方便函数，例如indexOf(),join()和replaceInStrings()。利用split()函数和join()函数，在列表与字符串之间进行转换相当简单</li>
<li>QStringList对象可以调用方法takeFirst()来依次获得列表中的字符串对象</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QString</span> <span class="n">winter</span> <span class="o">=</span> <span class="s">&quot;December,January,February&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">QString</span> <span class="n">spring</span> <span class="o">=</span> <span class="s">&quot;March,April,May&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">QString</span> <span class="n">summer</span> <span class="o">=</span> <span class="s">&quot;June,July,August&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">QString</span> <span class="n">fall</span> <span class="o">=</span> <span class="s">&quot;September,October,November&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">QStringList</span> <span class="n">list</span><span class="p">;</span>
</span><span class='line'><span class="n">list</span> <span class="o">&lt;&lt;</span> <span class="n">winter</span><span class="p">;</span>
</span><span class='line'><span class="n">list</span> <span class="o">+=</span> <span class="n">spring</span><span class="p">;</span>
</span><span class='line'><span class="n">list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">summer</span><span class="p">);</span>
</span><span class='line'><span class="n">list</span> <span class="o">&lt;&lt;</span> <span class="n">fall</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">QString</span> <span class="n">allmonths</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">);</span>  <span class="cm">/*从列表到字符串，以逗号为分隔符*/</span>
</span><span class='line'><span class="n">QStringList</span> <span class="n">list2</span> <span class="o">=</span> <span class="n">allmonths</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">);</span> <span class="cm">/*从字符串到列表，以逗号为分隔符*/</span>
</span><span class='line'>
</span><span class='line'><span class="n">foreach</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span><span class="n">list</span><span class="p">){</span> <span class="cm">/*Qt foreach循环*/</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">QStringList</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">){</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">QListIterator</span><span class="o">&lt;</span><span class="n">QString</span><span class="o">&gt;</span> <span class="n">itr</span><span class="p">(</span><span class="n">list2</span><span class="p">);</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">itr</span><span class="p">.</span><span class="n">hasNext</span><span class="p">()){</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">current</span> <span class="o">=</span> <span class="n">itr</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QDir，QFileInfo和QDirIterator</h2>

<figure class='code'><figcaption><span>利用QDir类和QFileInfo类获取目录的内容列表以及关于每一个项的信息</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">void</span> <span class="nf">recurseAddDir</span><span class="p">(</span><span class="n">QDir</span> <span class="n">d</span><span class="p">,</span><span class="kt">bool</span> <span class="n">recursive</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span><span class="kt">bool</span> <span class="n">symlinks</span><span class="o">=</span><span class="nb">false</span><span class="p">){</span>
</span><span class='line'>  <span class="n">d</span><span class="p">.</span><span class="n">setSorting</span><span class="p">(</span><span class="n">QDir</span><span class="o">::</span><span class="n">Name</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QDir</span><span class="o">::</span><span class="n">Filters</span> <span class="n">df</span> <span class="o">=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">Files</span> <span class="o">|</span> <span class="n">QDir</span><span class="o">::</span><span class="n">NoDotAndDotDot</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span> <span class="n">df</span> <span class="o">|=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">Dirs</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">not</span> <span class="n">symlinks</span><span class="p">)</span> <span class="n">df</span> <span class="o">|=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">NoSymLinks</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QStringList</span> <span class="n">qsl</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">entryList</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">QDir</span><span class="o">::</span><span class="n">Name</span><span class="o">|</span><span class="n">QDir</span><span class="o">::</span><span class="n">DirsFirst</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">foreach</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span><span class="n">qsl</span><span class="p">){</span>
</span><span class='line'>      <span class="n">QFileInfo</span> <span class="n">finfo</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">isDir</span><span class="p">()){</span>
</span><span class='line'>          <span class="n">QDir</span> <span class="n">sd</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">absoluteFilePath</span><span class="p">());</span>
</span><span class='line'>          <span class="n">recurseAddDir</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>          <span class="k">if</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">completeSuffix</span><span class="p">()</span><span class="o">==</span><span class="s">&quot;mp3&quot;</span><span class="p">){</span>
</span><span class='line'>              <span class="n">addMp3File</span><span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">absoluteFilePath</span><span class="p">());</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>使用QDirIterator实现相同功能</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QDir</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">QDir</span><span class="o">::</span><span class="n">current</span><span class="p">();</span>
</span><span class='line'><span class="n">QDirIterator</span> <span class="nf">qdi</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="n">absolutePath</span><span class="p">(),</span> <span class="n">QStringList</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*.mp3&quot;</span><span class="p">,</span> <span class="n">QDir</span><span class="o">::</span><span class="n">NoSymLinks</span> <span class="o">|</span> <span class="n">QDir</span><span class="o">::</span><span class="n">Files</span><span class="p">,</span> <span class="n">QDirIterator</span><span class="o">::</span><span class="n">Subdirectories</span><span class="p">);</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">qdi</span><span class="p">.</span><span class="n">hasNext</span><span class="p">){</span>
</span><span class='line'>  <span class="n">addMp3File</span><span class="p">(</span><span class="n">qdi</span><span class="p">.</span><span class="n">next</span><span class="p">());</span>
</span><span class='line'>  <span class="c1">//TODO</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QDate</h2>

<blockquote><ol>
<li>static QDate currentDate = QDate::currentDate();</li>
</ol>
</blockquote>

<h2>Qt中字符串的数据流操作</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QString</span> <span class="n">Student</span><span class="o">::</span><span class="n">toString</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">retval</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QTextStream</span> <span class="nf">os</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>
</span><span class='line'>  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;name:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_Name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;;ID:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_StudentID</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>`</p>

<h2>qDeleteAll(container)只对包含指针的容器有意义，该函数将释放所有对象，但并不删除容器中的指针；删除容器中的指针需要调用容器的clear()函数</h2>

<h2>容器（Qt容器被定义成模板类）</h2>

<blockquote><ol>
<li>QList<T>是用数组实现的，数组的两端都有预分配的空间。它针对按索引的随机访问以及少于1000项的列表进行了优化。对于prepend()和append()这样的操作，它有很好的性能表现</li>
<li>QStringList是派生自QList<QString>的一个便利类</li>
<li>QLinkedList<T>针对迭代器的顺序访问以及快速、常量时间的列表插入操作进行了优化，但排序和搜索比较缓慢。它提供多个便利函数来处理那些经常用到的操作
QVector<T>以连续的内存位置保存数据，并针对按索引的随机访问进行了优化。通常而言，QVector对象都是用其初始大小进行构造的，在其两端都不存在预先自动分配的内存空间，所以中间掺入、末端插入以及前端插入都是耗时的</li>
<li>QStack<T>是派生自QVector<T>的public类，所以QVector类的public接口可以用于QStack对象。不过，push(),pop()以及top()函数采用的是后入先出(LIFO)的语法</li>
<li>QMap&lt;Key,T>是一个有序的关联容器，它保存的是键/值对，其作用是根据键来快速找到对应的值。它也被设计成支持适量的快速插入操作和删除操作。它将键有序排列，以便能够快速搜索和快速缩小搜索范围，采用的是一个跳跃列表字典，这个字典在概率上是平衡的并且高效的利用了内存。键的类型必须是operator&lt;()和operator==()</li>
<li>QHash&lt;Key,T>也是一个关联容器，它使用哈希表来进行键的查找。它提供快速的查找(键精确匹配)和插入操作，但其搜索速度较慢，且没有排序功能。键的类型必须是operator==()</li>
<li>QMultiMap&lt;Key,T>是QMap的一个子类，而QMultiHash&lt;Key,T>是QHash的一个子类。这两个类是的一个键可以与多个值关联</li>
<li>QCache&lt;Key,T>是一个关联容器，它对最近使用过的项提供最快速的访问，并会根据几个开销函数的结果自动移除哪些不常用的项</li>
<li>QSet<T>用QHash保存T类型的值，QHash中的键位于T中，而其中的哑值与每一个键相关联。这种安排可优化查找和插入操作。QSet中的几个函数用于常规的集合操作。它的默认构造函数会创建一个空集合</li>
</ol>


<p><strong>用于模板容器类的类型参数T，或者用于关联容器的键类型都必须为可赋值数据类型，即值类型。这意味着T必须具有public类型的默认构造函数、拷贝构造函数和赋值运算符。基本类例如int，double，char和指针都是可赋值的，有些Qt类型是可赋值的，例如QString，QDate，QTime。QObject以及派生自QObject的类型都是不可赋值的，如果需要使用某种不可赋值类型的对象，则可以定义一个指针容器，例如QList&lt;QFile*></strong></p></blockquote>

<h2>QFile</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QFile</span> <span class="nf">outf</span><span class="p">((</span><span class="s">&quot;filename&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">outf</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>
</span><span class='line'><span class="n">QTextStream</span> <span class="nf">outstr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outf</span><span class="p">);</span>
</span><span class='line'><span class="n">outstr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;content&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">outf</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>序列化器模式：QTextStream和QDataStream</h2>

<blockquote><ol>
<li>序列化器是一种只负责读取或者写入对象的对象，Qt的QTextStream序列化器用于读写人可读的文件，而QDataStream序列化器用于读写结构化的二进制数据。这些类都是用序列化器模式实现的</li>
<li>利用QDataStream就可以序列化和解序列化QVariant支持的全部类型，包括QList，QMap，QVector以及其他类型。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QFile</span> <span class="nf">textFile</span><span class="p">(</span><span class="s">&quot;playlist1.tsv&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QFile</span> <span class="nf">binaryFile</span><span class="p">(</span><span class="s">&quot;playlist1.bin&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">QTextStream</span> <span class="n">textStream</span><span class="err">；</span>
</span><span class='line'><span class="n">QDataStream</span> <span class="n">dataStream</span><span class="err">；</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">textFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">)){</span>
</span><span class='line'>  <span class="n">textStream</span><span class="p">.</span><span class="n">setDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">textFile</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">binaryFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">)){</span>
</span><span class='line'>  <span class="n">dataStream</span><span class="p">.</span><span class="n">setDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binaryFile</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">QList</span><span class="o">&lt;</span><span class="n">MetaDataValue</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">textStream</span><span class="p">.</span><span class="n">atEnd</span><span class="p">()){</span>
</span><span class='line'>  <span class="n">MetaDataValue</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'>  <span class="n">textStream</span> <span class="o">&gt;&gt;</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'>  <span class="n">values</span> <span class="o">&lt;&lt;</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dataStream</span> <span class="o">&lt;&lt;</span> <span class="n">mdv</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QObject</h2>

<blockquote><ol>
<li>QObject是Qt库中许多重要的类的基类，如QEvent，QApplication，QLayout和QWidget。</li>
<li>QObject使基于事件的编程成为了可能，其中用到了QApplication和Qt的事件循环</li>
<li>QObject没有公有的拷贝构造函数或复制赋值运算符。QObject类定义的结尾处有一个宏Q_DISABLE_COPY(QObject)，它显示地确保任何QObject都不能被复制。QObject不是设计用于复制的，QObject会用来代表具有唯一身份的对象。这种不带拷贝构造函数策略的一个直接后果就是永远无法通过值传递方式向函数传递OBject。</li>
<li>QObject及其派生类的单参数构造函数应当予以显式声明explicit，以免意外的隐式转换的发生。</li>
<li>每个QObject都可以有（至多）一个父QObject，且可以拥有任意数量的子QObject。</li>
<li>每个QObject都将指向各个子对象的指针存放在一个QObjectList中，在调用QObject的析构函数时会自动销毁该对象的子对象</li>
<li>通常而言，没有父对象的QObject应当在程序栈区(stack)中进行定义，而那些有父对象的QObject则应当在堆区(heap)动态创建出来，这样可有助于确保发生正确的析构操作。</li>
<li>QObject有一个成员函数，可以返回一个指向主对象中全部子对象的指针列表：const QObjeectList&amp; QObject::children() const</li>
<li>QObject还提供了两个名称为findChildren()的重载(递归)每个都会返回一个满足特定条件的子对象列表：QList<T> parentObj.findChildren<T>(const QString&amp; name=QString()) const 该函数返回一个类型为T的子对象列表，其对象名与name相等。如果name是空字符串，那么将会起到一个类过滤器的作用，返回结果是一个QList，其中包含指向全部子对象的指针，而这些子对象都可以通过类型转换变成类型T的对象</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QList</span><span class="o">&lt;</span><span class="n">Customer</span><span class="o">*&gt;</span> <span class="n">custlist</span> <span class="o">=</span> <span class="n">parent</span><span class="p">.</span><span class="n">findChildren</span><span class="o">&lt;</span><span class="n">Customer</span><span class="o">*&gt;</span><span class="p">();</span>
</span><span class='line'><span class="n">foreach</span> <span class="p">(</span><span class="k">const</span> <span class="n">Customer</span><span class="o">*</span> <span class="n">current</span><span class="p">,</span><span class="n">custlist</span><span class="p">){</span>
</span><span class='line'>  <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QEvent</h2>

<blockquote><ol>
<li>QEvent类封装了底层事件的概念。QEvent类是若干特定事件类的基类，例如QActionEvent,QFileOpenEvent,QHoverEvent,QInputEvent,QMouseEvent等。QEvent对象可以由窗口系统创建以响应用户的动作(例如，QMouseEvent)或按照指定的时间间隔(QTimerEvent)完成创建，也可以由应用程序显式地创建。成员type()会返回一个美剧，其中含有近百个特定的值，以区分不同种类的各式事件(例如,关闭、DragEnter、DragMove、放下、输入、GrabMouse、HoverEnter、KeyPress、MouseButtonDblClick、MouseMove、Resize)</li>
<li>一个典型的Qt程序会创建对象，连接各个对象，然后再告诉应用程序开始发送exec()，在运行时，应用程序就进入了事件循环，各个对象之间可以通过各种方式相互发送消息。</li>
<li>只有在事件循环，特别是QApplication::exec()进入的事件循环中，信号才能发送到槽上。这是因为信号和槽在其外表之下是使用事件循环来传递消息的。</li>
<li>QObject支持一些普通C++对象通常没有的特性：信号和槽，元对象、元属性、元方法，qobject_cast</li>
<li>元对象编辑器，即moc，会针对每个使用Q_OBJECT宏的QObject派生类生成额外的函数，生成的代码可以在名称为moc_filename.cpp的文件中找到。</li>
</ol>
</blockquote>

<h2>信号和槽</h2>

<blockquote><ol>
<li>信号是在类定义中给出的类似于void函数声明的一种消息。它有参数列表却没有函数体。信号时一个类的接口的一部分，它看起来想函数，但不用同样的方式进行调用&mdash;它被此类的对象发射</li>
<li>槽通常是一个void成员函数，它可以像普通的成员函数一样进行调用，或者可以由QMetaObject系统进行间接调用</li>
<li>连接语句的语法：bool QObject::connect(senderQObjectPtr,SIGNAL(signalName(argumentList)),receiverQObjectPtr,SLOT(slotName(argumentList))optionalConnectionType);optionalConnectionType让你可以明确说明，你是否希望从发射点处同步(阻塞)或者非同步(排队)地调用目标槽</li>
<li>如果有多个信号连接到同一个槽上且需要知道是那哟个QPbject发射的信号，则可以在该槽中调用sender(),它会返回一个指向那个对象的指针</li>
</ol>
</blockquote>

<h2>堆还是栈</h2>

<blockquote><p>一般情况下，没有父对象的QObject应当在栈上创建，或者定义成另一个类的子对象。有父对象的QObject不应该在栈上创建，因为那样的话，它有可能会被删除两次。
不推荐直接删除QObject，在带有事件循环的程序中，最好利用QObject::deleteLater()来删除QObject。这样做，可以在应用程序处理事件并在当前槽返回之后就安排该对象的销毁。希望能够在槽内删除信号的sender(),这么做实际上是必须的</p></blockquote>

<h2>QWidget和其余GUI开发中常用的类</h2>

<blockquote><ol>
<li>QWidget是一个采用了多重继承的类，首先，QWidget是一个QObject，因此它可以有父对象、信号、槽以及可受管理的子对象。同时QWidget也是一个QPaintDevice，这个类是所有可在屏幕上进行绘制的对象的基类</li>
<li>Qt数据类型——QPoint,QSize,QColor,QImage和QPixmap是在处理图形对象时常用到的类型</li>
<li>布局——这些类能够动态地管理Widget的布局，其中有些事常用的特殊布局，包括QHBoxLayout，QVBoxLayout，QGridLayout，QFormLayout等</li>
<li>模型——QAbstractItemModel及其各个派生类，如QAbstractListModel和QAbstractTableModel，外加一些已有的可继承实体类，如QSqlQueryModel和QFileSystemModel，都是Qt模型/视图框架中的一部分，该框架内置将一个模型和其他不同视图相连接的机制，以便对一个组件的修改可以自动变换到其他组件上</li>
<li>控制类——QApplication和QAction两者都是管理GUI应用程序控制流的对象。QItemDelegate用作模型和视图之间的控制器</li>
</ol>
</blockquote>

<h2>对话框</h2>

<blockquote><ol>
<li>QDialog是Qt所有对话框的基类。对话框窗口可以是模态(modal)对话框也可以是非模态(nonmodal)对话框。</li>
<li>当程序调用静态的便利函数"QMessageBox::&ldquo;或者"QFileDialog::"时，弹出的对话框就是模态对话框。当模态对话框显示在屏幕上时，它会冻结同一应用程序中的其他所有可见窗口的输入功能。用户解除模态对话框后，与应用程序的常规交互才可以继续下去。QDialog::exec()是将模态对话框放到屏幕上的另一种方式。当用户完成了所需的响应后，对话框就可以返回数据，也可以返回对话框代码(QDialog::Accepted或者QDialog::Rejected);</li>
<li>可以像QWidget一样通过show()显示一个QDialog，在此情况下，对话框是非模态的，用户也就可以与应用程序的其他窗口继续交互。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QApplication</span> <span class="nf">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">);</span>
</span><span class='line'><span class="n">QProgressDialog</span> <span class="n">nonModal</span><span class="p">;</span>
</span><span class='line'><span class="n">nonModal</span><span class="p">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s">&quot;Non Modal Parent Dialog&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">nonModal</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
</span><span class='line'><span class="n">nonModal</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nonModal</span><span class="p">,</span><span class="n">SIGNAL</span><span class="p">(</span><span class="n">finished</span><span class="p">()),</span><span class="o">&amp;</span><span class="n">app</span><span class="p">,</span><span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>图标、图像与资源</h2>

<blockquote><ol>
<li>Qt提供了至少两种方式来获得标准的图标。一种方式来自于桌面样式的QStyle::standardIcon()，另一种则来自插件型图标主题:QIcon::fromTheme()</li>
<li>把所需的二进制数据文件作为资源附加到工程中会让工程更为健壮。源代码无须为资源文件使用一些不可移植的路径名。要引用一个存储成资源的文件，可以使用在.rcc文件中指定的别名并在前面带一个前缀":/&ldquo;。于是，每个资源好像位于一个私有虚文件系统中，其根为&rdquo;:/&ldquo;。然而，得到这些好处是需要付出代价的，可执行文件会更大，程序也会需要更多的内存</li>
<li>有3个Qt类可以简化处理图片：

<ul>
<li>QImage——用于离屏操作，输入输出操作，并可直接访问像素</li>
<li>QPixmap——用于在屏幕上进行绘制并优化，仅用在主线程中</li>
<li>QIcon——用于视频内存的缓冲且经常用到，但仅用在主线程中</li>
<li>QPicture——存储绘制的操作而不是实际的位图图片</li>
</ul>
</li>
</ol>
</blockquote>

<h2>布局</h2>

<blockquote><ol>
<li>布局可以将它们的Widgets排列成如下几种形式：

<ul>
<li>垂直型(QVBoxLayout)</li>
<li>水平型(QHBoxLayout)</li>
<li>网格型(QGridLayout)</li>
<li>窗体型(QFormLayout)</li>
<li>栈型，任何时候都只有一个窗件可见(QStackedLayout)</li>
</ul>
</li>
<li>可以使用addWidget()函数向QLayout添加窗件，当窗件添加到布局中时，它会称为拥有该布局的窗件的子对象。窗件永远不会称为布局的子对象</li>
<li>为了能够顺利地管理其几何形状，每个QLayout对象都必须有一个父对象，这可以是一个QWidget，也可以是一个QLayout。可以在创建布局时通过向构造函数传递一个指向父窗件或者布局的指针来指定其父对象。当然，也可以先创建一个QLayout而不指定QLayout的父对象，这种情况下，可以稍后通过调用QWidget::addLayout()来指定其父对象</li>
<li>布局可以拥有子布局，通过调用addLayout()函数，可以将一个布局添加为另外一个布局的子布局。如果布局的父对象是一个窗件，那么该窗件将再也无法称为另外一个布局的父对象</li>
<li>不使用Qt设计师时，可以使用QLayout类的API来直接指定各个窗件之间的分割、伸展和支撑

<ul>
<li>addSpacing(int size)会向布局的末尾添加固定数量的像素</li>
<li>addStretch(int stretch = 0)会添加数目不定的像素。此函数由一个最小的数目开始，然后逐渐扩展到使用所有的可用空间。如果在同一个布局中进行多次扩展，可以用此作为一个增长因子</li>
<li>addStrut(int size)讲给处置方向施加一个最小的数值(也就是，QVBoxLayout的宽度或者QHBoxLayout的高度)</li>
</ul>
</li>
</ol>
</blockquote>

<h2>QTimer</h2>

<blockquote><ol>
<li>QTimer对象是一个倒数计时器，以毫秒级时间间隔启动，当其到达零时会发出一个timeout()信号.QTimer可用来以规则的间隔来发射信号，或者如果singleShot属性已设置成true，则在给定的时间间隔后仅发射一次信号。QTimer有一个静态函数singleShot()，可以在给定的时间间隔后调用一次槽。如果倒数间隔设置成0，QTimer会在事件队列中的全部事件处理完后就立刻发出timeout()信号</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QTimer</span><span class="o">::</span><span class="n">singleShot</span><span class="p">(</span><span class="n">m_expInterval</span><span class="p">,</span><span class="n">this</span><span class="p">,</span><span class="n">SLOT</span><span class="p">(</span><span class="n">timerDisplayRandStr</span><span class="p">()));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>绘制事件和画图</h2>

<blockquote><ol>
<li>一个Widget应当在其paintEvent()方法中执行适当的绘制操作。这是QWidget中唯一可以创建QPainter painter(this)的地方。有下面几个原因使得QPaintEvent可以被发送到QWidget上。

<ol>
<li>窗件是隐藏的，然后又显露了出来</li>
<li>窗件改变了大小或者进行了重新排布</li>
<li>调用了update()或者repaint()。repaint()在paintEvent()得到调用后才会返回。update()在QPaintEvent被放进事件队列后会立即返回</li>
</ol>
</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">void</span> <span class="n">LifeWidget</span><span class="o">::</span><span class="n">paintEvent</span><span class="p">(</span><span class="n">QPaintEvent</span><span class="o">*</span> <span class="n">evt</span><span class="p">){</span>
</span><span class='line'>  <span class="n">QPainter</span> <span class="n">painter</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m_image</span><span class="p">.</span><span class="n">isNull</span><span class="p">()){</span>
</span><span class='line'>      <span class="n">painter</span><span class="p">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">QPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">m_image</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QMainWindow</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">class</span> <span class="nl">MyMainWindow</span><span class="p">:</span><span class="n">public</span> <span class="n">QMainWindow</span><span class="p">{</span>
</span><span class='line'>  <span class="n">Q_OBJECT</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>  <span class="n">explicit</span> <span class="n">MyMainWindow</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">parent</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">closeEvent</span><span class="p">(</span><span class="n">QCloseEvent</span><span class="o">*</span> <span class="n">event</span><span class="p">);</span>
</span><span class='line'><span class="n">protected</span> <span class="nl">slots</span><span class="p">:</span>
</span><span class='line'>  <span class="n">virtual</span> <span class="kt">void</span> <span class="n">newFile</span><span class="p">();</span>
</span><span class='line'>  <span class="n">virtual</span> <span class="kt">void</span> <span class="nf">open</span><span class="p">();</span>
</span><span class='line'>  <span class="n">virtual</span> <span class="kt">bool</span> <span class="nf">save</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QAction</h2>

<blockquote><ol>
<li>QAction从QObject派生而来，是用于用户选定动作的一个基类。它提供了丰富的接口，它还可以用于许多种动作中。QWidget接口使得每个窗件都可以维护一个QList&lt;QAction*>。所有QWidget都可以拥有QAction，一些窗件借助上下文提供了QAction的清单，其他借助菜单栏。</li>
<li>QMenu是一个能够给QAction集合提供特殊视图的QWidget。QMenuBar是菜单的一个集合，常见于QMainWindow中。</li>
<li>每次调用QMenu::addAction(text,target,slot,shortcut)函数，都会窗件一个未命名的QAction，并且会将其添加到这个QMenu上。然后会调用它的积累函数，QWidget::addAction(QAction*),这样把新建的QAction添加到用于上下文菜单的QMenu的QAction清单中。</li>
</ol>
</blockquote>

<h2>QSettings</h2>

<blockquote><ol>
<li>QSettings会管理键/值对的永久映射关系，它是一个QObject，并且会使用一些与QObject相似的属性接口——setValue()和value()——来设置和获取它的值。这个类可以用来存储任何需要在多次执行之间进行记忆的数据</li>
<li>QSettings需要一个组织名和一个应用程序名，但当使用默认的构造函数时，QSettings会从QApplication中获得这些值。每个名称组合都会定义一个唯一的永久映射，这使得不会与其他命名的Qt应用程序产生冲突</li>
<li>允许多个实例共享相同状态的类，可以看成是Monodtate模式的一种实现。拥有相同组织/应用程序名称的两个QSettings实例，可以访问同一个永久映射数据。这简化了应用程序从不同源文件访问公共设置值的过程。QSettings是Monostate模式的一种实现</li>
</ol>
</blockquote>

<h2>剪切板</h2>

<blockquote><ol>
<li>每个Qt应用程序都可以使用qApp->clipboard()访问系统的剪贴板。剪贴板会保存带类型的数据(文本，图片，URL或者自定义数据)。要往剪贴板中放置数据，可以创建一个QMimeData，以一定的方式对数据进行编码，并且调用QClipBoard->setMimeData()。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">connect</span><span class="p">(</span><span class="n">qApp</span><span class="o">-&gt;</span><span class="n">clipboard</span><span class="p">(),</span><span class="n">SIGNAL</span><span class="p">(</span><span class="n">changed</span><span class="p">(</span><span class="n">QClipboard</span><span class="o">::</span><span class="n">Mode</span><span class="p">)),</span><span class="n">this</span><span class="p">,</span><span class="n">SLOT</span><span class="p">(</span><span class="n">clipboardChanged</span><span class="p">(</span><span class="n">QClipboard</span><span class="o">::</span><span class="n">Mode</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QImage</h2>

<blockquote><ol>
<li>QImage在像素处理上得到了优化，QPixmap使用了视频存储器，它也是需要在屏幕上显示图片的多种窗件要用到的类。可以吧QImage转换成QPixmap并将其在QLabel进行显示</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="nf">h</span><span class="p">(</span><span class="n">m_Image</span><span class="p">.</span><span class="n">height</span><span class="p">()),</span><span class="n">w</span><span class="p">(</span><span class="n">m_Image</span><span class="p">.</span><span class="n">width</span><span class="p">());</span>
</span><span class='line'><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="n">QRgb</span> <span class="n">oldpix</span><span class="p">,</span><span class="n">newpix</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">y</span><span class="o">&lt;</span><span class="n">h</span><span class="p">;</span><span class="n">y</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">x</span><span class="o">&lt;</span><span class="n">w</span><span class="p">;</span><span class="n">x</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>      <span class="n">oldpix</span><span class="o">=</span><span class="n">m_Image</span><span class="p">.</span><span class="n">pixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>      <span class="n">r</span><span class="o">=</span><span class="n">qRed</span><span class="p">(</span><span class="n">oldpix</span><span class="p">)</span><span class="o">*</span><span class="n">radj</span><span class="p">;</span>
</span><span class='line'>      <span class="n">g</span><span class="o">=</span><span class="n">qGreen</span><span class="p">(</span><span class="n">oldpix</span><span class="p">)</span><span class="o">*</span><span class="n">gadj</span><span class="p">;</span>
</span><span class='line'>      <span class="n">b</span><span class="o">=</span><span class="n">qBlue</span><span class="p">(</span><span class="n">oldpix</span><span class="p">)</span><span class="o">*</span><span class="n">badj</span><span class="p">;</span>
</span><span class='line'>      <span class="n">newpix</span><span class="o">=</span><span class="n">qRgb</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>      <span class="n">m_Image</span><span class="p">.</span><span class="n">setPix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">newpix</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>模板类</h2>

<blockquote><p>因为每个Q_OBJECT都需要通过moc为其生成代码，而且moc并未智能到知道如何生成模板类的特化，孤儿不允许使一个已经标记为Q_OBJECT的类再次成为模板类</p></blockquote>

<h2>qSort</h2>

<blockquote><ol>
<li>qSort()函数是一个使用堆分类算法进行实现的范型方法。qSort()可以应用到任何Qt容器，只要容器内的对象拥有公共接口operator&lt;()和operator==()。基本数据类型的容器也可以使用此函数进行排序</li>
</ol>
</blockquote>

<h2>反射与元对象</h2>

<blockquote><ol>
<li>所谓反射，就是指对象成员的自我检查，使用反射编程，就可以编写出通用的操作，可对具有各种不同结构的类进行操作。使用通用的值存储器QVariant，就可以按照一种统一的方式来对基本类型和其他普通类型进行操作</li>
<li>所谓元对象就是描述另一个对象结构的对象。QMetaObject是元对象模式的一个Qt实现，它提供了一个QObject对象所拥有的属性和方法的信息。元对象模式有时也称为反射模式</li>
<li>一个拥有元对象的类就可以支持反射。这是一个许多面向对象语言都具有的性质。虽然C++中不存在反射，但Qt的元对象编译器(moc)可以为QObject生成支持这种机制的代码</li>
<li>只要满足一定条件(每个类都必须在头文件中定义，并且列举在工程文件的HEADERS中，同时此类的定义中还必须包括Q_OBJECT宏)，每个派生自QObject的类都会拥有一个有moc为其生成的QMetaObject。QObject拥有有个成员函数，它能够返回指向对象的QMetaObject的指针，这个函数原型是：QMetaObject* QObject：：metaObject() const[virtual]</li>
<li>可以使用QMetaObject的下面这些方法来获取一个QObject的信息：

<ul>
<li>className(),它会将类的名称以const char*格式返回</li>
<li>superClass(),如果存在基类的QMetaObject，则返回其指针，如果不存在返回0</li>
<li>mathodCount(),返回类的成员函数的个数</li>
</ul>
</li>
<li>信号和槽机制同样需要依赖与QMetaObject</li>
<li>通过使用QMetaObject和QMetaProperty就可以编写足够通用的代码来处理所有具有自我描述能力的类</li>
<li>除了C++的RTTI运算符dynamic_cast和typeid之外，Qt还提供了两种运行时的类型识别机制：

<ul>
<li>qobject_cast</li>
<li>QObject::inherits()</li>
</ul>
</li>
<li>qobject_cast是一个ANSI风格的类型转换运算符：DestType<em> qobject_cast&lt;DestType</em>> (QObject* qoptr),如果转换失败返回NULL。qobject_cast实际是一个向下转换运算符，类似于dynamic_cast。拥有指向派生类的基类指针时，向下转换允许调用在基类接口中不存在的派生类方法。</li>
<li>访问数据成员的方式：

<ul>
<li>直接访问，通过经典的gettet/settet，速度快，更为有效</li>
<li>间接访问，通过QObject/QMetaObject接口，可让代码复用性更好</li>
</ul>
</li>
<li>使用Q_PROPERTY宏来描述QObject的属性：Q_PROPERTY(type name READ getFunction [WRITE setFunction] [RESET resetFunction] [NOTIFY notifySignal] [DESIGNABLE bool] [SCRIPTABLE bool] [STORED bool]),例如：</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span>customer-props.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">class</span> <span class="nl">Customer</span><span class="p">:</span><span class="n">public</span> <span class="n">QObject</span><span class="p">{</span>
</span><span class='line'>  <span class="n">Q_OBJECT</span>         <span class="c1">//moc预处理类需要的宏</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">id</span> <span class="n">READ</span> <span class="n">getId</span> <span class="n">WRITE</span> <span class="n">setId</span> <span class="n">NOTIFY</span> <span class="n">valueChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">name</span> <span class="n">READ</span> <span class="n">getName</span> <span class="n">WRITE</span> <span class="n">setName</span> <span class="n">NOTIFY</span> <span class="n">valueChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">address</span> <span class="n">READ</span> <span class="n">getAddress</span> <span class="n">WRITE</span> <span class="n">setAddress</span> <span class="n">NOTIFY</span> <span class="n">addressChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">phone</span> <span class="n">READ</span> <span class="n">getPhone</span> <span class="n">WRITE</span> <span class="n">setPhone</span> <span class="n">NOTIFY</span> <span class="n">phoneChanged</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QDate</span> <span class="n">dateEstablished</span> <span class="n">READ</span> <span class="n">getDateEstablished</span><span class="p">);</span>     <span class="c1">//只读属性</span>
</span><span class='line'>  <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">type</span> <span class="n">READ</span> <span class="n">getType</span> <span class="n">WRITE</span> <span class="n">setType</span> <span class="n">NOTIFY</span> <span class="n">valueChanged</span><span class="p">);</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">CustomerType</span><span class="p">{</span>
</span><span class='line'>              <span class="n">Corporate</span><span class="p">,</span><span class="n">Individual</span><span class="p">,</span><span class="n">Educational</span><span class="p">,</span><span class="n">Government</span>
</span><span class='line'>                  <span class="p">};</span>                                               <span class="c1">//枚举类型定义必须与Q_ENUMS宏的定义出现在同一类定义中</span>
</span><span class='line'>  <span class="n">Q_ENUMS</span><span class="p">(</span><span class="n">CustomerType</span><span class="p">);</span>                                          <span class="c1">//特殊的宏可以实现生成字符串到枚举之间的转换功能；必须在同一个类中</span>
</span><span class='line'>  <span class="n">explicit</span> <span class="nf">Customer</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="n">name</span> <span class="o">=</span> <span class="n">QString</span><span class="p">(),</span><span class="n">QObject</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//之所以声明为explicit，是因为不希望从QString转换到Customer时出现意外</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">getId</span> <span class="k">const</span><span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">m_id</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">setType</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">newType</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">setType</span><span class="p">(</span><span class="n">QString</span> <span class="n">newType</span><span class="p">);</span>
</span><span class='line'><span class="nl">signals</span><span class="p">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">addressChanged</span><span class="p">(</span><span class="n">QString</span> <span class="n">newAddress</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="n">QString</span> <span class="n">propertyName</span><span class="p">,</span><span class="n">QVariant</span> <span class="n">newValue</span><span class="p">,</span><span class="n">QVariant</span> <span class="n">oldValue</span><span class="o">=</span><span class="n">QVariant</span><span class="p">());</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">phoneChanged</span><span class="p">(</span><span class="n">QString</span> <span class="n">newPhone</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">typeChanged</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">type</span><span class="p">);</span>
</span><span class='line'><span class="nl">private</span><span class="p">:</span>
</span><span class='line'>  <span class="n">QString</span> <span class="n">m_id</span><span class="p">,</span><span class="n">m_name</span><span class="p">,</span><span class="n">m_address</span><span class="p">,</span><span class="n">m_phone</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QDate</span> <span class="n">m_date</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CustomerType</span> <span class="n">m_type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>customer-props.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">Customer</span><span class="o">::</span><span class="n">Customer</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="n">name</span><span class="p">,</span><span class="n">QObject</span><span class="o">*</span> <span class="n">parent</span><span class="p">)</span><span class="o">:</span><span class="n">QObject</span><span class="p">(</span><span class="n">parent</span><span class="p">){</span>
</span><span class='line'>  <span class="n">setObjectName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Customer</span><span class="o">::</span><span class="n">setId</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">newId</span><span class="p">){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">newId</span> <span class="o">!=</span> <span class="n">m_id</span><span class="p">){</span>
</span><span class='line'>      <span class="n">QString</span> <span class="n">oldId</span> <span class="o">=</span> <span class="n">m_id</span><span class="p">;</span>
</span><span class='line'>      <span class="n">m_id</span> <span class="o">=</span> <span class="n">newId</span><span class="p">;</span>
</span><span class='line'>      <span class="n">emit</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">,</span><span class="n">newId</span><span class="p">,</span><span class="n">oldId</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Customer</span><span class="o">::</span><span class="n">setType</span><span class="p">(</span><span class="n">CustomerType</span> <span class="n">theType</span><span class="p">){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">m_type</span> <span class="o">!=</span> <span class="n">theType</span><span class="p">){</span>
</span><span class='line'>      <span class="n">CustomerType</span> <span class="n">oldType</span> <span class="o">=</span> <span class="n">m_type</span><span class="p">;</span>
</span><span class='line'>      <span class="n">m_type</span> <span class="o">=</span> <span class="n">theType</span><span class="p">;</span>
</span><span class='line'>      <span class="n">emit</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">,</span><span class="n">theType</span><span class="p">,</span><span class="n">oldType</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">Customer</span><span class="o">::</span><span class="n">setType</span><span class="p">(</span><span class="n">QString</span> <span class="n">newType</span><span class="p">){</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="n">QMetaObject</span><span class="o">*</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">metaObject</span><span class="p">();</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">propindex</span> <span class="o">=</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">indexOfProperty</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">static</span> <span class="k">const</span> <span class="n">QMetaProperty</span> <span class="n">mp</span> <span class="o">=</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="n">propindex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">QMetaEnum</span> <span class="n">menum</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">enumerator</span><span class="p">();</span>
</span><span class='line'>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ntyp</span> <span class="o">=</span> <span class="n">newType</span><span class="p">.</span><span class="n">toAscii</span><span class="p">().</span><span class="n">data</span><span class="p">();</span>
</span><span class='line'>  <span class="n">CustomerType</span> <span class="n">theType</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">CustomerType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">menum</span><span class="p">.</span><span class="n">keyToValue</span><span class="p">(</span><span class="n">ntyp</span><span class="p">));</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">theType</span> <span class="o">!=</span> <span class="n">m_type</span><span class="p">){</span>
</span><span class='line'>      <span class="n">CustomerType</span> <span class="n">oldType</span> <span class="o">=</span> <span class="n">m_type</span><span class="p">;</span>
</span><span class='line'>      <span class="n">m_type</span> <span class="o">=</span> <span class="n">theType</span><span class="p">;</span>
</span><span class='line'>      <span class="n">emit</span> <span class="nf">valueChanged</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">,</span><span class="n">theType</span><span class="p">,</span><span class="n">oldType</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">QString</span> <span class="n">Customer</span><span class="o">::</span><span class="n">getTypeString</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">property</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">).</span><span class="n">toString</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>可以通多下面的函数来获得任意属性的值：QVariant QObject::property(QString propertyName);
QVariant是一个联合体的封装，其中包含了所有基本类型和所允许的全部Q_PROPERTY类型。QVariant有一个toString()函数能够为它支持的许多类型返回其QString表示。
QVariant对象可以通过QMetaProperty::read()或者QObject::property()获得
同一类的所有对象会共享同一个metaObject，因而会有相同元属性组</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QString</span> <span class="nf">objTOString</span><span class="p">(</span><span class="k">const</span> <span class="n">QObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
</span><span class='line'>  <span class="n">QStringList</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="k">const</span> <span class="n">QMetaObject</span><span class="o">*</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">metaObject</span><span class="p">();</span>
</span><span class='line'>  <span class="n">result</span> <span class="o">+=</span> <span class="n">QString</span><span class="p">(</span><span class="s">&quot;class %1:public %2 {&quot;</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">className</span><span class="p">()).</span><span class="n">arg</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">superClass</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">className</span><span class="p">());</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">propertyCount</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span><span class='line'>      <span class="k">const</span> <span class="n">QMetaProperty</span> <span class="n">qmp</span><span class="o">=</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>      <span class="n">QVariant</span> <span class="n">value</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="n">qmp</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">canConvert</span><span class="p">(</span><span class="n">QVariant</span><span class="o">::</span><span class="n">String</span><span class="p">)){</span>
</span><span class='line'>          <span class="n">result</span> <span class="o">+=</span> <span class="n">QString</span><span class="p">(</span><span class="s">&quot;%1 %2=%3;&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">qmp</span><span class="p">.</span><span class="n">typeName</span><span class="p">())</span>
</span><span class='line'>          <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">qmp</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
</span><span class='line'>          <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;};&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QMetaType</h2>

<blockquote><ol>
<li>QMetaType是一个用于值类型的辅助类，对于60多种内置类型，QMetaType为每个类型ID关联了一个类型名，从而使构造和析构可以在运行时动态发生。有一个名称为QMetaType::Type的公共枚举，它有所有QVariant兼容类型的值。在QMetaType::Type中的枚举值与QVariant::Type中的枚举值一样
通过使用Q_ENUMS宏可以在QVariant系统中加入一些自定义的枚举类型。
使用Q_DECLARE_METATYPE(MyType)宏也有可能把自己的值类型加到QMetaType列表中。如果MyType有公共的默认复制构造函数和公共的复制构造函数以及一个公共的析构函数，Q_DECLARE_METATYPE宏使得它可用作QVariant中的自定义类型
要注册的元类型必须已经用Q_DECLARE_METATYPE声明过。模板函数qRegisterMetaType<T>()会注册类型T并返回由QMetaType使用的内部ID。这个函数有一个重载版本，qRegisterMetaType<T>(const char* name),它可以让你注册一个名称作为类型T的名称。对于这个函数的调用必须早早地出现在主程序中。</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span>fraction.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">class</span> <span class="nl">Fraction</span><span class="p">:</span><span class="n">public</span> <span class="n">QPair</span><span class="o">&lt;</span><span class="n">qint32</span><span class="p">,</span><span class="n">qint32</span><span class="o">&gt;</span><span class="p">{</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>  <span class="n">Fraction</span><span class="p">(</span><span class="n">qint32</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">qint32</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="n">QPair</span><span class="o">&lt;</span><span class="n">qint32</span><span class="p">,</span><span class="n">qint32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">d</span><span class="p">){}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">Q_DECLARE_METATYPE</span><span class="p">(</span><span class="n">Fraction</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span>metatype.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
</span><span class='line'>  <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">);</span>
</span><span class='line'>  <span class="n">qRegissterMetaType</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Fraction&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Fraction</span> <span class="n">twoThirds</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QVariant</span> <span class="n">var</span><span class="p">;</span>
</span><span class='line'>  <span class="n">var</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">twoThirds</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">var</span><span class="p">.</span><span class="n">value</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="n">twoThirds</span><span class="p">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">Fraction</span> <span class="n">oneHalf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Fraction</span> <span class="n">threeQuarters</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QList</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span> <span class="n">fractions</span><span class="p">;</span>
</span><span class='line'>  <span class="n">fractions</span><span class="o">&lt;&lt;</span><span class="n">oneHalf</span><span class="o">&lt;&lt;</span><span class="n">twoThirds</span><span class="o">&lt;&lt;</span><span class="n">threeQuarters</span><span class="p">;</span>
</span><span class='line'>  <span class="n">QFile</span> <span class="n">binaryTestFile</span><span class="p">(</span><span class="s">&quot;testMetaType.bin&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QDataStream</span> <span class="n">dout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binaryTestFile</span><span class="p">);</span>
</span><span class='line'>  <span class="n">dout</span><span class="o">&lt;&lt;</span><span class="n">fractions</span><span class="p">;</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">QIODevice</span><span class="o">::</span><span class="n">ReadOnly</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QDataStream</span> <span class="n">din</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binaryTestFile</span><span class="p">);</span>
</span><span class='line'>  <span class="n">QList</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span> <span class="n">frac2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">din</span> <span class="o">&gt;&gt;</span> <span class="n">frac2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">binaryTestFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span><span class='line'>  <span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">fractions</span> <span class="o">==</span> <span class="n">frac2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">creatTest</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">creatTest</span><span class="p">(){</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">fracType</span> <span class="o">=</span> <span class="n">QMetaType</span><span class="o">::</span><span class="n">type</span><span class="p">(</span><span class="s">&quot;Fraction&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span><span class="o">*</span> <span class="n">vp</span> <span class="o">=</span> <span class="n">QMetaType</span><span class="o">::</span><span class="n">construct</span><span class="p">(</span><span class="n">fracType</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Fraction</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">vp</span><span class="p">);</span>
</span><span class='line'>  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">first</span>  <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Q_ASSERT</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span> <span class="o">==</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>invokeMethod()</h2>

<blockquote><ol>
<li>Qt把信号连接到槽需要一种机制：通过名称以类型安全的方式来间接调用这些槽，当调用槽时，实际是由invokeMethod()完成的。</li>
<li>与QObject::connect()类似，invokeMethod()接受一个可选参数Qt::ConnectionType,该参数可让你来决定是要用同步调用还是要用异步调用。默认情况下是Qt::AutoConnection，表示发射者和接收者处于同一线程中时会同步执行一个槽</li>
<li>要通过invokeMethod()向函数传递类型参数，可以用Q_ARG宏创建一些值，这样会返回一个QGenericArgument，它封装了单个参数的类型和值信息</li>
</ol>
</blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="kt">void</span> <span class="n">AutoSaver</span><span class="o">::</span><span class="n">saveIfNecessary</span><span class="p">(){</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">QMetaObject</span><span class="o">::</span><span class="n">invokeMethod</span><span class="p">(</span><span class="n">parent</span><span class="p">(),</span><span class="s">&quot;save&quot;</span><span class="p">)){</span>
</span><span class='line'>      <span class="n">qWarning</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&quot;AutoSaver:error invoking save() on parent&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QByteArray</span> <span class="n">buffer</span><span class="o">=</span><span class="p">...;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="n">QMetaObject</span><span class="o">::</span><span class="n">invokeMethod</span><span class="p">(</span><span class="n">m_thread</span><span class="p">,</span><span class="s">&quot;caculateSpectrum&quot;</span><span class="p">,</span><span class="n">Qt</span><span class="o">::</span><span class="n">AutoConnection</span><span class="p">,</span><span class="n">Q_ARG</span><span class="p">(</span><span class="n">QByteArray</span><span class="p">,</span><span class="n">buffer</span><span class="p">),</span><span class="n">Q_ARG</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">format</span><span class="p">.</span><span class="n">frequency</span><span class="p">()),</span><span class="n">Q_ARG</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">bytesPerSample</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>MVC设计模式</h2>

<blockquote><ol>
<li>MVC由三类对象组成。模型是应用程序对象，视图是它的屏幕展示，控制器定义了用户界面对用户输入的反应行为。</li>
<li>在Qt中，不同的控制器类的基类是QAbstractItemDelegate。那些连接信号与槽的connect语句也可以认为是控制器代码</li>
<li>Qt中包含有一个模型/视图框架，用于维护数据的组织管理和向用户的呈现方式之间的分离。三个最常用的视图类(列表、树和表格)都是默认提供的。另外，它还提供了抽象的和具体的数据模型，这些数据模型可被扩展和自定义以保存不同类型的数据。</li>
<li>视图是获取、修改和呈现数据的对象。QAbstractItemModel定义了视图(还有委托)访问数据的一个标准接口。模型中存储供显示和操作的具体数据。通过信号和槽，他们将数据的变化通知给所有相关联的视图。每个视图对象都有一个指向模型对象的指针，视图对象会频繁访问模型的方法以获取或设置数据，或者做各种其他操作。</li>
<li>模型中每个数据项都用一个模型索引来表示。模型索引为视图和委托提供了在不知道其底层数据结构的情况下间接访问模型中数据项的方法。QModeIndex对象由模型创建，可以被模型、视图或委托代码用于定位数据模型中特定项。QModeIndex对象具有很短的生命周期，可能在刚刚创建后就变成无效的状态，因此它们应该被立即使用而后丢弃</li>
<li>如果使用一个在若干指令操作前已经存在的QModeIndex，那么应该先调用QModelIndex::isValid（）。QPersistentModelIndex对象具有更长的生命周期，但是在使用前任然应该先调用isValid()来进行检查</li>
</ol>
</blockquote>

<h2>智能指针</h2>

<blockquote><ol>
<li>一个重写了指针解引用操作operator*()和operator->()的类被称为智能指针。</li>
<li>QScopedPointer是一个在指针作用域结束后自动删除所引用对象的智能指针。它类似于std::auto_ptr。复制QScopedPointer是毫无意义的，因为它会导致所引用的对象重复删除</li>
<li>QSharedPointer是一个自动删除它所引用的对象的智能指针，但是它允许被复制，而且QSharedPointer会保持一个引用计数。共享的堆对象只有在最后一个指向它的只能指针销毁时才会被删除。</li>
</ol>
</blockquote>

<h2>输入掩码</h2>

<blockquote><p>1.所谓的输入掩码，是一种控制用户在输入窗件中可键入的内容的主动模式。它有助于防止输入某些类型的不正确的数据。每个QLineEdit都有一个QString属性用来存储掩码字符。输入掩码可以指定在键入QLineEdit的字符串中那个位置处的何种字符是允许的。该字符串由一些特殊的、预定义的掩码字符和一些占据输入字符串相应位置的普通字符构成
掩码字符：
    * A:ASCII字母型字符——大写或者小写
    * N:ASCII字母数字型字符——大写或者小写
    * X:任意的ASCII字符
    * D:ASCII非零数字
    * 9:ASCII数字
    * H:十六进制数字
    * B:二进制数字
    * >:随后的字母字符是大写
    * &lt;:随后的字母字符是小写
    * ！:结束大小写转换
    * :转义字符</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="n">QLineEdit</span><span class="o">*</span> <span class="n">m_StringEntry</span><span class="p">;</span>
</span><span class='line'><span class="n">m_StringEntry</span><span class="o">-&gt;</span><span class="n">setInputMask</span><span class="p">(</span><span class="n">m_InputMask</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<h2>QRegExp</h2>

<blockquote><ol>
<li>正则表达式是验证输入、从输入中提取数据以及对输入进行搜索和替换的强大工具。Qt提供了QRegExp类，它实现了Perl风格的扩展正则表达式语言的大部分功能</li>
<li>特殊字符：

<ul>
<li>&lsquo;.'可以与任意字符相匹配，称之为元字符</li>
<li>&lsquo;\n'匹配换行符</li>
<li>&lsquo;\f'匹配换页符</li>
<li>&lsquo;\t'匹配制表符</li>
<li>&lsquo;\xhhhh'匹配一个Unicode字符，其对应的码值是范围为0x0000到0xFFFF之间的一个十六进制数hhhh</li>
</ul>
</li>
<li>量词——说明前面的字符(或字符组)在匹配的表达式中可出现次数的修饰符

<ul>
<li>&lsquo;+&rsquo; 出现1次或者更多次</li>
<li>&lsquo;?&rsquo; 出现0次或者1次</li>
<li>&lsquo;*&rsquo; 出现0次或者更多次</li>
<li>{i,j} 出现至少i次但不超过j次</li>
</ul>
</li>
<li>字符集——在匹配表达式指定位置允许出现的字符集合

<ul>
<li>&lsquo;\s&rsquo; 匹配任何空白符</li>
<li>&lsquo;\S&rsquo; 匹配任何非空白符</li>
<li>&lsquo;\d&rsquo; 匹配任何数字字符：从'0'到'9'</li>
<li>&lsquo;\D&rsquo; 匹配任何非数字字符</li>
<li>&lsquo;\w&rsquo; 匹配任何“单词”字符，也就是任意的字母、数字或者下划线</li>
<li>&lsquo;\W&rsquo; 匹配任意的非单词字符</li>
</ul>
</li>
<li>字符集也可以使用方括号指定:

<ul>
<li>[AEIOU]匹配这五个字符中的任意一个</li>
<li>[a-g]短线使此集合可匹配从'a'到'g'的字符</li>
<li>[^xyz]匹配任何除这三字符以外的字符</li>
</ul>
</li>
<li>分组和捕获字符——(圆括号)是可以用来把字符划分成组的特殊字符。字符组可以是后向引用的。也就是说，如果存在一个匹配，那么分组了的值将可以通过各种方法来捕获和访问。为了简便起见，一般规定在一个正则表达式中最多可以引用9个分组，即使用\1到\9这样的修饰符。此外还有一个QRegExp成员函数cap(int nth),它返回第那个分组(基于QString的形式返回)</li>
<li>锚点字符——去顶尝试进行匹配操作的边界

<ul>
<li>脱字符(^),如果它是正则表达式中的第一个字符，则说明匹配过程从字符串的开头处开始</li>
<li>美元符($),如果它是正则表达式的最后一个字符，则表明匹配过程指导字符串的结尾才结束</li>
<li>此外，还有单词边界(\b)断言或者非单词边界(\B),有助于我们关注正则表达式本身</li>
</ul>
</li>
</ol>
</blockquote>

<h2>Qt环境变量的获取与设置</h2>

<blockquote><p>QProcess::environment()函数和setEnvironment()函数</p></blockquote>

<h2>QProcess和进程控制</h2>

<blockquote><ol>
<li>QProcess是一个能够非常方便而且跨平台的用于启动和控制其他进程的类。它从QPbject派生而来，可充分利用信号和槽来简化和其他Qt类的交互</li>
<li>一个QProcess可以使用start()函数来启动另外一个进程，新进程将会成为一个子进程并且在父进程终止时而随之终止</li>
<li>Qt的线程模型允许线程的优先次序和控制。QThread是一个低级类，适合用于显式的构建长期运行的线程</li>
<li>QtConcurrent是一个命名空间，提供了用于编写并发软件的更高层次的类和算法。该命名空间有一个重要的类，QThreadPool，这是一个管理线程池的类。每个Qt应用程序都有一个QThreadPool::globalInstance()函数，它带有一个推荐的最大线程数，在大多数系统上，处理核的数量就是该值的默认值</li>
<li>借助QtConcurrent中函数式的map/filter/reduce算法，通过将进程分布在由线程池管理的多个线程上，可编写一个能够自动利用系统多核的程序。另外，在命令模式和利用QtConcurrent::run()工作时可把QRunnable用作基类。在这些情况下，无须显示地创建线程或者直接管理他们，只需简单把工作片段描述为具有正确接口的对象即可</li>
</ol>
</blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-19T20:52:44+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/qt4/'>qt4</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/13/ut4418-introduce/">
		
			UT4418_Introduce</a>
	</h2>
	<div class="entry-content">
		<h2>S5PV4418简介</h2>

<blockquote><p>S5PV4418处理器是三星2014年推出的4核处理器，使用Cortex-A9四核心，整体性能比Cortex-A8核心高出50%，提供6.4GB/s内存带宽，支持1080P的全高清视频输出，以及3D图形显示，支持LCD显示1080P高清电视输出等。完全是Exynos4412的升级版芯片，性能远远超过Exynos4412，并且基本兼容Exynos412</p></blockquote>

<h2>开发板配置</h2>

<ol>
<li>4G iNand(SDIN5C1-4G),1G DDR3(H5TQ4G63AFR-PBC),三星电源管理芯片&ndash;NXE2000</li>
<li>尺寸：120mm*90mm</li>
<li>TF卡支持热插拔，容量最大支持32G</li>
<li>设有开机键，长按3秒后开机</li>
<li>设有复位键，长按3秒后硬件复位，在系统启动后，可以通过软件去配置PMU来改变复位键长按时间的长短</li>
<li>通过SDA7123转换出VGA信号，VGA支持LCD同步显示，支持1080P视频输出</li>
<li>HDMI信号通过MCU直接引出，减少了转换芯片的链接，支持与LCD同步播放视频，支持的视频输出格式为480P，720P,1080P</li>
<li>以太网接口采用RTL8211E-VB-CG芯片，支持10M，100M，1000M网自适应</li>
<li>配置了USB接口的wifi模块&ndash;RTL8188</li>
<li>配置了FT-009红外接收头，支持红外遥控接收</li>
</ol>


<h2>开发环境搭建</h2>

<ol>
<li>使用虚拟机VirtualBox安装Ubuntu14.04.2LTS系统</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-13T13:10:17+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/s5pv4418/'>s5pv4418</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/06/poe-introduce/">
		
			POE简介</a>
	</h2>
	<div class="entry-content">
		<p><img src="http://i.imgur.com/G9gjcdZ.png" alt="什么是POE" /></p>

<blockquote><p>以太网供电（Power over Ethernet，简称PoE）也称为PoE供电，是一种可以在以太网路中透过双绞线来传输电力与资料到装置上的技术。以太网供电技术的出发点是让IP电话、WLAN接入点、网络摄像头等小型网络设备，可以直接从以太网线（4对双绞线中空闲的2对来传输）获得电力，无需单独铺设电力线，以简化系统布线，降低网络基础设施的建设成本。</p></blockquote>

<h2>使用POE的注意事项</h2>

<blockquote><p>使用POE需要留意以下三点：</p>

<ol>
<li>如上图所示，不是所有的以太网交换机都支持PoE供电功能，供电模块内置或外置，一般价格比普通交换贵一些。</li>
<li>要求终端也支持PoE受电功能。</li>
<li>通过网线供电，功率本身是有一定限制的，留意查看不同设备的使用说明和功率要求。</li>
</ol>
</blockquote>

<h2>典型的系统</h2>

<blockquote><p>一个典型的以太网供电系统。在配线柜里保留以太网交换机设备，用一个带电源供电集线器(Midspan HUB)给局域网的双绞线提供电源。在双绞线的末端，该电源用来驱动电话、无线接入点、相机和其他设备。为避免断电，可以选用一个UPS。</p></blockquote>

<h2>原理</h2>

<blockquote><p>标准的五类网线有<strong>四对双绞线</strong>,但是在10M BASE-T和100M BASE-T中只用到其中的<strong>两对</strong>。IEEE80 2.3af允许<strong>两种</strong>用法:</p>

<ol>
<li>应用空闲脚供电时,4、5脚连接为正极,7、8脚连接为负极。</li>
<li>应用数据脚供电时,将DC电源加在传输变压器的中点,不影响数据的传输。在这种方式下线对1、2和线对3、6可以为任意极性。</li>
</ol>


<p>IEEE802.3af标准不允许同时应用以上两种情况。电源提供设备PSE只能提供一种用法,但是电源应用设备PD必须能够同时适应两种情况。该标准规定供电电源通常是48V、13W的。PD设备提供48V到低电压的转换是较容易的,但同时应有1500V的绝缘安全电压。</p></blockquote>

<p><img src="http://i.imgur.com/uRd8v4m.png" alt="POE典型组网图" /></p>

<h2>参数</h2>

<blockquote><p>一个完整的POE系统包括供电端设备(PSE, Power Sourcing Equipment)和受电端设备(PD, Powered Device)两部分。PSE设备是为以太网客户端设备供电的设备,同时也是整个POE以太网供电过程的管理者。而PD设备是接受供电的PSE负载,即POE系统的客户端设备,如IP电话、网络安全摄像机、AP及掌上电脑( PDA)或移动电话充电器等许多其他以太网设备（实际上,任何功率不超过13W的设备都可以从RJ45插座获取相应的电力）。</p>

<p>POE标准供电系统的主要供电特性参数为：</p>

<ol>
<li>电压在44～57V之间,典型值为48V。</li>
<li>允许最大电流为550mA,最大启动电流为500mA。</li>
<li>典型工作电流为10～350mA,超载检测电流为350～500mA。</li>
<li>在空载条件下,最大需要电流为5mA。</li>
<li>为PD设备提供3.84～12.95W三个等级的电功率请求,最大不超过13W。（注意PD分级0和分级4没有显示出来而且不应采用。）</li>
<li>2009年10月30日 IEEE出了一个最新的802.3at标准，其中规定了POE可以提供更高的功率，超过了13W，可以达到30W,分三个等级(7W,15.4W,30W)</li>
<li>一般设备上会标明：15.4W/802.3af,30W/802.3at</li>
</ol>
</blockquote>

<h2>工作过程</h2>

<ol>
<li>检测

<ul>
<li>一开始,PSE设备在端口输出很小的电压,直到其检测到线缆终端的连接为一个支持IEEE 802.3af标准的受电端设备。检测电源输出线对之间的阻容值来判断PD是否存在</li>
</ul>
</li>
<li>PD端设备分类

<ul>
<li>当检测到受电端设备PD之后,PSE设备可能会为PD设备进行分类,并且评估此PD设备所需的功率损耗。</li>
</ul>
</li>
<li>开始供电

<ul>
<li>在一个可配置时间(一般小于15μs)的启动期内,PSE设备开始从低电压向PD设备供电,直至提供48V的直流电源。</li>
</ul>
</li>
<li>供电

<ul>
<li>为PD设备提供稳定可靠48V的直流电,满足PD设备不越过 30W的功率消耗。</li>
</ul>
</li>
<li>断电

<ul>
<li>若PD设备从网络上断开时,PSE就会快速地(一般在300～400ms之内)停止为PD设备供电,并重复检测过程以检测线缆的终端是否连接PD设备。</li>
</ul>
</li>
</ol>


<h2>HY931147C网络接口(RJ45，集成网络变压器，POE电源信号分离)</h2>

<p><img src="http://i.imgur.com/vkG79aZ.png" alt="内部结构图" />
1. 两个二极管桥确保1236和4578都能用来供电，同时也能确保12作为正或者36作为正互相兼容</p>

<h2>POE电源工作回路</h2>

<ol>
<li>IEEE 802.3af：15.4W供电功率，在100米最大电缆损耗条件下可传送13W的功率</li>
<li>IEEE 802.3at：30W供电功率，在100米最大电缆损耗条件下可输送25.5W的功率
<img src="http://i.imgur.com/R9UCls3.png" alt="POE电源工作回路" /></li>
</ol>


<h2>POE等级界限（按终端设备划分）</h2>

<ol>
<li>Class1：可向PD输送3.84W的最大功率</li>
<li>CLass2：可向PD输送6.49W的最大功率</li>
<li>Class3：可向PD输送13.0W的最大功率</li>
<li>Class4：可向PD输送25.5W的最大功率</li>
</ol>


<h2>POE工作原理</h2>

<ol>
<li>检测

<ol>
<li>处理PSE的使用以确保远端是PD所期望的功率</li>
<li>避免损坏那些不兼容POE标准的老式设备</li>
<li>低电压、低电流限制探测功能电路寻找25K特征电阻</li>
</ol>
</li>
<li>分级

<ol>
<li>用于确定PD所需功率的任选过程</li>
<li>可对电源管理有所帮助</li>
<li>中间电压/电流限制探测功能电路寻找四个电流吸收器之一</li>
<li>仅在成功的检测之后进行</li>
</ol>
</li>
<li>电源维护

<ol>
<li>确保在PD断连时将高压电源拿掉</li>
</ol>
</li>
<li>过流

<ol>
<li>在链路操作的不同阶段所提供的保护有所不同</li>
<li>防止不良事件的发生</li>
<li>确保在发生PD或电缆布线系统问题时将电源拿掉
<img src="http://i.imgur.com/Jh1B0xr.png" alt="POE周期图" /></li>
</ol>
</li>
</ol>


<h2>线性稳压器</h2>

<ol>
<li>优点

<ol>
<li>低输出纹波和噪声，无EMI问题</li>
<li>低成本</li>
<li>简单，所需的外部组件极少，易于配置和设计</li>
<li>面对大的负载阶跃，可在Vout上实现快速瞬态响应</li>
<li>易于实现短路保护</li>
</ol>
</li>
<li>缺点

<ol>
<li>低效率</li>
<li>热问题</li>
<li>Vout必须低于Vin</li>
</ol>
</li>
<li>工作原理

<ol>
<li>线性稳压器和输出阻抗一起形成了一个分压网络</li>
<li>线型稳压器的作用就像受控的可变电阻器，其可根据输出负载自我调节以保持一个稳定的输出</li>
</ol>
</li>
<li>压降电压：为使线性稳压器处在稳压器的指定工作范围之内，VIN与VOUT之间可接受的最小压差</li>
<li>线型稳压器中的元件可以是双极型晶体管或MOSFET。不同的配置将产生不同的压降电压

<ol>
<li>双极型线型稳压器具有较高的压降电压，并能支持较高的输入电压且拥有更好的瞬态响应</li>
<li>MOSFET LDO能支持非常低的压降、低静态电流、改善的噪声性能和低电源抑制</li>
</ol>
</li>
<li>静态电流：由稳压器所消耗且不流向输出负载的电流

<ol>
<li>该规格指标对于需要时钟保持运行的应用（如基带、实时时钟）很重要</li>
</ol>
</li>
<li>电源抑制比（PSRR）：已调输出电压纹波与输入电压纹波之比

<ol>
<li>该规格指标对于具有高噪声限值要求的应用（如低噪声放大器、音频、RF和无线等）很重要</li>
</ol>
</li>
<li>基带噪声：某个特定频率范围内的总噪声能量

<ol>
<li>该规格指标对于具有高噪声限值要求的应用（如PLL、TXCO、RF和无线等）很重要
<img src="http://i.imgur.com/7wrqQCt.png" alt="LDO的选择" /></li>
</ol>
</li>
</ol>


<h2>开关稳压器</h2>

<ol>
<li>优点

<ol>
<li>高效率</li>
<li>优良的热性能</li>
<li>高功率密度</li>
<li>允许宽输入电压范围</li>
<li>Vout可以低于或高于Vin</li>
<li>可利用变压器提供隔离</li>
<li>可利用变压器提供多个输出</li>
</ol>
</li>
<li>缺点

<ol>
<li>开关操作会产生较高的输出纹波和噪声</li>
<li>缓慢的瞬态响应（响应带宽约为开关频率的1/10）</li>
<li>高复杂性</li>
</ol>
</li>
<li>工作原理

<ol>
<li>电感负责储存能量及向输出负载释放能量</li>
<li>电感根据开关管的开通从输入端获得能量</li>
</ol>
</li>
<li>三种基本的直流开关变换器拓扑（公式推导基于电感的平均电压为0，D为PWM占空比）
<img src="http://i.imgur.com/4mqTm8J.png" alt="基本拓扑" /></li>
<li>同步与非同步
<img src="http://i.imgur.com/hxTCszv.png" alt="同步与非同步" /></li>
<li>隔离式与非隔离式

<ol>
<li>隔离式变换器在输入和输出之间没有电流回路，原副边不同地</li>
<li>变压器通过磁场将能量从初级耦合至次级</li>
<li>隔离式变换器通常在需要提供初级至次级不同地，高可靠性、防雷、耐高压等，如隔离的医疗电源</li>
<li>并非标准负载点电源（POL）解决方案所常用</li>
<li>不仅要电气隔离，还要信号隔离，所以反馈回路需要使用光耦
<img src="http://i.imgur.com/ncj4TY4.png" alt="隔离开关电源" /></li>
</ol>
</li>
</ol>


<h2>电荷泵稳压器</h2>

<ol>
<li>电荷泵稳压器是一种只通过电容器的交替式充电和放点来传送功率的开关稳压器</li>
<li>它适合于具有低负载电流及中等输入-输出电压差的应用</li>
<li>开关操作会产生较高的输出纹波和噪声，输出电流能力受限于电容器</li>
<li>倍压电路
<img src="http://i.imgur.com/8p5zBIr.png" alt="倍压电路" /></li>
</ol>


<h2>变换器控制系统</h2>

<ol>
<li>由于在电路中实现了闭环控制系统，因此变换器能够在不同的条件下提供一个恒定的电压输出
<img src="http://i.imgur.com/G4Rr42H.png" alt="控制系统工作原理" /></li>
</ol>


<h2>UVLO(低电压锁定)</h2>

<p>欠压关断模式可保证IC在供电电压不足的时候不至于损坏，一个低电压锁定（UVLO）电路可确保IC在电池电压未达到安全操作电压前不会激活，UVLO的功能会展示滞后现象，以确保在电源供应上的噪音不会不慎导致系统故障。为了更稳定的工作，某些DC/DC转换器具有UVLO功能，电源开启后，UVLO功能使内部电路处于待机状态，直到DC/DC转换器的输入电压达到UVLO电压，以此来减少消费电流并避免误操作</p>

<h2>TPS54160（1.5A,60V,降压DC/DC转换器）</h2>

<ol>
<li>支持3.5V~60V的输入电压范围</li>
<li>内部高端MOSFET的导通电阻200mΩ。（low side一般指MOSFET接地，其驱动信号是基于地信号的，在驱动电路中不需要加电压抬升电路；如果是high side即常说的高端驱动，其驱动信号是浮动的，需要加电压抬升电路）</li>
<li>低负载的转换效率也很高，因为设计了独特的Pulse Skipping Eco-mode</li>
<li>可调节的UVLO电压和滞后时间</li>
<li>116uA的静态工作电流</li>
<li>1.3uA的关断电流</li>
<li>100KHz~2.5MHz的开关频率</li>
<li>与外部时钟同步</li>
<li>内部有0.8V的参考电压</li>
<li>欠压（UV）输出保护内部默认设置为2.5V，但是可以通过EN引脚来提高</li>
<li>输出电压启动坡度可以通过SS（slow start）引脚来控制
<img src="http://i.imgur.com/TSjMe8c.png" alt="简化的原理图" /></li>
<li>在BOOT引脚和PH（内部高端MOEFET的源极）引脚之间需要一个自举电容，当其上的电压少于器件的最低要求，输出将会被关闭，直到自举电容被刷新</li>
<li>COMP是误差放大器的输出，并且会输入到内部的电流比较器中。这个引脚需要连接频率补偿元件</li>
<li>EN脚电压低于1.2后会使芯片不工作，悬空可以工作（芯片内部该引脚上拉到电流源）。要求电压范围不超过5V</li>
<li>PWRGD开漏输出，如果芯片过压、关断、跌落，该引脚会输出低电平</li>
<li>RT(Resistor Timing)/CLK内部的放大器会使该引脚维持在一个固定的电压值，该引脚通过一个连接到地的电阻来设置开关频率</li>
<li>SS/TR该引脚到地的电容可以设置输出电压的抬升时间，降低启动过程中的浪涌电流</li>
<li>VSENSE反馈电压不能超过3V</li>
<li>电流模式控制可以降低输出电容，简化频率补偿
<img src="http://i.imgur.com/n8qTBGt.png" alt="内部结构图" /></li>
<li>输出电压调节
<img src="http://i.imgur.com/PPkiol6.png" alt="调节输出电压" /></li>
<li>如果Vin电压小于2.5V，那么TPS54160将不工作，如果需要更高的UVLO电压，可以如图所示
<img src="http://i.imgur.com/7U5iiB1.png" alt="提高UVLO" /></li>
<li>开关频率由以下公式确定
<img src="http://i.imgur.com/EcqbYXX.png" alt="开关频率确定公式" /></li>
<li>PCB Layout要领

<ol>
<li>Vin需要使用低等效串联电阻(ESR)的陶瓷电容旁路，可以选择X5R或者X7R的陶瓷电容</li>
<li>减小由旁路电容的连线，Vin引脚和续流二极管的正极所构成的回路</li>
<li>power pad连接到GND，并且通过多个过孔连接至地平面</li>
<li>续流二极管的阴极和输出电感需要靠近PH引脚</li>
<li>Rt电阻离RT/CLK引脚的距离越近越好
<img src="http://i.imgur.com/Itr7Gst.png" alt="Layout举例" /></li>
</ol>
</li>
</ol>


<h2>开尔文连接</h2>

<p>开尔文连接是一种用于模拟信号远传的连接方法，其特点是不在驱动器的输出端直接连接反馈到反相端，而是从负载端将反馈接到驱动器的反相端的而一种连接方法，其目的是减小线路电阻引起的误差</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-06T20:16:12+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/poe/'>poe</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/06/29/about-nginx/">
		
			初识Nginx</a>
	</h2>
	<div class="entry-content">
		<h2>Nginx简介</h2>

<blockquote><ol>
<li>Nginx是一种服务器软件，Nginx是一种高性能的HTTP和反向代理服务器，同时是一个代理邮件服务器，也就是Ngix上可以发布网站，也可以实现负载均衡，还可以作为邮件服务器实现收发邮件的功能</li>
<li>所谓负载均衡，是指当同时有N多个用户访问我们服务器的时候，为了减小服务器压力，我们需要将用户分别引入各服务器，分担服务器压力</li>
<li>优点：高并发，部署简单，内存消耗少，成本低</li>
<li>缺点：rewrite功能不够强大，模块没有Apache多</li>
</ol>
</blockquote>

<h2>其它服务器</h2>

<ol>
<li>IIS服务器只能在Windows上运行，Windows服务器性能不如Linux服务器</li>
<li>Tomcat服务器面向的是Java语言，是一种重量级的服务器</li>
<li>Apache服务器稳定，开源，跨平台，但是不支持高并发</li>
</ol>


<h2>Nginx环境的搭建</h2>

<ol>
<li><a href="http://nginx.org">进入官网下载最新版</a></li>
<li>安装gcc:<code>yum -y install gcc gcc-c++ autoconf automake</code></li>
<li>安装PCRE库文件：<code>yum -y install pcre pcre-devel</code></li>
<li>安装zlib库文件：<code>yum -y install zlib zlib-devel</code></li>
<li>解压缩Nginx压缩包，然后进入解压后文件夹，<code>./config --prefix=/software</code>,成功后执行<code>make $$ make install</code></li>
<li>启动服务器：<code>/software/nginx/sbin/nginx -c /software/nginx/conf/nginx.conf</code></li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-06-29T10:21:37+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/nginx/'>nginx</a>, <a class='category' href='/blog/categories/study/'>study</a>


</div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/06/27/c-language-review/">
		
			C语言知识点</a>
	</h2>
	<div class="entry-content">
		<h2><code>#ifdef和#if defined的差别</code></h2>

<p>注意两者都有个define的作用，区别在于使用方式上。前者的通常用法是:</p>

<figure class='code'><figcaption><span>只能在两者中选择是否有定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#ifdef  XXX</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于后者，常用法是：</p>

<figure class='code'><figcaption><span>可以在多个中选择是否有定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#if defined xxx1</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#elif defined xxx2</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#elif defined xxx3</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">....</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<h2>小细节</h2>

<ol>
<li>C++并不支持void*隐式转换为其他类型的指针，但是C语言允许</li>
<li>变量命名，所有字符都使用小写，含义多的可以用<strong>_</strong>进行辅助</li>
<li>全局变量能少用就少用，必须要用的情况下，可以考虑添加前缀<strong>g_</strong></li>
<li>不要将<strong>_</strong>作为宏的开头或者结尾</li>
<li>要使用<strong>#if</strong>而不是<strong>#ifdef</strong>，可以使用<strong>define（）</strong>来替代<strong>#ifdef</strong>的功能</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="cp">#if !define(USERS_DEFINE)</span>
</span><span class='line'>      <span class="cp">#define USERS_DEFINE ...</span>
</span><span class='line'> <span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<h2>volatile关键字</h2>

<p>一旦使用了，就是告诉编译器，即使这个变量没有被使用或修改其他内存单元，它的值也可能发生变化。通俗地讲，告诉编译器，不要把你的那一套优化策略用在我的身上</p>

<h2>两种不太常见的格式：%[]和%*</h2>

<ol>
<li>%[]用于限制读取类型，常见于字符串的过滤。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="c1">//假设输入：22 hello,string to me!</span>
</span><span class='line'><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %[a-z]&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span><span class="c1">//22 hello</span>
</span><span class='line'><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %[^i]&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span><span class="c1">//22 hello,str</span>
</span><span class='line'><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %[^,]&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span><span class="c1">//22 hello</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>%*是忽略第一个输入，也可以理解为文件宽度(域宽)</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'><span class="c1">//假设输入：22 33</span>
</span><span class='line'><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%*d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span><span class="c1">//读到33</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='C'><span class='line'> <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;dir&quot;</span><span class="p">;</span>
</span><span class='line'> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%*s%s&quot;</span><span class="p">,</span><span class="mi">4</span> <span class="p">,</span><span class="s">&quot;&quot;</span> <span class="p">,</span> <span class="n">str</span><span class="p">);</span><span class="c1">//输出:    dir,前面有四个空白占位   </span>
</span></code></pre></td></tr></table></div></figure>


<h2>select机制</h2>

<ol>
<li>select()的机制中提供一fd_set的数据结构，实际上是一long类型的数组， 每一个数组元素都能与一打开的文件句柄（不管是Socket句柄，还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读或可写。</li>
<li>程序去select的时候，如果没有数据输入，程序会一直等待，直到有数据为止，也就是程序中无需循环和sleep</li>
<li>使用Select就可以完成非阻塞（所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生，则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的程序，它能够监视我们需要监视的文件描述符的变化情况——读写或是异常。</li>
<li>返回值：准备就绪的描述符数，若超时则返回0，若出错则返回-1。</li>
</ol>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-06-27T15:17:24+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/c/'>c</a>, <a class='category' href='/blog/categories/study/'>study</a>


</div>
	
</div>
</article>

<nav id="pagenavi">
    
        
            <a href="/posts/4" class="prev">Prev</a>
        
    
    
        <a href="/posts/6" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    suda-morris

Powered by Octopress-WenRis Group
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>